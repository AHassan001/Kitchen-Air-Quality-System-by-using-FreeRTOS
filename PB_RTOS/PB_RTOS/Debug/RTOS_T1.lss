
RTOS_T1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006c16  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000154  00800060  00006c16  00006caa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000651  008001b4  008001b4  00006dfe  2**0
                  ALLOC
  3 .stab         00008f1c  00000000  00000000  00006e00  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000543e  00000000  00000000  0000fd1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  0001515a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001f2  00000000  00000000  000152fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000240b  00000000  00000000  000154ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001386  00000000  00000000  000178f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011d6  00000000  00000000  00018c7d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  00019e54  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f6  00000000  00000000  0001a014  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000096e  00000000  00000000  0001a30a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001ac78  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 30 0d 	jmp	0x1a60	; 0x1a60 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e1       	ldi	r30, 0x16	; 22
      68:	fc e6       	ldi	r31, 0x6C	; 108
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 3b       	cpi	r26, 0xB4	; 180
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	18 e0       	ldi	r17, 0x08	; 8
      78:	a4 eb       	ldi	r26, 0xB4	; 180
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 30       	cpi	r26, 0x05	; 5
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 4a 34 	call	0x6894	; 0x6894 <main>
      8a:	0c 94 09 36 	jmp	0x6c12	; 0x6c12 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 7d 35 	jmp	0x6afa	; 0x6afa <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a9 ea       	ldi	r26, 0xA9	; 169
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 99 35 	jmp	0x6b32	; 0x6b32 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 89 35 	jmp	0x6b12	; 0x6b12 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 a5 35 	jmp	0x6b4a	; 0x6b4a <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 89 35 	jmp	0x6b12	; 0x6b12 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 a5 35 	jmp	0x6b4a	; 0x6b4a <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 7d 35 	jmp	0x6afa	; 0x6afa <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	89 ea       	ldi	r24, 0xA9	; 169
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 99 35 	jmp	0x6b32	; 0x6b32 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 85 35 	jmp	0x6b0a	; 0x6b0a <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	69 ea       	ldi	r22, 0xA9	; 169
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 a1 35 	jmp	0x6b42	; 0x6b42 <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 89 35 	jmp	0x6b12	; 0x6b12 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 a5 35 	jmp	0x6b4a	; 0x6b4a <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 89 35 	jmp	0x6b12	; 0x6b12 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 a5 35 	jmp	0x6b4a	; 0x6b4a <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 89 35 	jmp	0x6b12	; 0x6b12 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 a5 35 	jmp	0x6b4a	; 0x6b4a <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 8d 35 	jmp	0x6b1a	; 0x6b1a <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 a9 35 	jmp	0x6b52	; 0x6b52 <__epilogue_restores__+0x20>

00000952 <__floatunsisf>:
     952:	a8 e0       	ldi	r26, 0x08	; 8
     954:	b0 e0       	ldi	r27, 0x00	; 0
     956:	ef ea       	ldi	r30, 0xAF	; 175
     958:	f4 e0       	ldi	r31, 0x04	; 4
     95a:	0c 94 85 35 	jmp	0x6b0a	; 0x6b0a <__prologue_saves__+0x10>
     95e:	7b 01       	movw	r14, r22
     960:	8c 01       	movw	r16, r24
     962:	61 15       	cp	r22, r1
     964:	71 05       	cpc	r23, r1
     966:	81 05       	cpc	r24, r1
     968:	91 05       	cpc	r25, r1
     96a:	19 f4       	brne	.+6      	; 0x972 <__floatunsisf+0x20>
     96c:	82 e0       	ldi	r24, 0x02	; 2
     96e:	89 83       	std	Y+1, r24	; 0x01
     970:	60 c0       	rjmp	.+192    	; 0xa32 <__floatunsisf+0xe0>
     972:	83 e0       	ldi	r24, 0x03	; 3
     974:	89 83       	std	Y+1, r24	; 0x01
     976:	8e e1       	ldi	r24, 0x1E	; 30
     978:	c8 2e       	mov	r12, r24
     97a:	d1 2c       	mov	r13, r1
     97c:	dc 82       	std	Y+4, r13	; 0x04
     97e:	cb 82       	std	Y+3, r12	; 0x03
     980:	ed 82       	std	Y+5, r14	; 0x05
     982:	fe 82       	std	Y+6, r15	; 0x06
     984:	0f 83       	std	Y+7, r16	; 0x07
     986:	18 87       	std	Y+8, r17	; 0x08
     988:	c8 01       	movw	r24, r16
     98a:	b7 01       	movw	r22, r14
     98c:	0e 94 22 05 	call	0xa44	; 0xa44 <__clzsi2>
     990:	fc 01       	movw	r30, r24
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	f7 ff       	sbrs	r31, 7
     996:	3b c0       	rjmp	.+118    	; 0xa0e <__floatunsisf+0xbc>
     998:	22 27       	eor	r18, r18
     99a:	33 27       	eor	r19, r19
     99c:	2e 1b       	sub	r18, r30
     99e:	3f 0b       	sbc	r19, r31
     9a0:	57 01       	movw	r10, r14
     9a2:	68 01       	movw	r12, r16
     9a4:	02 2e       	mov	r0, r18
     9a6:	04 c0       	rjmp	.+8      	; 0x9b0 <__floatunsisf+0x5e>
     9a8:	d6 94       	lsr	r13
     9aa:	c7 94       	ror	r12
     9ac:	b7 94       	ror	r11
     9ae:	a7 94       	ror	r10
     9b0:	0a 94       	dec	r0
     9b2:	d2 f7       	brpl	.-12     	; 0x9a8 <__floatunsisf+0x56>
     9b4:	40 e0       	ldi	r20, 0x00	; 0
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	a0 e0       	ldi	r26, 0x00	; 0
     9c2:	b0 e0       	ldi	r27, 0x00	; 0
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__floatunsisf+0x7c>
     9c6:	88 0f       	add	r24, r24
     9c8:	99 1f       	adc	r25, r25
     9ca:	aa 1f       	adc	r26, r26
     9cc:	bb 1f       	adc	r27, r27
     9ce:	2a 95       	dec	r18
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__floatunsisf+0x74>
     9d2:	01 97       	sbiw	r24, 0x01	; 1
     9d4:	a1 09       	sbc	r26, r1
     9d6:	b1 09       	sbc	r27, r1
     9d8:	8e 21       	and	r24, r14
     9da:	9f 21       	and	r25, r15
     9dc:	a0 23       	and	r26, r16
     9de:	b1 23       	and	r27, r17
     9e0:	00 97       	sbiw	r24, 0x00	; 0
     9e2:	a1 05       	cpc	r26, r1
     9e4:	b1 05       	cpc	r27, r1
     9e6:	21 f0       	breq	.+8      	; 0x9f0 <__floatunsisf+0x9e>
     9e8:	41 e0       	ldi	r20, 0x01	; 1
     9ea:	50 e0       	ldi	r21, 0x00	; 0
     9ec:	60 e0       	ldi	r22, 0x00	; 0
     9ee:	70 e0       	ldi	r23, 0x00	; 0
     9f0:	4a 29       	or	r20, r10
     9f2:	5b 29       	or	r21, r11
     9f4:	6c 29       	or	r22, r12
     9f6:	7d 29       	or	r23, r13
     9f8:	4d 83       	std	Y+5, r20	; 0x05
     9fa:	5e 83       	std	Y+6, r21	; 0x06
     9fc:	6f 83       	std	Y+7, r22	; 0x07
     9fe:	78 87       	std	Y+8, r23	; 0x08
     a00:	8e e1       	ldi	r24, 0x1E	; 30
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	8e 1b       	sub	r24, r30
     a06:	9f 0b       	sbc	r25, r31
     a08:	9c 83       	std	Y+4, r25	; 0x04
     a0a:	8b 83       	std	Y+3, r24	; 0x03
     a0c:	12 c0       	rjmp	.+36     	; 0xa32 <__floatunsisf+0xe0>
     a0e:	30 97       	sbiw	r30, 0x00	; 0
     a10:	81 f0       	breq	.+32     	; 0xa32 <__floatunsisf+0xe0>
     a12:	0e 2e       	mov	r0, r30
     a14:	04 c0       	rjmp	.+8      	; 0xa1e <__floatunsisf+0xcc>
     a16:	ee 0c       	add	r14, r14
     a18:	ff 1c       	adc	r15, r15
     a1a:	00 1f       	adc	r16, r16
     a1c:	11 1f       	adc	r17, r17
     a1e:	0a 94       	dec	r0
     a20:	d2 f7       	brpl	.-12     	; 0xa16 <__floatunsisf+0xc4>
     a22:	ed 82       	std	Y+5, r14	; 0x05
     a24:	fe 82       	std	Y+6, r15	; 0x06
     a26:	0f 83       	std	Y+7, r16	; 0x07
     a28:	18 87       	std	Y+8, r17	; 0x08
     a2a:	ce 1a       	sub	r12, r30
     a2c:	df 0a       	sbc	r13, r31
     a2e:	dc 82       	std	Y+4, r13	; 0x04
     a30:	cb 82       	std	Y+3, r12	; 0x03
     a32:	1a 82       	std	Y+2, r1	; 0x02
     a34:	ce 01       	movw	r24, r28
     a36:	01 96       	adiw	r24, 0x01	; 1
     a38:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     a3c:	28 96       	adiw	r28, 0x08	; 8
     a3e:	ea e0       	ldi	r30, 0x0A	; 10
     a40:	0c 94 a1 35 	jmp	0x6b42	; 0x6b42 <__epilogue_restores__+0x10>

00000a44 <__clzsi2>:
     a44:	ef 92       	push	r14
     a46:	ff 92       	push	r15
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	7b 01       	movw	r14, r22
     a4e:	8c 01       	movw	r16, r24
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	e8 16       	cp	r14, r24
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	f8 06       	cpc	r15, r24
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	08 07       	cpc	r16, r24
     a5c:	80 e0       	ldi	r24, 0x00	; 0
     a5e:	18 07       	cpc	r17, r24
     a60:	88 f4       	brcc	.+34     	; 0xa84 <__clzsi2+0x40>
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	e8 16       	cp	r14, r24
     a66:	f1 04       	cpc	r15, r1
     a68:	01 05       	cpc	r16, r1
     a6a:	11 05       	cpc	r17, r1
     a6c:	31 f0       	breq	.+12     	; 0xa7a <__clzsi2+0x36>
     a6e:	28 f0       	brcs	.+10     	; 0xa7a <__clzsi2+0x36>
     a70:	88 e0       	ldi	r24, 0x08	; 8
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	a0 e0       	ldi	r26, 0x00	; 0
     a76:	b0 e0       	ldi	r27, 0x00	; 0
     a78:	17 c0       	rjmp	.+46     	; 0xaa8 <__clzsi2+0x64>
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	a0 e0       	ldi	r26, 0x00	; 0
     a80:	b0 e0       	ldi	r27, 0x00	; 0
     a82:	12 c0       	rjmp	.+36     	; 0xaa8 <__clzsi2+0x64>
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	e8 16       	cp	r14, r24
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	f8 06       	cpc	r15, r24
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	08 07       	cpc	r16, r24
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	18 07       	cpc	r17, r24
     a94:	28 f0       	brcs	.+10     	; 0xaa0 <__clzsi2+0x5c>
     a96:	88 e1       	ldi	r24, 0x18	; 24
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	04 c0       	rjmp	.+8      	; 0xaa8 <__clzsi2+0x64>
     aa0:	80 e1       	ldi	r24, 0x10	; 16
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	a0 e0       	ldi	r26, 0x00	; 0
     aa6:	b0 e0       	ldi	r27, 0x00	; 0
     aa8:	20 e2       	ldi	r18, 0x20	; 32
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	40 e0       	ldi	r20, 0x00	; 0
     aae:	50 e0       	ldi	r21, 0x00	; 0
     ab0:	28 1b       	sub	r18, r24
     ab2:	39 0b       	sbc	r19, r25
     ab4:	4a 0b       	sbc	r20, r26
     ab6:	5b 0b       	sbc	r21, r27
     ab8:	04 c0       	rjmp	.+8      	; 0xac2 <__clzsi2+0x7e>
     aba:	16 95       	lsr	r17
     abc:	07 95       	ror	r16
     abe:	f7 94       	ror	r15
     ac0:	e7 94       	ror	r14
     ac2:	8a 95       	dec	r24
     ac4:	d2 f7       	brpl	.-12     	; 0xaba <__clzsi2+0x76>
     ac6:	f7 01       	movw	r30, r14
     ac8:	ef 54       	subi	r30, 0x4F	; 79
     aca:	ff 4f       	sbci	r31, 0xFF	; 255
     acc:	80 81       	ld	r24, Z
     ace:	28 1b       	sub	r18, r24
     ad0:	31 09       	sbc	r19, r1
     ad2:	41 09       	sbc	r20, r1
     ad4:	51 09       	sbc	r21, r1
     ad6:	c9 01       	movw	r24, r18
     ad8:	1f 91       	pop	r17
     ada:	0f 91       	pop	r16
     adc:	ff 90       	pop	r15
     ade:	ef 90       	pop	r14
     ae0:	08 95       	ret

00000ae2 <__pack_f>:
     ae2:	df 92       	push	r13
     ae4:	ef 92       	push	r14
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	fc 01       	movw	r30, r24
     aee:	e4 80       	ldd	r14, Z+4	; 0x04
     af0:	f5 80       	ldd	r15, Z+5	; 0x05
     af2:	06 81       	ldd	r16, Z+6	; 0x06
     af4:	17 81       	ldd	r17, Z+7	; 0x07
     af6:	d1 80       	ldd	r13, Z+1	; 0x01
     af8:	80 81       	ld	r24, Z
     afa:	82 30       	cpi	r24, 0x02	; 2
     afc:	48 f4       	brcc	.+18     	; 0xb10 <__pack_f+0x2e>
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	a0 e1       	ldi	r26, 0x10	; 16
     b04:	b0 e0       	ldi	r27, 0x00	; 0
     b06:	e8 2a       	or	r14, r24
     b08:	f9 2a       	or	r15, r25
     b0a:	0a 2b       	or	r16, r26
     b0c:	1b 2b       	or	r17, r27
     b0e:	a5 c0       	rjmp	.+330    	; 0xc5a <__pack_f+0x178>
     b10:	84 30       	cpi	r24, 0x04	; 4
     b12:	09 f4       	brne	.+2      	; 0xb16 <__pack_f+0x34>
     b14:	9f c0       	rjmp	.+318    	; 0xc54 <__pack_f+0x172>
     b16:	82 30       	cpi	r24, 0x02	; 2
     b18:	21 f4       	brne	.+8      	; 0xb22 <__pack_f+0x40>
     b1a:	ee 24       	eor	r14, r14
     b1c:	ff 24       	eor	r15, r15
     b1e:	87 01       	movw	r16, r14
     b20:	05 c0       	rjmp	.+10     	; 0xb2c <__pack_f+0x4a>
     b22:	e1 14       	cp	r14, r1
     b24:	f1 04       	cpc	r15, r1
     b26:	01 05       	cpc	r16, r1
     b28:	11 05       	cpc	r17, r1
     b2a:	19 f4       	brne	.+6      	; 0xb32 <__pack_f+0x50>
     b2c:	e0 e0       	ldi	r30, 0x00	; 0
     b2e:	f0 e0       	ldi	r31, 0x00	; 0
     b30:	96 c0       	rjmp	.+300    	; 0xc5e <__pack_f+0x17c>
     b32:	62 81       	ldd	r22, Z+2	; 0x02
     b34:	73 81       	ldd	r23, Z+3	; 0x03
     b36:	9f ef       	ldi	r25, 0xFF	; 255
     b38:	62 38       	cpi	r22, 0x82	; 130
     b3a:	79 07       	cpc	r23, r25
     b3c:	0c f0       	brlt	.+2      	; 0xb40 <__pack_f+0x5e>
     b3e:	5b c0       	rjmp	.+182    	; 0xbf6 <__pack_f+0x114>
     b40:	22 e8       	ldi	r18, 0x82	; 130
     b42:	3f ef       	ldi	r19, 0xFF	; 255
     b44:	26 1b       	sub	r18, r22
     b46:	37 0b       	sbc	r19, r23
     b48:	2a 31       	cpi	r18, 0x1A	; 26
     b4a:	31 05       	cpc	r19, r1
     b4c:	2c f0       	brlt	.+10     	; 0xb58 <__pack_f+0x76>
     b4e:	20 e0       	ldi	r18, 0x00	; 0
     b50:	30 e0       	ldi	r19, 0x00	; 0
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
     b56:	2a c0       	rjmp	.+84     	; 0xbac <__pack_f+0xca>
     b58:	b8 01       	movw	r22, r16
     b5a:	a7 01       	movw	r20, r14
     b5c:	02 2e       	mov	r0, r18
     b5e:	04 c0       	rjmp	.+8      	; 0xb68 <__pack_f+0x86>
     b60:	76 95       	lsr	r23
     b62:	67 95       	ror	r22
     b64:	57 95       	ror	r21
     b66:	47 95       	ror	r20
     b68:	0a 94       	dec	r0
     b6a:	d2 f7       	brpl	.-12     	; 0xb60 <__pack_f+0x7e>
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	a0 e0       	ldi	r26, 0x00	; 0
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <__pack_f+0x9c>
     b76:	88 0f       	add	r24, r24
     b78:	99 1f       	adc	r25, r25
     b7a:	aa 1f       	adc	r26, r26
     b7c:	bb 1f       	adc	r27, r27
     b7e:	2a 95       	dec	r18
     b80:	d2 f7       	brpl	.-12     	; 0xb76 <__pack_f+0x94>
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	a1 09       	sbc	r26, r1
     b86:	b1 09       	sbc	r27, r1
     b88:	8e 21       	and	r24, r14
     b8a:	9f 21       	and	r25, r15
     b8c:	a0 23       	and	r26, r16
     b8e:	b1 23       	and	r27, r17
     b90:	00 97       	sbiw	r24, 0x00	; 0
     b92:	a1 05       	cpc	r26, r1
     b94:	b1 05       	cpc	r27, r1
     b96:	21 f0       	breq	.+8      	; 0xba0 <__pack_f+0xbe>
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a0 e0       	ldi	r26, 0x00	; 0
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
     ba0:	9a 01       	movw	r18, r20
     ba2:	ab 01       	movw	r20, r22
     ba4:	28 2b       	or	r18, r24
     ba6:	39 2b       	or	r19, r25
     ba8:	4a 2b       	or	r20, r26
     baa:	5b 2b       	or	r21, r27
     bac:	da 01       	movw	r26, r20
     bae:	c9 01       	movw	r24, r18
     bb0:	8f 77       	andi	r24, 0x7F	; 127
     bb2:	90 70       	andi	r25, 0x00	; 0
     bb4:	a0 70       	andi	r26, 0x00	; 0
     bb6:	b0 70       	andi	r27, 0x00	; 0
     bb8:	80 34       	cpi	r24, 0x40	; 64
     bba:	91 05       	cpc	r25, r1
     bbc:	a1 05       	cpc	r26, r1
     bbe:	b1 05       	cpc	r27, r1
     bc0:	39 f4       	brne	.+14     	; 0xbd0 <__pack_f+0xee>
     bc2:	27 ff       	sbrs	r18, 7
     bc4:	09 c0       	rjmp	.+18     	; 0xbd8 <__pack_f+0xf6>
     bc6:	20 5c       	subi	r18, 0xC0	; 192
     bc8:	3f 4f       	sbci	r19, 0xFF	; 255
     bca:	4f 4f       	sbci	r20, 0xFF	; 255
     bcc:	5f 4f       	sbci	r21, 0xFF	; 255
     bce:	04 c0       	rjmp	.+8      	; 0xbd8 <__pack_f+0xf6>
     bd0:	21 5c       	subi	r18, 0xC1	; 193
     bd2:	3f 4f       	sbci	r19, 0xFF	; 255
     bd4:	4f 4f       	sbci	r20, 0xFF	; 255
     bd6:	5f 4f       	sbci	r21, 0xFF	; 255
     bd8:	e0 e0       	ldi	r30, 0x00	; 0
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	20 30       	cpi	r18, 0x00	; 0
     bde:	a0 e0       	ldi	r26, 0x00	; 0
     be0:	3a 07       	cpc	r19, r26
     be2:	a0 e0       	ldi	r26, 0x00	; 0
     be4:	4a 07       	cpc	r20, r26
     be6:	a0 e4       	ldi	r26, 0x40	; 64
     be8:	5a 07       	cpc	r21, r26
     bea:	10 f0       	brcs	.+4      	; 0xbf0 <__pack_f+0x10e>
     bec:	e1 e0       	ldi	r30, 0x01	; 1
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	79 01       	movw	r14, r18
     bf2:	8a 01       	movw	r16, r20
     bf4:	27 c0       	rjmp	.+78     	; 0xc44 <__pack_f+0x162>
     bf6:	60 38       	cpi	r22, 0x80	; 128
     bf8:	71 05       	cpc	r23, r1
     bfa:	64 f5       	brge	.+88     	; 0xc54 <__pack_f+0x172>
     bfc:	fb 01       	movw	r30, r22
     bfe:	e1 58       	subi	r30, 0x81	; 129
     c00:	ff 4f       	sbci	r31, 0xFF	; 255
     c02:	d8 01       	movw	r26, r16
     c04:	c7 01       	movw	r24, r14
     c06:	8f 77       	andi	r24, 0x7F	; 127
     c08:	90 70       	andi	r25, 0x00	; 0
     c0a:	a0 70       	andi	r26, 0x00	; 0
     c0c:	b0 70       	andi	r27, 0x00	; 0
     c0e:	80 34       	cpi	r24, 0x40	; 64
     c10:	91 05       	cpc	r25, r1
     c12:	a1 05       	cpc	r26, r1
     c14:	b1 05       	cpc	r27, r1
     c16:	39 f4       	brne	.+14     	; 0xc26 <__pack_f+0x144>
     c18:	e7 fe       	sbrs	r14, 7
     c1a:	0d c0       	rjmp	.+26     	; 0xc36 <__pack_f+0x154>
     c1c:	80 e4       	ldi	r24, 0x40	; 64
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	a0 e0       	ldi	r26, 0x00	; 0
     c22:	b0 e0       	ldi	r27, 0x00	; 0
     c24:	04 c0       	rjmp	.+8      	; 0xc2e <__pack_f+0x14c>
     c26:	8f e3       	ldi	r24, 0x3F	; 63
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	a0 e0       	ldi	r26, 0x00	; 0
     c2c:	b0 e0       	ldi	r27, 0x00	; 0
     c2e:	e8 0e       	add	r14, r24
     c30:	f9 1e       	adc	r15, r25
     c32:	0a 1f       	adc	r16, r26
     c34:	1b 1f       	adc	r17, r27
     c36:	17 ff       	sbrs	r17, 7
     c38:	05 c0       	rjmp	.+10     	; 0xc44 <__pack_f+0x162>
     c3a:	16 95       	lsr	r17
     c3c:	07 95       	ror	r16
     c3e:	f7 94       	ror	r15
     c40:	e7 94       	ror	r14
     c42:	31 96       	adiw	r30, 0x01	; 1
     c44:	87 e0       	ldi	r24, 0x07	; 7
     c46:	16 95       	lsr	r17
     c48:	07 95       	ror	r16
     c4a:	f7 94       	ror	r15
     c4c:	e7 94       	ror	r14
     c4e:	8a 95       	dec	r24
     c50:	d1 f7       	brne	.-12     	; 0xc46 <__pack_f+0x164>
     c52:	05 c0       	rjmp	.+10     	; 0xc5e <__pack_f+0x17c>
     c54:	ee 24       	eor	r14, r14
     c56:	ff 24       	eor	r15, r15
     c58:	87 01       	movw	r16, r14
     c5a:	ef ef       	ldi	r30, 0xFF	; 255
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	6e 2f       	mov	r22, r30
     c60:	67 95       	ror	r22
     c62:	66 27       	eor	r22, r22
     c64:	67 95       	ror	r22
     c66:	90 2f       	mov	r25, r16
     c68:	9f 77       	andi	r25, 0x7F	; 127
     c6a:	d7 94       	ror	r13
     c6c:	dd 24       	eor	r13, r13
     c6e:	d7 94       	ror	r13
     c70:	8e 2f       	mov	r24, r30
     c72:	86 95       	lsr	r24
     c74:	49 2f       	mov	r20, r25
     c76:	46 2b       	or	r20, r22
     c78:	58 2f       	mov	r21, r24
     c7a:	5d 29       	or	r21, r13
     c7c:	b7 01       	movw	r22, r14
     c7e:	ca 01       	movw	r24, r20
     c80:	1f 91       	pop	r17
     c82:	0f 91       	pop	r16
     c84:	ff 90       	pop	r15
     c86:	ef 90       	pop	r14
     c88:	df 90       	pop	r13
     c8a:	08 95       	ret

00000c8c <__unpack_f>:
     c8c:	fc 01       	movw	r30, r24
     c8e:	db 01       	movw	r26, r22
     c90:	40 81       	ld	r20, Z
     c92:	51 81       	ldd	r21, Z+1	; 0x01
     c94:	22 81       	ldd	r18, Z+2	; 0x02
     c96:	62 2f       	mov	r22, r18
     c98:	6f 77       	andi	r22, 0x7F	; 127
     c9a:	70 e0       	ldi	r23, 0x00	; 0
     c9c:	22 1f       	adc	r18, r18
     c9e:	22 27       	eor	r18, r18
     ca0:	22 1f       	adc	r18, r18
     ca2:	93 81       	ldd	r25, Z+3	; 0x03
     ca4:	89 2f       	mov	r24, r25
     ca6:	88 0f       	add	r24, r24
     ca8:	82 2b       	or	r24, r18
     caa:	28 2f       	mov	r18, r24
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	99 1f       	adc	r25, r25
     cb0:	99 27       	eor	r25, r25
     cb2:	99 1f       	adc	r25, r25
     cb4:	11 96       	adiw	r26, 0x01	; 1
     cb6:	9c 93       	st	X, r25
     cb8:	11 97       	sbiw	r26, 0x01	; 1
     cba:	21 15       	cp	r18, r1
     cbc:	31 05       	cpc	r19, r1
     cbe:	a9 f5       	brne	.+106    	; 0xd2a <__unpack_f+0x9e>
     cc0:	41 15       	cp	r20, r1
     cc2:	51 05       	cpc	r21, r1
     cc4:	61 05       	cpc	r22, r1
     cc6:	71 05       	cpc	r23, r1
     cc8:	11 f4       	brne	.+4      	; 0xcce <__unpack_f+0x42>
     cca:	82 e0       	ldi	r24, 0x02	; 2
     ccc:	37 c0       	rjmp	.+110    	; 0xd3c <__unpack_f+0xb0>
     cce:	82 e8       	ldi	r24, 0x82	; 130
     cd0:	9f ef       	ldi	r25, 0xFF	; 255
     cd2:	13 96       	adiw	r26, 0x03	; 3
     cd4:	9c 93       	st	X, r25
     cd6:	8e 93       	st	-X, r24
     cd8:	12 97       	sbiw	r26, 0x02	; 2
     cda:	9a 01       	movw	r18, r20
     cdc:	ab 01       	movw	r20, r22
     cde:	67 e0       	ldi	r22, 0x07	; 7
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	44 1f       	adc	r20, r20
     ce6:	55 1f       	adc	r21, r21
     ce8:	6a 95       	dec	r22
     cea:	d1 f7       	brne	.-12     	; 0xce0 <__unpack_f+0x54>
     cec:	83 e0       	ldi	r24, 0x03	; 3
     cee:	8c 93       	st	X, r24
     cf0:	0d c0       	rjmp	.+26     	; 0xd0c <__unpack_f+0x80>
     cf2:	22 0f       	add	r18, r18
     cf4:	33 1f       	adc	r19, r19
     cf6:	44 1f       	adc	r20, r20
     cf8:	55 1f       	adc	r21, r21
     cfa:	12 96       	adiw	r26, 0x02	; 2
     cfc:	8d 91       	ld	r24, X+
     cfe:	9c 91       	ld	r25, X
     d00:	13 97       	sbiw	r26, 0x03	; 3
     d02:	01 97       	sbiw	r24, 0x01	; 1
     d04:	13 96       	adiw	r26, 0x03	; 3
     d06:	9c 93       	st	X, r25
     d08:	8e 93       	st	-X, r24
     d0a:	12 97       	sbiw	r26, 0x02	; 2
     d0c:	20 30       	cpi	r18, 0x00	; 0
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	38 07       	cpc	r19, r24
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	48 07       	cpc	r20, r24
     d16:	80 e4       	ldi	r24, 0x40	; 64
     d18:	58 07       	cpc	r21, r24
     d1a:	58 f3       	brcs	.-42     	; 0xcf2 <__unpack_f+0x66>
     d1c:	14 96       	adiw	r26, 0x04	; 4
     d1e:	2d 93       	st	X+, r18
     d20:	3d 93       	st	X+, r19
     d22:	4d 93       	st	X+, r20
     d24:	5c 93       	st	X, r21
     d26:	17 97       	sbiw	r26, 0x07	; 7
     d28:	08 95       	ret
     d2a:	2f 3f       	cpi	r18, 0xFF	; 255
     d2c:	31 05       	cpc	r19, r1
     d2e:	79 f4       	brne	.+30     	; 0xd4e <__unpack_f+0xc2>
     d30:	41 15       	cp	r20, r1
     d32:	51 05       	cpc	r21, r1
     d34:	61 05       	cpc	r22, r1
     d36:	71 05       	cpc	r23, r1
     d38:	19 f4       	brne	.+6      	; 0xd40 <__unpack_f+0xb4>
     d3a:	84 e0       	ldi	r24, 0x04	; 4
     d3c:	8c 93       	st	X, r24
     d3e:	08 95       	ret
     d40:	64 ff       	sbrs	r22, 4
     d42:	03 c0       	rjmp	.+6      	; 0xd4a <__unpack_f+0xbe>
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	8c 93       	st	X, r24
     d48:	12 c0       	rjmp	.+36     	; 0xd6e <__unpack_f+0xe2>
     d4a:	1c 92       	st	X, r1
     d4c:	10 c0       	rjmp	.+32     	; 0xd6e <__unpack_f+0xe2>
     d4e:	2f 57       	subi	r18, 0x7F	; 127
     d50:	30 40       	sbci	r19, 0x00	; 0
     d52:	13 96       	adiw	r26, 0x03	; 3
     d54:	3c 93       	st	X, r19
     d56:	2e 93       	st	-X, r18
     d58:	12 97       	sbiw	r26, 0x02	; 2
     d5a:	83 e0       	ldi	r24, 0x03	; 3
     d5c:	8c 93       	st	X, r24
     d5e:	87 e0       	ldi	r24, 0x07	; 7
     d60:	44 0f       	add	r20, r20
     d62:	55 1f       	adc	r21, r21
     d64:	66 1f       	adc	r22, r22
     d66:	77 1f       	adc	r23, r23
     d68:	8a 95       	dec	r24
     d6a:	d1 f7       	brne	.-12     	; 0xd60 <__unpack_f+0xd4>
     d6c:	70 64       	ori	r23, 0x40	; 64
     d6e:	14 96       	adiw	r26, 0x04	; 4
     d70:	4d 93       	st	X+, r20
     d72:	5d 93       	st	X+, r21
     d74:	6d 93       	st	X+, r22
     d76:	7c 93       	st	X, r23
     d78:	17 97       	sbiw	r26, 0x07	; 7
     d7a:	08 95       	ret

00000d7c <__fpcmp_parts_f>:
     d7c:	1f 93       	push	r17
     d7e:	dc 01       	movw	r26, r24
     d80:	fb 01       	movw	r30, r22
     d82:	9c 91       	ld	r25, X
     d84:	92 30       	cpi	r25, 0x02	; 2
     d86:	08 f4       	brcc	.+2      	; 0xd8a <__fpcmp_parts_f+0xe>
     d88:	47 c0       	rjmp	.+142    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d8a:	80 81       	ld	r24, Z
     d8c:	82 30       	cpi	r24, 0x02	; 2
     d8e:	08 f4       	brcc	.+2      	; 0xd92 <__fpcmp_parts_f+0x16>
     d90:	43 c0       	rjmp	.+134    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d92:	94 30       	cpi	r25, 0x04	; 4
     d94:	51 f4       	brne	.+20     	; 0xdaa <__fpcmp_parts_f+0x2e>
     d96:	11 96       	adiw	r26, 0x01	; 1
     d98:	1c 91       	ld	r17, X
     d9a:	84 30       	cpi	r24, 0x04	; 4
     d9c:	99 f5       	brne	.+102    	; 0xe04 <__fpcmp_parts_f+0x88>
     d9e:	81 81       	ldd	r24, Z+1	; 0x01
     da0:	68 2f       	mov	r22, r24
     da2:	70 e0       	ldi	r23, 0x00	; 0
     da4:	61 1b       	sub	r22, r17
     da6:	71 09       	sbc	r23, r1
     da8:	3f c0       	rjmp	.+126    	; 0xe28 <__fpcmp_parts_f+0xac>
     daa:	84 30       	cpi	r24, 0x04	; 4
     dac:	21 f0       	breq	.+8      	; 0xdb6 <__fpcmp_parts_f+0x3a>
     dae:	92 30       	cpi	r25, 0x02	; 2
     db0:	31 f4       	brne	.+12     	; 0xdbe <__fpcmp_parts_f+0x42>
     db2:	82 30       	cpi	r24, 0x02	; 2
     db4:	b9 f1       	breq	.+110    	; 0xe24 <__fpcmp_parts_f+0xa8>
     db6:	81 81       	ldd	r24, Z+1	; 0x01
     db8:	88 23       	and	r24, r24
     dba:	89 f1       	breq	.+98     	; 0xe1e <__fpcmp_parts_f+0xa2>
     dbc:	2d c0       	rjmp	.+90     	; 0xe18 <__fpcmp_parts_f+0x9c>
     dbe:	11 96       	adiw	r26, 0x01	; 1
     dc0:	1c 91       	ld	r17, X
     dc2:	11 97       	sbiw	r26, 0x01	; 1
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	f1 f0       	breq	.+60     	; 0xe04 <__fpcmp_parts_f+0x88>
     dc8:	81 81       	ldd	r24, Z+1	; 0x01
     dca:	18 17       	cp	r17, r24
     dcc:	d9 f4       	brne	.+54     	; 0xe04 <__fpcmp_parts_f+0x88>
     dce:	12 96       	adiw	r26, 0x02	; 2
     dd0:	2d 91       	ld	r18, X+
     dd2:	3c 91       	ld	r19, X
     dd4:	13 97       	sbiw	r26, 0x03	; 3
     dd6:	82 81       	ldd	r24, Z+2	; 0x02
     dd8:	93 81       	ldd	r25, Z+3	; 0x03
     dda:	82 17       	cp	r24, r18
     ddc:	93 07       	cpc	r25, r19
     dde:	94 f0       	brlt	.+36     	; 0xe04 <__fpcmp_parts_f+0x88>
     de0:	28 17       	cp	r18, r24
     de2:	39 07       	cpc	r19, r25
     de4:	bc f0       	brlt	.+46     	; 0xe14 <__fpcmp_parts_f+0x98>
     de6:	14 96       	adiw	r26, 0x04	; 4
     de8:	8d 91       	ld	r24, X+
     dea:	9d 91       	ld	r25, X+
     dec:	0d 90       	ld	r0, X+
     dee:	bc 91       	ld	r27, X
     df0:	a0 2d       	mov	r26, r0
     df2:	24 81       	ldd	r18, Z+4	; 0x04
     df4:	35 81       	ldd	r19, Z+5	; 0x05
     df6:	46 81       	ldd	r20, Z+6	; 0x06
     df8:	57 81       	ldd	r21, Z+7	; 0x07
     dfa:	28 17       	cp	r18, r24
     dfc:	39 07       	cpc	r19, r25
     dfe:	4a 07       	cpc	r20, r26
     e00:	5b 07       	cpc	r21, r27
     e02:	18 f4       	brcc	.+6      	; 0xe0a <__fpcmp_parts_f+0x8e>
     e04:	11 23       	and	r17, r17
     e06:	41 f0       	breq	.+16     	; 0xe18 <__fpcmp_parts_f+0x9c>
     e08:	0a c0       	rjmp	.+20     	; 0xe1e <__fpcmp_parts_f+0xa2>
     e0a:	82 17       	cp	r24, r18
     e0c:	93 07       	cpc	r25, r19
     e0e:	a4 07       	cpc	r26, r20
     e10:	b5 07       	cpc	r27, r21
     e12:	40 f4       	brcc	.+16     	; 0xe24 <__fpcmp_parts_f+0xa8>
     e14:	11 23       	and	r17, r17
     e16:	19 f0       	breq	.+6      	; 0xe1e <__fpcmp_parts_f+0xa2>
     e18:	61 e0       	ldi	r22, 0x01	; 1
     e1a:	70 e0       	ldi	r23, 0x00	; 0
     e1c:	05 c0       	rjmp	.+10     	; 0xe28 <__fpcmp_parts_f+0xac>
     e1e:	6f ef       	ldi	r22, 0xFF	; 255
     e20:	7f ef       	ldi	r23, 0xFF	; 255
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <__fpcmp_parts_f+0xac>
     e24:	60 e0       	ldi	r22, 0x00	; 0
     e26:	70 e0       	ldi	r23, 0x00	; 0
     e28:	cb 01       	movw	r24, r22
     e2a:	1f 91       	pop	r17
     e2c:	08 95       	ret

00000e2e <pvPortMalloc>:
PRIVILEGED_DATA static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
     e2e:	df 93       	push	r29
     e30:	cf 93       	push	r28
     e32:	cd b7       	in	r28, 0x3d	; 61
     e34:	de b7       	in	r29, 0x3e	; 62
     e36:	2a 97       	sbiw	r28, 0x0a	; 10
     e38:	0f b6       	in	r0, 0x3f	; 63
     e3a:	f8 94       	cli
     e3c:	de bf       	out	0x3e, r29	; 62
     e3e:	0f be       	out	0x3f, r0	; 63
     e40:	cd bf       	out	0x3d, r28	; 61
     e42:	9a 87       	std	Y+10, r25	; 0x0a
     e44:	89 87       	std	Y+9, r24	; 0x09
    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;
    void * pvReturn = NULL;
     e46:	1a 82       	std	Y+2, r1	; 0x02
     e48:	19 82       	std	Y+1, r1	; 0x01

    vTaskSuspendAll();
     e4a:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
    {
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( pxEnd == NULL )
     e4e:	80 91 b4 01 	lds	r24, 0x01B4
     e52:	90 91 b5 01 	lds	r25, 0x01B5
     e56:	00 97       	sbiw	r24, 0x00	; 0
     e58:	11 f4       	brne	.+4      	; 0xe5e <pvPortMalloc+0x30>
        {
            prvHeapInit();
     e5a:	0e 94 b0 08 	call	0x1160	; 0x1160 <prvHeapInit>

        /* Check the requested block size is not so large that the top bit is
         * set.  The top bit of the block size member of the BlockLink_t structure
         * is used to determine who owns the block - the application or the
         * kernel, so it must be free. */
        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     e5e:	80 91 be 01 	lds	r24, 0x01BE
     e62:	90 91 bf 01 	lds	r25, 0x01BF
     e66:	29 85       	ldd	r18, Y+9	; 0x09
     e68:	3a 85       	ldd	r19, Y+10	; 0x0a
     e6a:	82 23       	and	r24, r18
     e6c:	93 23       	and	r25, r19
     e6e:	00 97       	sbiw	r24, 0x00	; 0
     e70:	09 f0       	breq	.+2      	; 0xe74 <pvPortMalloc+0x46>
     e72:	de c0       	rjmp	.+444    	; 0x1030 <pvPortMalloc+0x202>
        {
            /* The wanted size must be increased so it can contain a BlockLink_t
             * structure in addition to the requested amount of bytes. */
            if( ( xWantedSize > 0 ) && 
     e74:	89 85       	ldd	r24, Y+9	; 0x09
     e76:	9a 85       	ldd	r25, Y+10	; 0x0a
     e78:	00 97       	sbiw	r24, 0x00	; 0
     e7a:	c1 f0       	breq	.+48     	; 0xeac <pvPortMalloc+0x7e>
     e7c:	20 91 b2 01 	lds	r18, 0x01B2
     e80:	30 91 b3 01 	lds	r19, 0x01B3
     e84:	89 85       	ldd	r24, Y+9	; 0x09
     e86:	9a 85       	ldd	r25, Y+10	; 0x0a
     e88:	28 0f       	add	r18, r24
     e8a:	39 1f       	adc	r19, r25
     e8c:	89 85       	ldd	r24, Y+9	; 0x09
     e8e:	9a 85       	ldd	r25, Y+10	; 0x0a
     e90:	82 17       	cp	r24, r18
     e92:	93 07       	cpc	r25, r19
     e94:	58 f4       	brcc	.+22     	; 0xeac <pvPortMalloc+0x7e>
                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */
            {
                xWantedSize += xHeapStructSize;
     e96:	80 91 b2 01 	lds	r24, 0x01B2
     e9a:	90 91 b3 01 	lds	r25, 0x01B3
     e9e:	29 85       	ldd	r18, Y+9	; 0x09
     ea0:	3a 85       	ldd	r19, Y+10	; 0x0a
     ea2:	82 0f       	add	r24, r18
     ea4:	93 1f       	adc	r25, r19
     ea6:	9a 87       	std	Y+10, r25	; 0x0a
     ea8:	89 87       	std	Y+9, r24	; 0x09
     eaa:	02 c0       	rjmp	.+4      	; 0xeb0 <pvPortMalloc+0x82>
                    mtCOVERAGE_TEST_MARKER();
                }
            } 
            else 
            {
                xWantedSize = 0;
     eac:	1a 86       	std	Y+10, r1	; 0x0a
     eae:	19 86       	std	Y+9, r1	; 0x09
            }

            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     eb0:	89 85       	ldd	r24, Y+9	; 0x09
     eb2:	9a 85       	ldd	r25, Y+10	; 0x0a
     eb4:	00 97       	sbiw	r24, 0x00	; 0
     eb6:	09 f4       	brne	.+2      	; 0xeba <pvPortMalloc+0x8c>
     eb8:	bb c0       	rjmp	.+374    	; 0x1030 <pvPortMalloc+0x202>
     eba:	20 91 b6 01 	lds	r18, 0x01B6
     ebe:	30 91 b7 01 	lds	r19, 0x01B7
     ec2:	89 85       	ldd	r24, Y+9	; 0x09
     ec4:	9a 85       	ldd	r25, Y+10	; 0x0a
     ec6:	28 17       	cp	r18, r24
     ec8:	39 07       	cpc	r19, r25
     eca:	08 f4       	brcc	.+2      	; 0xece <pvPortMalloc+0xa0>
     ecc:	b1 c0       	rjmp	.+354    	; 0x1030 <pvPortMalloc+0x202>
            {
                /* Traverse the list from the start	(lowest address) block until
                 * one of adequate size is found. */
                pxPreviousBlock = &xStart;
     ece:	8c e9       	ldi	r24, 0x9C	; 156
     ed0:	97 e0       	ldi	r25, 0x07	; 7
     ed2:	9e 83       	std	Y+6, r25	; 0x06
     ed4:	8d 83       	std	Y+5, r24	; 0x05
                pxBlock = xStart.pxNextFreeBlock;
     ed6:	80 91 9c 07 	lds	r24, 0x079C
     eda:	90 91 9d 07 	lds	r25, 0x079D
     ede:	98 87       	std	Y+8, r25	; 0x08
     ee0:	8f 83       	std	Y+7, r24	; 0x07
     ee2:	0a c0       	rjmp	.+20     	; 0xef8 <pvPortMalloc+0xca>

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
                {
                    pxPreviousBlock = pxBlock;
     ee4:	8f 81       	ldd	r24, Y+7	; 0x07
     ee6:	98 85       	ldd	r25, Y+8	; 0x08
     ee8:	9e 83       	std	Y+6, r25	; 0x06
     eea:	8d 83       	std	Y+5, r24	; 0x05
                    pxBlock = pxBlock->pxNextFreeBlock;
     eec:	ef 81       	ldd	r30, Y+7	; 0x07
     eee:	f8 85       	ldd	r31, Y+8	; 0x08
     ef0:	80 81       	ld	r24, Z
     ef2:	91 81       	ldd	r25, Z+1	; 0x01
     ef4:	98 87       	std	Y+8, r25	; 0x08
     ef6:	8f 83       	std	Y+7, r24	; 0x07
                /* Traverse the list from the start	(lowest address) block until
                 * one of adequate size is found. */
                pxPreviousBlock = &xStart;
                pxBlock = xStart.pxNextFreeBlock;

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     ef8:	ef 81       	ldd	r30, Y+7	; 0x07
     efa:	f8 85       	ldd	r31, Y+8	; 0x08
     efc:	22 81       	ldd	r18, Z+2	; 0x02
     efe:	33 81       	ldd	r19, Z+3	; 0x03
     f00:	89 85       	ldd	r24, Y+9	; 0x09
     f02:	9a 85       	ldd	r25, Y+10	; 0x0a
     f04:	28 17       	cp	r18, r24
     f06:	39 07       	cpc	r19, r25
     f08:	30 f4       	brcc	.+12     	; 0xf16 <pvPortMalloc+0xe8>
     f0a:	ef 81       	ldd	r30, Y+7	; 0x07
     f0c:	f8 85       	ldd	r31, Y+8	; 0x08
     f0e:	80 81       	ld	r24, Z
     f10:	91 81       	ldd	r25, Z+1	; 0x01
     f12:	00 97       	sbiw	r24, 0x00	; 0
     f14:	39 f7       	brne	.-50     	; 0xee4 <pvPortMalloc+0xb6>
                    pxBlock = pxBlock->pxNextFreeBlock;
                }

                /* If the end marker was reached then a block of adequate size
                 * was not found. */
                if( pxBlock != pxEnd )
     f16:	20 91 b4 01 	lds	r18, 0x01B4
     f1a:	30 91 b5 01 	lds	r19, 0x01B5
     f1e:	8f 81       	ldd	r24, Y+7	; 0x07
     f20:	98 85       	ldd	r25, Y+8	; 0x08
     f22:	82 17       	cp	r24, r18
     f24:	93 07       	cpc	r25, r19
     f26:	09 f4       	brne	.+2      	; 0xf2a <pvPortMalloc+0xfc>
     f28:	83 c0       	rjmp	.+262    	; 0x1030 <pvPortMalloc+0x202>
                {
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     f2a:	ed 81       	ldd	r30, Y+5	; 0x05
     f2c:	fe 81       	ldd	r31, Y+6	; 0x06
     f2e:	20 81       	ld	r18, Z
     f30:	31 81       	ldd	r19, Z+1	; 0x01
     f32:	80 91 b2 01 	lds	r24, 0x01B2
     f36:	90 91 b3 01 	lds	r25, 0x01B3
     f3a:	82 0f       	add	r24, r18
     f3c:	93 1f       	adc	r25, r19
     f3e:	9a 83       	std	Y+2, r25	; 0x02
     f40:	89 83       	std	Y+1, r24	; 0x01

                    /* This block is being returned for use so must be taken out
                     * of the list of free blocks. */
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     f42:	ef 81       	ldd	r30, Y+7	; 0x07
     f44:	f8 85       	ldd	r31, Y+8	; 0x08
     f46:	80 81       	ld	r24, Z
     f48:	91 81       	ldd	r25, Z+1	; 0x01
     f4a:	ed 81       	ldd	r30, Y+5	; 0x05
     f4c:	fe 81       	ldd	r31, Y+6	; 0x06
     f4e:	91 83       	std	Z+1, r25	; 0x01
     f50:	80 83       	st	Z, r24

                    /* If the block is larger than required it can be split into
                     * two. */
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     f52:	ef 81       	ldd	r30, Y+7	; 0x07
     f54:	f8 85       	ldd	r31, Y+8	; 0x08
     f56:	22 81       	ldd	r18, Z+2	; 0x02
     f58:	33 81       	ldd	r19, Z+3	; 0x03
     f5a:	89 85       	ldd	r24, Y+9	; 0x09
     f5c:	9a 85       	ldd	r25, Y+10	; 0x0a
     f5e:	28 1b       	sub	r18, r24
     f60:	39 0b       	sbc	r19, r25
     f62:	80 91 b2 01 	lds	r24, 0x01B2
     f66:	90 91 b3 01 	lds	r25, 0x01B3
     f6a:	88 0f       	add	r24, r24
     f6c:	99 1f       	adc	r25, r25
     f6e:	82 17       	cp	r24, r18
     f70:	93 07       	cpc	r25, r19
     f72:	00 f5       	brcc	.+64     	; 0xfb4 <pvPortMalloc+0x186>
                    {
                        /* This block is to be split into two.  Create a new
                         * block following the number of bytes requested. The void
                         * cast is used to prevent byte alignment warnings from the
                         * compiler. */
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     f74:	2f 81       	ldd	r18, Y+7	; 0x07
     f76:	38 85       	ldd	r19, Y+8	; 0x08
     f78:	89 85       	ldd	r24, Y+9	; 0x09
     f7a:	9a 85       	ldd	r25, Y+10	; 0x0a
     f7c:	82 0f       	add	r24, r18
     f7e:	93 1f       	adc	r25, r19
     f80:	9c 83       	std	Y+4, r25	; 0x04
     f82:	8b 83       	std	Y+3, r24	; 0x03
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

                        /* Calculate the sizes of two blocks split from the
                         * single block. */
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     f84:	ef 81       	ldd	r30, Y+7	; 0x07
     f86:	f8 85       	ldd	r31, Y+8	; 0x08
     f88:	22 81       	ldd	r18, Z+2	; 0x02
     f8a:	33 81       	ldd	r19, Z+3	; 0x03
     f8c:	89 85       	ldd	r24, Y+9	; 0x09
     f8e:	9a 85       	ldd	r25, Y+10	; 0x0a
     f90:	a9 01       	movw	r20, r18
     f92:	48 1b       	sub	r20, r24
     f94:	59 0b       	sbc	r21, r25
     f96:	ca 01       	movw	r24, r20
     f98:	eb 81       	ldd	r30, Y+3	; 0x03
     f9a:	fc 81       	ldd	r31, Y+4	; 0x04
     f9c:	93 83       	std	Z+3, r25	; 0x03
     f9e:	82 83       	std	Z+2, r24	; 0x02
                        pxBlock->xBlockSize = xWantedSize;
     fa0:	ef 81       	ldd	r30, Y+7	; 0x07
     fa2:	f8 85       	ldd	r31, Y+8	; 0x08
     fa4:	89 85       	ldd	r24, Y+9	; 0x09
     fa6:	9a 85       	ldd	r25, Y+10	; 0x0a
     fa8:	93 83       	std	Z+3, r25	; 0x03
     faa:	82 83       	std	Z+2, r24	; 0x02

                        /* Insert the new block into the list of free blocks. */
                        prvInsertBlockIntoFreeList( pxNewBlockLink );
     fac:	8b 81       	ldd	r24, Y+3	; 0x03
     fae:	9c 81       	ldd	r25, Y+4	; 0x04
     fb0:	0e 94 29 09 	call	0x1252	; 0x1252 <prvInsertBlockIntoFreeList>
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    xFreeBytesRemaining -= pxBlock->xBlockSize;
     fb4:	20 91 b6 01 	lds	r18, 0x01B6
     fb8:	30 91 b7 01 	lds	r19, 0x01B7
     fbc:	ef 81       	ldd	r30, Y+7	; 0x07
     fbe:	f8 85       	ldd	r31, Y+8	; 0x08
     fc0:	82 81       	ldd	r24, Z+2	; 0x02
     fc2:	93 81       	ldd	r25, Z+3	; 0x03
     fc4:	a9 01       	movw	r20, r18
     fc6:	48 1b       	sub	r20, r24
     fc8:	59 0b       	sbc	r21, r25
     fca:	ca 01       	movw	r24, r20
     fcc:	90 93 b7 01 	sts	0x01B7, r25
     fd0:	80 93 b6 01 	sts	0x01B6, r24

                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     fd4:	20 91 b6 01 	lds	r18, 0x01B6
     fd8:	30 91 b7 01 	lds	r19, 0x01B7
     fdc:	80 91 b8 01 	lds	r24, 0x01B8
     fe0:	90 91 b9 01 	lds	r25, 0x01B9
     fe4:	28 17       	cp	r18, r24
     fe6:	39 07       	cpc	r19, r25
     fe8:	40 f4       	brcc	.+16     	; 0xffa <pvPortMalloc+0x1cc>
                    {
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     fea:	80 91 b6 01 	lds	r24, 0x01B6
     fee:	90 91 b7 01 	lds	r25, 0x01B7
     ff2:	90 93 b9 01 	sts	0x01B9, r25
     ff6:	80 93 b8 01 	sts	0x01B8, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The block is being returned - it is allocated and owned
                     * by the application and has no "next" block. */
                    pxBlock->xBlockSize |= xBlockAllocatedBit;
     ffa:	ef 81       	ldd	r30, Y+7	; 0x07
     ffc:	f8 85       	ldd	r31, Y+8	; 0x08
     ffe:	22 81       	ldd	r18, Z+2	; 0x02
    1000:	33 81       	ldd	r19, Z+3	; 0x03
    1002:	80 91 be 01 	lds	r24, 0x01BE
    1006:	90 91 bf 01 	lds	r25, 0x01BF
    100a:	82 2b       	or	r24, r18
    100c:	93 2b       	or	r25, r19
    100e:	ef 81       	ldd	r30, Y+7	; 0x07
    1010:	f8 85       	ldd	r31, Y+8	; 0x08
    1012:	93 83       	std	Z+3, r25	; 0x03
    1014:	82 83       	std	Z+2, r24	; 0x02
                    pxBlock->pxNextFreeBlock = NULL;
    1016:	ef 81       	ldd	r30, Y+7	; 0x07
    1018:	f8 85       	ldd	r31, Y+8	; 0x08
    101a:	11 82       	std	Z+1, r1	; 0x01
    101c:	10 82       	st	Z, r1
                    xNumberOfSuccessfulAllocations++;
    101e:	80 91 ba 01 	lds	r24, 0x01BA
    1022:	90 91 bb 01 	lds	r25, 0x01BB
    1026:	01 96       	adiw	r24, 0x01	; 1
    1028:	90 93 bb 01 	sts	0x01BB, r25
    102c:	80 93 ba 01 	sts	0x01BA, r24
            mtCOVERAGE_TEST_MARKER();
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    1030:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
            }
        }
    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */

    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
    return pvReturn;
    1034:	89 81       	ldd	r24, Y+1	; 0x01
    1036:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1038:	2a 96       	adiw	r28, 0x0a	; 10
    103a:	0f b6       	in	r0, 0x3f	; 63
    103c:	f8 94       	cli
    103e:	de bf       	out	0x3e, r29	; 62
    1040:	0f be       	out	0x3f, r0	; 63
    1042:	cd bf       	out	0x3d, r28	; 61
    1044:	cf 91       	pop	r28
    1046:	df 91       	pop	r29
    1048:	08 95       	ret

0000104a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    104a:	df 93       	push	r29
    104c:	cf 93       	push	r28
    104e:	00 d0       	rcall	.+0      	; 0x1050 <vPortFree+0x6>
    1050:	00 d0       	rcall	.+0      	; 0x1052 <vPortFree+0x8>
    1052:	00 d0       	rcall	.+0      	; 0x1054 <vPortFree+0xa>
    1054:	cd b7       	in	r28, 0x3d	; 61
    1056:	de b7       	in	r29, 0x3e	; 62
    1058:	9e 83       	std	Y+6, r25	; 0x06
    105a:	8d 83       	std	Y+5, r24	; 0x05
    uint8_t * puc = ( uint8_t * ) pv;
    105c:	8d 81       	ldd	r24, Y+5	; 0x05
    105e:	9e 81       	ldd	r25, Y+6	; 0x06
    1060:	9c 83       	std	Y+4, r25	; 0x04
    1062:	8b 83       	std	Y+3, r24	; 0x03
    BlockLink_t * pxLink;

    if( pv != NULL )
    1064:	8d 81       	ldd	r24, Y+5	; 0x05
    1066:	9e 81       	ldd	r25, Y+6	; 0x06
    1068:	00 97       	sbiw	r24, 0x00	; 0
    106a:	09 f4       	brne	.+2      	; 0x106e <vPortFree+0x24>
    106c:	53 c0       	rjmp	.+166    	; 0x1114 <vPortFree+0xca>
    {
        /* The memory being freed will have an BlockLink_t structure immediately
         * before it. */
        puc -= xHeapStructSize;
    106e:	80 91 b2 01 	lds	r24, 0x01B2
    1072:	90 91 b3 01 	lds	r25, 0x01B3
    1076:	22 27       	eor	r18, r18
    1078:	33 27       	eor	r19, r19
    107a:	28 1b       	sub	r18, r24
    107c:	39 0b       	sbc	r19, r25
    107e:	8b 81       	ldd	r24, Y+3	; 0x03
    1080:	9c 81       	ldd	r25, Y+4	; 0x04
    1082:	82 0f       	add	r24, r18
    1084:	93 1f       	adc	r25, r19
    1086:	9c 83       	std	Y+4, r25	; 0x04
    1088:	8b 83       	std	Y+3, r24	; 0x03

        /* This casting is to keep the compiler from issuing warnings. */
        pxLink = ( void * ) puc;
    108a:	8b 81       	ldd	r24, Y+3	; 0x03
    108c:	9c 81       	ldd	r25, Y+4	; 0x04
    108e:	9a 83       	std	Y+2, r25	; 0x02
    1090:	89 83       	std	Y+1, r24	; 0x01

        /* Check the block is actually allocated. */
        configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
        configASSERT( pxLink->pxNextFreeBlock == NULL );

        if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    1092:	e9 81       	ldd	r30, Y+1	; 0x01
    1094:	fa 81       	ldd	r31, Y+2	; 0x02
    1096:	22 81       	ldd	r18, Z+2	; 0x02
    1098:	33 81       	ldd	r19, Z+3	; 0x03
    109a:	80 91 be 01 	lds	r24, 0x01BE
    109e:	90 91 bf 01 	lds	r25, 0x01BF
    10a2:	82 23       	and	r24, r18
    10a4:	93 23       	and	r25, r19
    10a6:	00 97       	sbiw	r24, 0x00	; 0
    10a8:	a9 f1       	breq	.+106    	; 0x1114 <vPortFree+0xca>
        {
            if( pxLink->pxNextFreeBlock == NULL )
    10aa:	e9 81       	ldd	r30, Y+1	; 0x01
    10ac:	fa 81       	ldd	r31, Y+2	; 0x02
    10ae:	80 81       	ld	r24, Z
    10b0:	91 81       	ldd	r25, Z+1	; 0x01
    10b2:	00 97       	sbiw	r24, 0x00	; 0
    10b4:	79 f5       	brne	.+94     	; 0x1114 <vPortFree+0xca>
            {
                /* The block is being returned to the heap - it is no longer
                 * allocated. */
                pxLink->xBlockSize &= ~xBlockAllocatedBit;
    10b6:	e9 81       	ldd	r30, Y+1	; 0x01
    10b8:	fa 81       	ldd	r31, Y+2	; 0x02
    10ba:	22 81       	ldd	r18, Z+2	; 0x02
    10bc:	33 81       	ldd	r19, Z+3	; 0x03
    10be:	80 91 be 01 	lds	r24, 0x01BE
    10c2:	90 91 bf 01 	lds	r25, 0x01BF
    10c6:	80 95       	com	r24
    10c8:	90 95       	com	r25
    10ca:	82 23       	and	r24, r18
    10cc:	93 23       	and	r25, r19
    10ce:	e9 81       	ldd	r30, Y+1	; 0x01
    10d0:	fa 81       	ldd	r31, Y+2	; 0x02
    10d2:	93 83       	std	Z+3, r25	; 0x03
    10d4:	82 83       	std	Z+2, r24	; 0x02

                vTaskSuspendAll();
    10d6:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
                {
                    /* Add this block to the list of free blocks. */
                    xFreeBytesRemaining += pxLink->xBlockSize;
    10da:	e9 81       	ldd	r30, Y+1	; 0x01
    10dc:	fa 81       	ldd	r31, Y+2	; 0x02
    10de:	22 81       	ldd	r18, Z+2	; 0x02
    10e0:	33 81       	ldd	r19, Z+3	; 0x03
    10e2:	80 91 b6 01 	lds	r24, 0x01B6
    10e6:	90 91 b7 01 	lds	r25, 0x01B7
    10ea:	82 0f       	add	r24, r18
    10ec:	93 1f       	adc	r25, r19
    10ee:	90 93 b7 01 	sts	0x01B7, r25
    10f2:	80 93 b6 01 	sts	0x01B6, r24
                    traceFREE( pv, pxLink->xBlockSize );
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    10f6:	89 81       	ldd	r24, Y+1	; 0x01
    10f8:	9a 81       	ldd	r25, Y+2	; 0x02
    10fa:	0e 94 29 09 	call	0x1252	; 0x1252 <prvInsertBlockIntoFreeList>
                    xNumberOfSuccessfulFrees++;
    10fe:	80 91 bc 01 	lds	r24, 0x01BC
    1102:	90 91 bd 01 	lds	r25, 0x01BD
    1106:	01 96       	adiw	r24, 0x01	; 1
    1108:	90 93 bd 01 	sts	0x01BD, r25
    110c:	80 93 bc 01 	sts	0x01BC, r24
                }
                ( void ) xTaskResumeAll();
    1110:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
}
    1114:	26 96       	adiw	r28, 0x06	; 6
    1116:	0f b6       	in	r0, 0x3f	; 63
    1118:	f8 94       	cli
    111a:	de bf       	out	0x3e, r29	; 62
    111c:	0f be       	out	0x3f, r0	; 63
    111e:	cd bf       	out	0x3d, r28	; 61
    1120:	cf 91       	pop	r28
    1122:	df 91       	pop	r29
    1124:	08 95       	ret

00001126 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1126:	df 93       	push	r29
    1128:	cf 93       	push	r28
    112a:	cd b7       	in	r28, 0x3d	; 61
    112c:	de b7       	in	r29, 0x3e	; 62
    return xFreeBytesRemaining;
    112e:	80 91 b6 01 	lds	r24, 0x01B6
    1132:	90 91 b7 01 	lds	r25, 0x01B7
}
    1136:	cf 91       	pop	r28
    1138:	df 91       	pop	r29
    113a:	08 95       	ret

0000113c <xPortGetMinimumEverFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetMinimumEverFreeHeapSize( void )
{
    113c:	df 93       	push	r29
    113e:	cf 93       	push	r28
    1140:	cd b7       	in	r28, 0x3d	; 61
    1142:	de b7       	in	r29, 0x3e	; 62
    return xMinimumEverFreeBytesRemaining;
    1144:	80 91 b8 01 	lds	r24, 0x01B8
    1148:	90 91 b9 01 	lds	r25, 0x01B9
}
    114c:	cf 91       	pop	r28
    114e:	df 91       	pop	r29
    1150:	08 95       	ret

00001152 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1152:	df 93       	push	r29
    1154:	cf 93       	push	r28
    1156:	cd b7       	in	r28, 0x3d	; 61
    1158:	de b7       	in	r29, 0x3e	; 62
    /* This just exists to keep the linker quiet. */
}
    115a:	cf 91       	pop	r28
    115c:	df 91       	pop	r29
    115e:	08 95       	ret

00001160 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void ) /* PRIVILEGED_FUNCTION */
{
    1160:	df 93       	push	r29
    1162:	cf 93       	push	r28
    1164:	cd b7       	in	r28, 0x3d	; 61
    1166:	de b7       	in	r29, 0x3e	; 62
    1168:	28 97       	sbiw	r28, 0x08	; 8
    116a:	0f b6       	in	r0, 0x3f	; 63
    116c:	f8 94       	cli
    116e:	de bf       	out	0x3e, r29	; 62
    1170:	0f be       	out	0x3f, r0	; 63
    1172:	cd bf       	out	0x3d, r28	; 61
    BlockLink_t * pxFirstFreeBlock;
    uint8_t * pucAlignedHeap;
    size_t uxAddress;
    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
    1174:	8c ed       	ldi	r24, 0xDC	; 220
    1176:	95 e0       	ldi	r25, 0x05	; 5
    1178:	9a 83       	std	Y+2, r25	; 0x02
    117a:	89 83       	std	Y+1, r24	; 0x01

    /* Ensure the heap starts on a correctly aligned boundary. */
    uxAddress = ( size_t ) ucHeap;
    117c:	80 ec       	ldi	r24, 0xC0	; 192
    117e:	91 e0       	ldi	r25, 0x01	; 1
    1180:	9c 83       	std	Y+4, r25	; 0x04
    1182:	8b 83       	std	Y+3, r24	; 0x03
        uxAddress += ( portBYTE_ALIGNMENT - 1 );
        uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
        xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
    }

    pucAlignedHeap = ( uint8_t * ) uxAddress;
    1184:	8b 81       	ldd	r24, Y+3	; 0x03
    1186:	9c 81       	ldd	r25, Y+4	; 0x04
    1188:	9e 83       	std	Y+6, r25	; 0x06
    118a:	8d 83       	std	Y+5, r24	; 0x05

    /* xStart is used to hold a pointer to the first item in the list of free
     * blocks.  The void cast is used to prevent compiler warnings. */
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    118c:	8d 81       	ldd	r24, Y+5	; 0x05
    118e:	9e 81       	ldd	r25, Y+6	; 0x06
    1190:	90 93 9d 07 	sts	0x079D, r25
    1194:	80 93 9c 07 	sts	0x079C, r24
    xStart.xBlockSize = ( size_t ) 0;
    1198:	10 92 9f 07 	sts	0x079F, r1
    119c:	10 92 9e 07 	sts	0x079E, r1

    /* pxEnd is used to mark the end of the list of free blocks and is inserted
     * at the end of the heap space. */
    uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
    11a0:	2d 81       	ldd	r18, Y+5	; 0x05
    11a2:	3e 81       	ldd	r19, Y+6	; 0x06
    11a4:	89 81       	ldd	r24, Y+1	; 0x01
    11a6:	9a 81       	ldd	r25, Y+2	; 0x02
    11a8:	82 0f       	add	r24, r18
    11aa:	93 1f       	adc	r25, r19
    11ac:	9c 83       	std	Y+4, r25	; 0x04
    11ae:	8b 83       	std	Y+3, r24	; 0x03
    uxAddress -= xHeapStructSize;
    11b0:	20 91 b2 01 	lds	r18, 0x01B2
    11b4:	30 91 b3 01 	lds	r19, 0x01B3
    11b8:	8b 81       	ldd	r24, Y+3	; 0x03
    11ba:	9c 81       	ldd	r25, Y+4	; 0x04
    11bc:	82 1b       	sub	r24, r18
    11be:	93 0b       	sbc	r25, r19
    11c0:	9c 83       	std	Y+4, r25	; 0x04
    11c2:	8b 83       	std	Y+3, r24	; 0x03
    uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    pxEnd = ( void * ) uxAddress;
    11c4:	8b 81       	ldd	r24, Y+3	; 0x03
    11c6:	9c 81       	ldd	r25, Y+4	; 0x04
    11c8:	90 93 b5 01 	sts	0x01B5, r25
    11cc:	80 93 b4 01 	sts	0x01B4, r24
    pxEnd->xBlockSize = 0;
    11d0:	e0 91 b4 01 	lds	r30, 0x01B4
    11d4:	f0 91 b5 01 	lds	r31, 0x01B5
    11d8:	13 82       	std	Z+3, r1	; 0x03
    11da:	12 82       	std	Z+2, r1	; 0x02
    pxEnd->pxNextFreeBlock = NULL;
    11dc:	e0 91 b4 01 	lds	r30, 0x01B4
    11e0:	f0 91 b5 01 	lds	r31, 0x01B5
    11e4:	11 82       	std	Z+1, r1	; 0x01
    11e6:	10 82       	st	Z, r1

    /* To start with there is a single free block that is sized to take up the
     * entire heap space, minus the space taken by pxEnd. */
    pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    11e8:	8d 81       	ldd	r24, Y+5	; 0x05
    11ea:	9e 81       	ldd	r25, Y+6	; 0x06
    11ec:	98 87       	std	Y+8, r25	; 0x08
    11ee:	8f 83       	std	Y+7, r24	; 0x07
    pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    11f0:	2f 81       	ldd	r18, Y+7	; 0x07
    11f2:	38 85       	ldd	r19, Y+8	; 0x08
    11f4:	8b 81       	ldd	r24, Y+3	; 0x03
    11f6:	9c 81       	ldd	r25, Y+4	; 0x04
    11f8:	82 1b       	sub	r24, r18
    11fa:	93 0b       	sbc	r25, r19
    11fc:	ef 81       	ldd	r30, Y+7	; 0x07
    11fe:	f8 85       	ldd	r31, Y+8	; 0x08
    1200:	93 83       	std	Z+3, r25	; 0x03
    1202:	82 83       	std	Z+2, r24	; 0x02
    pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    1204:	80 91 b4 01 	lds	r24, 0x01B4
    1208:	90 91 b5 01 	lds	r25, 0x01B5
    120c:	ef 81       	ldd	r30, Y+7	; 0x07
    120e:	f8 85       	ldd	r31, Y+8	; 0x08
    1210:	91 83       	std	Z+1, r25	; 0x01
    1212:	80 83       	st	Z, r24

    /* Only one block exists - and it covers the entire usable heap space. */
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    1214:	ef 81       	ldd	r30, Y+7	; 0x07
    1216:	f8 85       	ldd	r31, Y+8	; 0x08
    1218:	82 81       	ldd	r24, Z+2	; 0x02
    121a:	93 81       	ldd	r25, Z+3	; 0x03
    121c:	90 93 b9 01 	sts	0x01B9, r25
    1220:	80 93 b8 01 	sts	0x01B8, r24
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    1224:	ef 81       	ldd	r30, Y+7	; 0x07
    1226:	f8 85       	ldd	r31, Y+8	; 0x08
    1228:	82 81       	ldd	r24, Z+2	; 0x02
    122a:	93 81       	ldd	r25, Z+3	; 0x03
    122c:	90 93 b7 01 	sts	0x01B7, r25
    1230:	80 93 b6 01 	sts	0x01B6, r24

    /* Work out the position of the top bit in a size_t variable. */
    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    1234:	80 e0       	ldi	r24, 0x00	; 0
    1236:	90 e8       	ldi	r25, 0x80	; 128
    1238:	90 93 bf 01 	sts	0x01BF, r25
    123c:	80 93 be 01 	sts	0x01BE, r24
}
    1240:	28 96       	adiw	r28, 0x08	; 8
    1242:	0f b6       	in	r0, 0x3f	; 63
    1244:	f8 94       	cli
    1246:	de bf       	out	0x3e, r29	; 62
    1248:	0f be       	out	0x3f, r0	; 63
    124a:	cd bf       	out	0x3d, r28	; 61
    124c:	cf 91       	pop	r28
    124e:	df 91       	pop	r29
    1250:	08 95       	ret

00001252 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) /* PRIVILEGED_FUNCTION */
{
    1252:	df 93       	push	r29
    1254:	cf 93       	push	r28
    1256:	00 d0       	rcall	.+0      	; 0x1258 <prvInsertBlockIntoFreeList+0x6>
    1258:	00 d0       	rcall	.+0      	; 0x125a <prvInsertBlockIntoFreeList+0x8>
    125a:	00 d0       	rcall	.+0      	; 0x125c <prvInsertBlockIntoFreeList+0xa>
    125c:	cd b7       	in	r28, 0x3d	; 61
    125e:	de b7       	in	r29, 0x3e	; 62
    1260:	9e 83       	std	Y+6, r25	; 0x06
    1262:	8d 83       	std	Y+5, r24	; 0x05
    BlockLink_t * pxIterator;
    uint8_t * puc;

    /* Iterate through the list until a block is found that has a higher address
     * than the block being inserted. */
    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    1264:	8c e9       	ldi	r24, 0x9C	; 156
    1266:	97 e0       	ldi	r25, 0x07	; 7
    1268:	9c 83       	std	Y+4, r25	; 0x04
    126a:	8b 83       	std	Y+3, r24	; 0x03
    126c:	06 c0       	rjmp	.+12     	; 0x127a <prvInsertBlockIntoFreeList+0x28>
    126e:	eb 81       	ldd	r30, Y+3	; 0x03
    1270:	fc 81       	ldd	r31, Y+4	; 0x04
    1272:	80 81       	ld	r24, Z
    1274:	91 81       	ldd	r25, Z+1	; 0x01
    1276:	9c 83       	std	Y+4, r25	; 0x04
    1278:	8b 83       	std	Y+3, r24	; 0x03
    127a:	eb 81       	ldd	r30, Y+3	; 0x03
    127c:	fc 81       	ldd	r31, Y+4	; 0x04
    127e:	20 81       	ld	r18, Z
    1280:	31 81       	ldd	r19, Z+1	; 0x01
    1282:	8d 81       	ldd	r24, Y+5	; 0x05
    1284:	9e 81       	ldd	r25, Y+6	; 0x06
    1286:	28 17       	cp	r18, r24
    1288:	39 07       	cpc	r19, r25
    128a:	88 f3       	brcs	.-30     	; 0x126e <prvInsertBlockIntoFreeList+0x1c>
        /* Nothing to do here, just iterate to the right position. */
    }

    /* Do the block being inserted, and the block it is being inserted after
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxIterator;
    128c:	8b 81       	ldd	r24, Y+3	; 0x03
    128e:	9c 81       	ldd	r25, Y+4	; 0x04
    1290:	9a 83       	std	Y+2, r25	; 0x02
    1292:	89 83       	std	Y+1, r24	; 0x01

    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    1294:	eb 81       	ldd	r30, Y+3	; 0x03
    1296:	fc 81       	ldd	r31, Y+4	; 0x04
    1298:	22 81       	ldd	r18, Z+2	; 0x02
    129a:	33 81       	ldd	r19, Z+3	; 0x03
    129c:	89 81       	ldd	r24, Y+1	; 0x01
    129e:	9a 81       	ldd	r25, Y+2	; 0x02
    12a0:	28 0f       	add	r18, r24
    12a2:	39 1f       	adc	r19, r25
    12a4:	8d 81       	ldd	r24, Y+5	; 0x05
    12a6:	9e 81       	ldd	r25, Y+6	; 0x06
    12a8:	28 17       	cp	r18, r24
    12aa:	39 07       	cpc	r19, r25
    12ac:	91 f4       	brne	.+36     	; 0x12d2 <prvInsertBlockIntoFreeList+0x80>
    {
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    12ae:	eb 81       	ldd	r30, Y+3	; 0x03
    12b0:	fc 81       	ldd	r31, Y+4	; 0x04
    12b2:	22 81       	ldd	r18, Z+2	; 0x02
    12b4:	33 81       	ldd	r19, Z+3	; 0x03
    12b6:	ed 81       	ldd	r30, Y+5	; 0x05
    12b8:	fe 81       	ldd	r31, Y+6	; 0x06
    12ba:	82 81       	ldd	r24, Z+2	; 0x02
    12bc:	93 81       	ldd	r25, Z+3	; 0x03
    12be:	82 0f       	add	r24, r18
    12c0:	93 1f       	adc	r25, r19
    12c2:	eb 81       	ldd	r30, Y+3	; 0x03
    12c4:	fc 81       	ldd	r31, Y+4	; 0x04
    12c6:	93 83       	std	Z+3, r25	; 0x03
    12c8:	82 83       	std	Z+2, r24	; 0x02
        pxBlockToInsert = pxIterator;
    12ca:	8b 81       	ldd	r24, Y+3	; 0x03
    12cc:	9c 81       	ldd	r25, Y+4	; 0x04
    12ce:	9e 83       	std	Y+6, r25	; 0x06
    12d0:	8d 83       	std	Y+5, r24	; 0x05
        mtCOVERAGE_TEST_MARKER();
    }

    /* Do the block being inserted, and the block it is being inserted before
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxBlockToInsert;
    12d2:	8d 81       	ldd	r24, Y+5	; 0x05
    12d4:	9e 81       	ldd	r25, Y+6	; 0x06
    12d6:	9a 83       	std	Y+2, r25	; 0x02
    12d8:	89 83       	std	Y+1, r24	; 0x01

    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    12da:	ed 81       	ldd	r30, Y+5	; 0x05
    12dc:	fe 81       	ldd	r31, Y+6	; 0x06
    12de:	22 81       	ldd	r18, Z+2	; 0x02
    12e0:	33 81       	ldd	r19, Z+3	; 0x03
    12e2:	89 81       	ldd	r24, Y+1	; 0x01
    12e4:	9a 81       	ldd	r25, Y+2	; 0x02
    12e6:	28 0f       	add	r18, r24
    12e8:	39 1f       	adc	r19, r25
    12ea:	eb 81       	ldd	r30, Y+3	; 0x03
    12ec:	fc 81       	ldd	r31, Y+4	; 0x04
    12ee:	80 81       	ld	r24, Z
    12f0:	91 81       	ldd	r25, Z+1	; 0x01
    12f2:	28 17       	cp	r18, r24
    12f4:	39 07       	cpc	r19, r25
    12f6:	89 f5       	brne	.+98     	; 0x135a <prvInsertBlockIntoFreeList+0x108>
    {
        if( pxIterator->pxNextFreeBlock != pxEnd )
    12f8:	eb 81       	ldd	r30, Y+3	; 0x03
    12fa:	fc 81       	ldd	r31, Y+4	; 0x04
    12fc:	20 81       	ld	r18, Z
    12fe:	31 81       	ldd	r19, Z+1	; 0x01
    1300:	80 91 b4 01 	lds	r24, 0x01B4
    1304:	90 91 b5 01 	lds	r25, 0x01B5
    1308:	28 17       	cp	r18, r24
    130a:	39 07       	cpc	r19, r25
    130c:	e9 f0       	breq	.+58     	; 0x1348 <prvInsertBlockIntoFreeList+0xf6>
        {
            /* Form one big block from the two blocks. */
            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    130e:	ed 81       	ldd	r30, Y+5	; 0x05
    1310:	fe 81       	ldd	r31, Y+6	; 0x06
    1312:	22 81       	ldd	r18, Z+2	; 0x02
    1314:	33 81       	ldd	r19, Z+3	; 0x03
    1316:	eb 81       	ldd	r30, Y+3	; 0x03
    1318:	fc 81       	ldd	r31, Y+4	; 0x04
    131a:	01 90       	ld	r0, Z+
    131c:	f0 81       	ld	r31, Z
    131e:	e0 2d       	mov	r30, r0
    1320:	82 81       	ldd	r24, Z+2	; 0x02
    1322:	93 81       	ldd	r25, Z+3	; 0x03
    1324:	82 0f       	add	r24, r18
    1326:	93 1f       	adc	r25, r19
    1328:	ed 81       	ldd	r30, Y+5	; 0x05
    132a:	fe 81       	ldd	r31, Y+6	; 0x06
    132c:	93 83       	std	Z+3, r25	; 0x03
    132e:	82 83       	std	Z+2, r24	; 0x02
            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    1330:	eb 81       	ldd	r30, Y+3	; 0x03
    1332:	fc 81       	ldd	r31, Y+4	; 0x04
    1334:	01 90       	ld	r0, Z+
    1336:	f0 81       	ld	r31, Z
    1338:	e0 2d       	mov	r30, r0
    133a:	80 81       	ld	r24, Z
    133c:	91 81       	ldd	r25, Z+1	; 0x01
    133e:	ed 81       	ldd	r30, Y+5	; 0x05
    1340:	fe 81       	ldd	r31, Y+6	; 0x06
    1342:	91 83       	std	Z+1, r25	; 0x01
    1344:	80 83       	st	Z, r24
    1346:	11 c0       	rjmp	.+34     	; 0x136a <prvInsertBlockIntoFreeList+0x118>
        }
        else
        {
            pxBlockToInsert->pxNextFreeBlock = pxEnd;
    1348:	80 91 b4 01 	lds	r24, 0x01B4
    134c:	90 91 b5 01 	lds	r25, 0x01B5
    1350:	ed 81       	ldd	r30, Y+5	; 0x05
    1352:	fe 81       	ldd	r31, Y+6	; 0x06
    1354:	91 83       	std	Z+1, r25	; 0x01
    1356:	80 83       	st	Z, r24
    1358:	08 c0       	rjmp	.+16     	; 0x136a <prvInsertBlockIntoFreeList+0x118>
        }
    }
    else
    {
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    135a:	eb 81       	ldd	r30, Y+3	; 0x03
    135c:	fc 81       	ldd	r31, Y+4	; 0x04
    135e:	80 81       	ld	r24, Z
    1360:	91 81       	ldd	r25, Z+1	; 0x01
    1362:	ed 81       	ldd	r30, Y+5	; 0x05
    1364:	fe 81       	ldd	r31, Y+6	; 0x06
    1366:	91 83       	std	Z+1, r25	; 0x01
    1368:	80 83       	st	Z, r24

    /* If the block being inserted plugged a gab, so was merged with the block
     * before and the block after, then it's pxNextFreeBlock pointer will have
     * already been set, and should not be set here as that would make it point
     * to itself. */
    if( pxIterator != pxBlockToInsert )
    136a:	2b 81       	ldd	r18, Y+3	; 0x03
    136c:	3c 81       	ldd	r19, Y+4	; 0x04
    136e:	8d 81       	ldd	r24, Y+5	; 0x05
    1370:	9e 81       	ldd	r25, Y+6	; 0x06
    1372:	28 17       	cp	r18, r24
    1374:	39 07       	cpc	r19, r25
    1376:	31 f0       	breq	.+12     	; 0x1384 <prvInsertBlockIntoFreeList+0x132>
    {
        pxIterator->pxNextFreeBlock = pxBlockToInsert;
    1378:	eb 81       	ldd	r30, Y+3	; 0x03
    137a:	fc 81       	ldd	r31, Y+4	; 0x04
    137c:	8d 81       	ldd	r24, Y+5	; 0x05
    137e:	9e 81       	ldd	r25, Y+6	; 0x06
    1380:	91 83       	std	Z+1, r25	; 0x01
    1382:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    1384:	26 96       	adiw	r28, 0x06	; 6
    1386:	0f b6       	in	r0, 0x3f	; 63
    1388:	f8 94       	cli
    138a:	de bf       	out	0x3e, r29	; 62
    138c:	0f be       	out	0x3f, r0	; 63
    138e:	cd bf       	out	0x3d, r28	; 61
    1390:	cf 91       	pop	r28
    1392:	df 91       	pop	r29
    1394:	08 95       	ret

00001396 <vPortGetHeapStats>:
/*-----------------------------------------------------------*/

void vPortGetHeapStats( HeapStats_t * pxHeapStats )
{
    1396:	df 93       	push	r29
    1398:	cf 93       	push	r28
    139a:	cd b7       	in	r28, 0x3d	; 61
    139c:	de b7       	in	r29, 0x3e	; 62
    139e:	2a 97       	sbiw	r28, 0x0a	; 10
    13a0:	0f b6       	in	r0, 0x3f	; 63
    13a2:	f8 94       	cli
    13a4:	de bf       	out	0x3e, r29	; 62
    13a6:	0f be       	out	0x3f, r0	; 63
    13a8:	cd bf       	out	0x3d, r28	; 61
    13aa:	9a 87       	std	Y+10, r25	; 0x0a
    13ac:	89 87       	std	Y+9, r24	; 0x09
    BlockLink_t * pxBlock;
    size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */
    13ae:	1e 82       	std	Y+6, r1	; 0x06
    13b0:	1d 82       	std	Y+5, r1	; 0x05
    13b2:	1c 82       	std	Y+4, r1	; 0x04
    13b4:	1b 82       	std	Y+3, r1	; 0x03
    13b6:	8f ef       	ldi	r24, 0xFF	; 255
    13b8:	9f ef       	ldi	r25, 0xFF	; 255
    13ba:	9a 83       	std	Y+2, r25	; 0x02
    13bc:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    13be:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
    {
        pxBlock = xStart.pxNextFreeBlock;
    13c2:	80 91 9c 07 	lds	r24, 0x079C
    13c6:	90 91 9d 07 	lds	r25, 0x079D
    13ca:	98 87       	std	Y+8, r25	; 0x08
    13cc:	8f 83       	std	Y+7, r24	; 0x07

        /* pxBlock will be NULL if the heap has not been initialised.  The heap
         * is initialised automatically when the first allocation is made. */
        if( pxBlock != NULL )
    13ce:	8f 81       	ldd	r24, Y+7	; 0x07
    13d0:	98 85       	ldd	r25, Y+8	; 0x08
    13d2:	00 97       	sbiw	r24, 0x00	; 0
    13d4:	91 f1       	breq	.+100    	; 0x143a <vPortGetHeapStats+0xa4>
        {
            do
            {
                /* Increment the number of blocks and record the largest block seen
                 * so far. */
                xBlocks++;
    13d6:	8d 81       	ldd	r24, Y+5	; 0x05
    13d8:	9e 81       	ldd	r25, Y+6	; 0x06
    13da:	01 96       	adiw	r24, 0x01	; 1
    13dc:	9e 83       	std	Y+6, r25	; 0x06
    13de:	8d 83       	std	Y+5, r24	; 0x05

                if( pxBlock->xBlockSize > xMaxSize )
    13e0:	ef 81       	ldd	r30, Y+7	; 0x07
    13e2:	f8 85       	ldd	r31, Y+8	; 0x08
    13e4:	22 81       	ldd	r18, Z+2	; 0x02
    13e6:	33 81       	ldd	r19, Z+3	; 0x03
    13e8:	8b 81       	ldd	r24, Y+3	; 0x03
    13ea:	9c 81       	ldd	r25, Y+4	; 0x04
    13ec:	82 17       	cp	r24, r18
    13ee:	93 07       	cpc	r25, r19
    13f0:	30 f4       	brcc	.+12     	; 0x13fe <vPortGetHeapStats+0x68>
                {
                    xMaxSize = pxBlock->xBlockSize;
    13f2:	ef 81       	ldd	r30, Y+7	; 0x07
    13f4:	f8 85       	ldd	r31, Y+8	; 0x08
    13f6:	82 81       	ldd	r24, Z+2	; 0x02
    13f8:	93 81       	ldd	r25, Z+3	; 0x03
    13fa:	9c 83       	std	Y+4, r25	; 0x04
    13fc:	8b 83       	std	Y+3, r24	; 0x03
                }

                if( pxBlock->xBlockSize < xMinSize )
    13fe:	ef 81       	ldd	r30, Y+7	; 0x07
    1400:	f8 85       	ldd	r31, Y+8	; 0x08
    1402:	22 81       	ldd	r18, Z+2	; 0x02
    1404:	33 81       	ldd	r19, Z+3	; 0x03
    1406:	89 81       	ldd	r24, Y+1	; 0x01
    1408:	9a 81       	ldd	r25, Y+2	; 0x02
    140a:	28 17       	cp	r18, r24
    140c:	39 07       	cpc	r19, r25
    140e:	30 f4       	brcc	.+12     	; 0x141c <vPortGetHeapStats+0x86>
                {
                    xMinSize = pxBlock->xBlockSize;
    1410:	ef 81       	ldd	r30, Y+7	; 0x07
    1412:	f8 85       	ldd	r31, Y+8	; 0x08
    1414:	82 81       	ldd	r24, Z+2	; 0x02
    1416:	93 81       	ldd	r25, Z+3	; 0x03
    1418:	9a 83       	std	Y+2, r25	; 0x02
    141a:	89 83       	std	Y+1, r24	; 0x01
                }

                /* Move to the next block in the chain until the last block is
                 * reached. */
                pxBlock = pxBlock->pxNextFreeBlock;
    141c:	ef 81       	ldd	r30, Y+7	; 0x07
    141e:	f8 85       	ldd	r31, Y+8	; 0x08
    1420:	80 81       	ld	r24, Z
    1422:	91 81       	ldd	r25, Z+1	; 0x01
    1424:	98 87       	std	Y+8, r25	; 0x08
    1426:	8f 83       	std	Y+7, r24	; 0x07
            } while( pxBlock != pxEnd );
    1428:	20 91 b4 01 	lds	r18, 0x01B4
    142c:	30 91 b5 01 	lds	r19, 0x01B5
    1430:	8f 81       	ldd	r24, Y+7	; 0x07
    1432:	98 85       	ldd	r25, Y+8	; 0x08
    1434:	82 17       	cp	r24, r18
    1436:	93 07       	cpc	r25, r19
    1438:	71 f6       	brne	.-100    	; 0x13d6 <vPortGetHeapStats+0x40>
        }
    }
    ( void ) xTaskResumeAll();
    143a:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>

    pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;
    143e:	e9 85       	ldd	r30, Y+9	; 0x09
    1440:	fa 85       	ldd	r31, Y+10	; 0x0a
    1442:	8b 81       	ldd	r24, Y+3	; 0x03
    1444:	9c 81       	ldd	r25, Y+4	; 0x04
    1446:	93 83       	std	Z+3, r25	; 0x03
    1448:	82 83       	std	Z+2, r24	; 0x02
    pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;
    144a:	e9 85       	ldd	r30, Y+9	; 0x09
    144c:	fa 85       	ldd	r31, Y+10	; 0x0a
    144e:	89 81       	ldd	r24, Y+1	; 0x01
    1450:	9a 81       	ldd	r25, Y+2	; 0x02
    1452:	95 83       	std	Z+5, r25	; 0x05
    1454:	84 83       	std	Z+4, r24	; 0x04
    pxHeapStats->xNumberOfFreeBlocks = xBlocks;
    1456:	e9 85       	ldd	r30, Y+9	; 0x09
    1458:	fa 85       	ldd	r31, Y+10	; 0x0a
    145a:	8d 81       	ldd	r24, Y+5	; 0x05
    145c:	9e 81       	ldd	r25, Y+6	; 0x06
    145e:	97 83       	std	Z+7, r25	; 0x07
    1460:	86 83       	std	Z+6, r24	; 0x06

    taskENTER_CRITICAL();
    1462:	0f b6       	in	r0, 0x3f	; 63
    1464:	f8 94       	cli
    1466:	0f 92       	push	r0
    {
        pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;
    1468:	80 91 b6 01 	lds	r24, 0x01B6
    146c:	90 91 b7 01 	lds	r25, 0x01B7
    1470:	e9 85       	ldd	r30, Y+9	; 0x09
    1472:	fa 85       	ldd	r31, Y+10	; 0x0a
    1474:	91 83       	std	Z+1, r25	; 0x01
    1476:	80 83       	st	Z, r24
        pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;
    1478:	80 91 ba 01 	lds	r24, 0x01BA
    147c:	90 91 bb 01 	lds	r25, 0x01BB
    1480:	e9 85       	ldd	r30, Y+9	; 0x09
    1482:	fa 85       	ldd	r31, Y+10	; 0x0a
    1484:	93 87       	std	Z+11, r25	; 0x0b
    1486:	82 87       	std	Z+10, r24	; 0x0a
        pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;
    1488:	80 91 bc 01 	lds	r24, 0x01BC
    148c:	90 91 bd 01 	lds	r25, 0x01BD
    1490:	e9 85       	ldd	r30, Y+9	; 0x09
    1492:	fa 85       	ldd	r31, Y+10	; 0x0a
    1494:	95 87       	std	Z+13, r25	; 0x0d
    1496:	84 87       	std	Z+12, r24	; 0x0c
        pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
    1498:	80 91 b8 01 	lds	r24, 0x01B8
    149c:	90 91 b9 01 	lds	r25, 0x01B9
    14a0:	e9 85       	ldd	r30, Y+9	; 0x09
    14a2:	fa 85       	ldd	r31, Y+10	; 0x0a
    14a4:	91 87       	std	Z+9, r25	; 0x09
    14a6:	80 87       	std	Z+8, r24	; 0x08
    }
    taskEXIT_CRITICAL();
    14a8:	0f 90       	pop	r0
    14aa:	0f be       	out	0x3f, r0	; 63
}
    14ac:	2a 96       	adiw	r28, 0x0a	; 10
    14ae:	0f b6       	in	r0, 0x3f	; 63
    14b0:	f8 94       	cli
    14b2:	de bf       	out	0x3e, r29	; 62
    14b4:	0f be       	out	0x3f, r0	; 63
    14b6:	cd bf       	out	0x3d, r28	; 61
    14b8:	cf 91       	pop	r28
    14ba:	df 91       	pop	r29
    14bc:	08 95       	ret

000014be <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    14be:	df 93       	push	r29
    14c0:	cf 93       	push	r28
    14c2:	cd b7       	in	r28, 0x3d	; 61
    14c4:	de b7       	in	r29, 0x3e	; 62
    14c6:	28 97       	sbiw	r28, 0x08	; 8
    14c8:	0f b6       	in	r0, 0x3f	; 63
    14ca:	f8 94       	cli
    14cc:	de bf       	out	0x3e, r29	; 62
    14ce:	0f be       	out	0x3f, r0	; 63
    14d0:	cd bf       	out	0x3d, r28	; 61
    14d2:	9c 83       	std	Y+4, r25	; 0x04
    14d4:	8b 83       	std	Y+3, r24	; 0x03
    14d6:	7e 83       	std	Y+6, r23	; 0x06
    14d8:	6d 83       	std	Y+5, r22	; 0x05
    14da:	58 87       	std	Y+8, r21	; 0x08
    14dc:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    14de:	eb 81       	ldd	r30, Y+3	; 0x03
    14e0:	fc 81       	ldd	r31, Y+4	; 0x04
    14e2:	81 e1       	ldi	r24, 0x11	; 17
    14e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    14e6:	8b 81       	ldd	r24, Y+3	; 0x03
    14e8:	9c 81       	ldd	r25, Y+4	; 0x04
    14ea:	01 97       	sbiw	r24, 0x01	; 1
    14ec:	9c 83       	std	Y+4, r25	; 0x04
    14ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    14f0:	eb 81       	ldd	r30, Y+3	; 0x03
    14f2:	fc 81       	ldd	r31, Y+4	; 0x04
    14f4:	82 e2       	ldi	r24, 0x22	; 34
    14f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    14f8:	8b 81       	ldd	r24, Y+3	; 0x03
    14fa:	9c 81       	ldd	r25, Y+4	; 0x04
    14fc:	01 97       	sbiw	r24, 0x01	; 1
    14fe:	9c 83       	std	Y+4, r25	; 0x04
    1500:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1502:	eb 81       	ldd	r30, Y+3	; 0x03
    1504:	fc 81       	ldd	r31, Y+4	; 0x04
    1506:	83 e3       	ldi	r24, 0x33	; 51
    1508:	80 83       	st	Z, r24
	pxTopOfStack--;
    150a:	8b 81       	ldd	r24, Y+3	; 0x03
    150c:	9c 81       	ldd	r25, Y+4	; 0x04
    150e:	01 97       	sbiw	r24, 0x01	; 1
    1510:	9c 83       	std	Y+4, r25	; 0x04
    1512:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1514:	8d 81       	ldd	r24, Y+5	; 0x05
    1516:	9e 81       	ldd	r25, Y+6	; 0x06
    1518:	9a 83       	std	Y+2, r25	; 0x02
    151a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    151c:	89 81       	ldd	r24, Y+1	; 0x01
    151e:	eb 81       	ldd	r30, Y+3	; 0x03
    1520:	fc 81       	ldd	r31, Y+4	; 0x04
    1522:	80 83       	st	Z, r24
	pxTopOfStack--;
    1524:	8b 81       	ldd	r24, Y+3	; 0x03
    1526:	9c 81       	ldd	r25, Y+4	; 0x04
    1528:	01 97       	sbiw	r24, 0x01	; 1
    152a:	9c 83       	std	Y+4, r25	; 0x04
    152c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    152e:	89 81       	ldd	r24, Y+1	; 0x01
    1530:	9a 81       	ldd	r25, Y+2	; 0x02
    1532:	89 2f       	mov	r24, r25
    1534:	99 27       	eor	r25, r25
    1536:	9a 83       	std	Y+2, r25	; 0x02
    1538:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    153a:	89 81       	ldd	r24, Y+1	; 0x01
    153c:	eb 81       	ldd	r30, Y+3	; 0x03
    153e:	fc 81       	ldd	r31, Y+4	; 0x04
    1540:	80 83       	st	Z, r24
	pxTopOfStack--;
    1542:	8b 81       	ldd	r24, Y+3	; 0x03
    1544:	9c 81       	ldd	r25, Y+4	; 0x04
    1546:	01 97       	sbiw	r24, 0x01	; 1
    1548:	9c 83       	std	Y+4, r25	; 0x04
    154a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    154c:	eb 81       	ldd	r30, Y+3	; 0x03
    154e:	fc 81       	ldd	r31, Y+4	; 0x04
    1550:	10 82       	st	Z, r1
	pxTopOfStack--;
    1552:	8b 81       	ldd	r24, Y+3	; 0x03
    1554:	9c 81       	ldd	r25, Y+4	; 0x04
    1556:	01 97       	sbiw	r24, 0x01	; 1
    1558:	9c 83       	std	Y+4, r25	; 0x04
    155a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    155c:	eb 81       	ldd	r30, Y+3	; 0x03
    155e:	fc 81       	ldd	r31, Y+4	; 0x04
    1560:	80 e8       	ldi	r24, 0x80	; 128
    1562:	80 83       	st	Z, r24
	pxTopOfStack--;
    1564:	8b 81       	ldd	r24, Y+3	; 0x03
    1566:	9c 81       	ldd	r25, Y+4	; 0x04
    1568:	01 97       	sbiw	r24, 0x01	; 1
    156a:	9c 83       	std	Y+4, r25	; 0x04
    156c:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    156e:	eb 81       	ldd	r30, Y+3	; 0x03
    1570:	fc 81       	ldd	r31, Y+4	; 0x04
    1572:	10 82       	st	Z, r1
	pxTopOfStack--;
    1574:	8b 81       	ldd	r24, Y+3	; 0x03
    1576:	9c 81       	ldd	r25, Y+4	; 0x04
    1578:	01 97       	sbiw	r24, 0x01	; 1
    157a:	9c 83       	std	Y+4, r25	; 0x04
    157c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    157e:	eb 81       	ldd	r30, Y+3	; 0x03
    1580:	fc 81       	ldd	r31, Y+4	; 0x04
    1582:	82 e0       	ldi	r24, 0x02	; 2
    1584:	80 83       	st	Z, r24
	pxTopOfStack--;
    1586:	8b 81       	ldd	r24, Y+3	; 0x03
    1588:	9c 81       	ldd	r25, Y+4	; 0x04
    158a:	01 97       	sbiw	r24, 0x01	; 1
    158c:	9c 83       	std	Y+4, r25	; 0x04
    158e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1590:	eb 81       	ldd	r30, Y+3	; 0x03
    1592:	fc 81       	ldd	r31, Y+4	; 0x04
    1594:	83 e0       	ldi	r24, 0x03	; 3
    1596:	80 83       	st	Z, r24
	pxTopOfStack--;
    1598:	8b 81       	ldd	r24, Y+3	; 0x03
    159a:	9c 81       	ldd	r25, Y+4	; 0x04
    159c:	01 97       	sbiw	r24, 0x01	; 1
    159e:	9c 83       	std	Y+4, r25	; 0x04
    15a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    15a2:	eb 81       	ldd	r30, Y+3	; 0x03
    15a4:	fc 81       	ldd	r31, Y+4	; 0x04
    15a6:	84 e0       	ldi	r24, 0x04	; 4
    15a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    15aa:	8b 81       	ldd	r24, Y+3	; 0x03
    15ac:	9c 81       	ldd	r25, Y+4	; 0x04
    15ae:	01 97       	sbiw	r24, 0x01	; 1
    15b0:	9c 83       	std	Y+4, r25	; 0x04
    15b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    15b4:	eb 81       	ldd	r30, Y+3	; 0x03
    15b6:	fc 81       	ldd	r31, Y+4	; 0x04
    15b8:	85 e0       	ldi	r24, 0x05	; 5
    15ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    15bc:	8b 81       	ldd	r24, Y+3	; 0x03
    15be:	9c 81       	ldd	r25, Y+4	; 0x04
    15c0:	01 97       	sbiw	r24, 0x01	; 1
    15c2:	9c 83       	std	Y+4, r25	; 0x04
    15c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    15c6:	eb 81       	ldd	r30, Y+3	; 0x03
    15c8:	fc 81       	ldd	r31, Y+4	; 0x04
    15ca:	86 e0       	ldi	r24, 0x06	; 6
    15cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    15ce:	8b 81       	ldd	r24, Y+3	; 0x03
    15d0:	9c 81       	ldd	r25, Y+4	; 0x04
    15d2:	01 97       	sbiw	r24, 0x01	; 1
    15d4:	9c 83       	std	Y+4, r25	; 0x04
    15d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    15d8:	eb 81       	ldd	r30, Y+3	; 0x03
    15da:	fc 81       	ldd	r31, Y+4	; 0x04
    15dc:	87 e0       	ldi	r24, 0x07	; 7
    15de:	80 83       	st	Z, r24
	pxTopOfStack--;
    15e0:	8b 81       	ldd	r24, Y+3	; 0x03
    15e2:	9c 81       	ldd	r25, Y+4	; 0x04
    15e4:	01 97       	sbiw	r24, 0x01	; 1
    15e6:	9c 83       	std	Y+4, r25	; 0x04
    15e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    15ea:	eb 81       	ldd	r30, Y+3	; 0x03
    15ec:	fc 81       	ldd	r31, Y+4	; 0x04
    15ee:	88 e0       	ldi	r24, 0x08	; 8
    15f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    15f2:	8b 81       	ldd	r24, Y+3	; 0x03
    15f4:	9c 81       	ldd	r25, Y+4	; 0x04
    15f6:	01 97       	sbiw	r24, 0x01	; 1
    15f8:	9c 83       	std	Y+4, r25	; 0x04
    15fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    15fc:	eb 81       	ldd	r30, Y+3	; 0x03
    15fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1600:	89 e0       	ldi	r24, 0x09	; 9
    1602:	80 83       	st	Z, r24
	pxTopOfStack--;
    1604:	8b 81       	ldd	r24, Y+3	; 0x03
    1606:	9c 81       	ldd	r25, Y+4	; 0x04
    1608:	01 97       	sbiw	r24, 0x01	; 1
    160a:	9c 83       	std	Y+4, r25	; 0x04
    160c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    160e:	eb 81       	ldd	r30, Y+3	; 0x03
    1610:	fc 81       	ldd	r31, Y+4	; 0x04
    1612:	80 e1       	ldi	r24, 0x10	; 16
    1614:	80 83       	st	Z, r24
	pxTopOfStack--;
    1616:	8b 81       	ldd	r24, Y+3	; 0x03
    1618:	9c 81       	ldd	r25, Y+4	; 0x04
    161a:	01 97       	sbiw	r24, 0x01	; 1
    161c:	9c 83       	std	Y+4, r25	; 0x04
    161e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1620:	eb 81       	ldd	r30, Y+3	; 0x03
    1622:	fc 81       	ldd	r31, Y+4	; 0x04
    1624:	81 e1       	ldi	r24, 0x11	; 17
    1626:	80 83       	st	Z, r24
	pxTopOfStack--;
    1628:	8b 81       	ldd	r24, Y+3	; 0x03
    162a:	9c 81       	ldd	r25, Y+4	; 0x04
    162c:	01 97       	sbiw	r24, 0x01	; 1
    162e:	9c 83       	std	Y+4, r25	; 0x04
    1630:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1632:	eb 81       	ldd	r30, Y+3	; 0x03
    1634:	fc 81       	ldd	r31, Y+4	; 0x04
    1636:	82 e1       	ldi	r24, 0x12	; 18
    1638:	80 83       	st	Z, r24
	pxTopOfStack--;
    163a:	8b 81       	ldd	r24, Y+3	; 0x03
    163c:	9c 81       	ldd	r25, Y+4	; 0x04
    163e:	01 97       	sbiw	r24, 0x01	; 1
    1640:	9c 83       	std	Y+4, r25	; 0x04
    1642:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1644:	eb 81       	ldd	r30, Y+3	; 0x03
    1646:	fc 81       	ldd	r31, Y+4	; 0x04
    1648:	83 e1       	ldi	r24, 0x13	; 19
    164a:	80 83       	st	Z, r24
	pxTopOfStack--;
    164c:	8b 81       	ldd	r24, Y+3	; 0x03
    164e:	9c 81       	ldd	r25, Y+4	; 0x04
    1650:	01 97       	sbiw	r24, 0x01	; 1
    1652:	9c 83       	std	Y+4, r25	; 0x04
    1654:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1656:	eb 81       	ldd	r30, Y+3	; 0x03
    1658:	fc 81       	ldd	r31, Y+4	; 0x04
    165a:	84 e1       	ldi	r24, 0x14	; 20
    165c:	80 83       	st	Z, r24
	pxTopOfStack--;
    165e:	8b 81       	ldd	r24, Y+3	; 0x03
    1660:	9c 81       	ldd	r25, Y+4	; 0x04
    1662:	01 97       	sbiw	r24, 0x01	; 1
    1664:	9c 83       	std	Y+4, r25	; 0x04
    1666:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1668:	eb 81       	ldd	r30, Y+3	; 0x03
    166a:	fc 81       	ldd	r31, Y+4	; 0x04
    166c:	85 e1       	ldi	r24, 0x15	; 21
    166e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1670:	8b 81       	ldd	r24, Y+3	; 0x03
    1672:	9c 81       	ldd	r25, Y+4	; 0x04
    1674:	01 97       	sbiw	r24, 0x01	; 1
    1676:	9c 83       	std	Y+4, r25	; 0x04
    1678:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    167a:	eb 81       	ldd	r30, Y+3	; 0x03
    167c:	fc 81       	ldd	r31, Y+4	; 0x04
    167e:	86 e1       	ldi	r24, 0x16	; 22
    1680:	80 83       	st	Z, r24
	pxTopOfStack--;
    1682:	8b 81       	ldd	r24, Y+3	; 0x03
    1684:	9c 81       	ldd	r25, Y+4	; 0x04
    1686:	01 97       	sbiw	r24, 0x01	; 1
    1688:	9c 83       	std	Y+4, r25	; 0x04
    168a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    168c:	eb 81       	ldd	r30, Y+3	; 0x03
    168e:	fc 81       	ldd	r31, Y+4	; 0x04
    1690:	87 e1       	ldi	r24, 0x17	; 23
    1692:	80 83       	st	Z, r24
	pxTopOfStack--;
    1694:	8b 81       	ldd	r24, Y+3	; 0x03
    1696:	9c 81       	ldd	r25, Y+4	; 0x04
    1698:	01 97       	sbiw	r24, 0x01	; 1
    169a:	9c 83       	std	Y+4, r25	; 0x04
    169c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    169e:	eb 81       	ldd	r30, Y+3	; 0x03
    16a0:	fc 81       	ldd	r31, Y+4	; 0x04
    16a2:	88 e1       	ldi	r24, 0x18	; 24
    16a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    16a6:	8b 81       	ldd	r24, Y+3	; 0x03
    16a8:	9c 81       	ldd	r25, Y+4	; 0x04
    16aa:	01 97       	sbiw	r24, 0x01	; 1
    16ac:	9c 83       	std	Y+4, r25	; 0x04
    16ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    16b0:	eb 81       	ldd	r30, Y+3	; 0x03
    16b2:	fc 81       	ldd	r31, Y+4	; 0x04
    16b4:	89 e1       	ldi	r24, 0x19	; 25
    16b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    16b8:	8b 81       	ldd	r24, Y+3	; 0x03
    16ba:	9c 81       	ldd	r25, Y+4	; 0x04
    16bc:	01 97       	sbiw	r24, 0x01	; 1
    16be:	9c 83       	std	Y+4, r25	; 0x04
    16c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    16c2:	eb 81       	ldd	r30, Y+3	; 0x03
    16c4:	fc 81       	ldd	r31, Y+4	; 0x04
    16c6:	80 e2       	ldi	r24, 0x20	; 32
    16c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    16ca:	8b 81       	ldd	r24, Y+3	; 0x03
    16cc:	9c 81       	ldd	r25, Y+4	; 0x04
    16ce:	01 97       	sbiw	r24, 0x01	; 1
    16d0:	9c 83       	std	Y+4, r25	; 0x04
    16d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    16d4:	eb 81       	ldd	r30, Y+3	; 0x03
    16d6:	fc 81       	ldd	r31, Y+4	; 0x04
    16d8:	81 e2       	ldi	r24, 0x21	; 33
    16da:	80 83       	st	Z, r24
	pxTopOfStack--;
    16dc:	8b 81       	ldd	r24, Y+3	; 0x03
    16de:	9c 81       	ldd	r25, Y+4	; 0x04
    16e0:	01 97       	sbiw	r24, 0x01	; 1
    16e2:	9c 83       	std	Y+4, r25	; 0x04
    16e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    16e6:	eb 81       	ldd	r30, Y+3	; 0x03
    16e8:	fc 81       	ldd	r31, Y+4	; 0x04
    16ea:	82 e2       	ldi	r24, 0x22	; 34
    16ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    16ee:	8b 81       	ldd	r24, Y+3	; 0x03
    16f0:	9c 81       	ldd	r25, Y+4	; 0x04
    16f2:	01 97       	sbiw	r24, 0x01	; 1
    16f4:	9c 83       	std	Y+4, r25	; 0x04
    16f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    16f8:	eb 81       	ldd	r30, Y+3	; 0x03
    16fa:	fc 81       	ldd	r31, Y+4	; 0x04
    16fc:	83 e2       	ldi	r24, 0x23	; 35
    16fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1700:	8b 81       	ldd	r24, Y+3	; 0x03
    1702:	9c 81       	ldd	r25, Y+4	; 0x04
    1704:	01 97       	sbiw	r24, 0x01	; 1
    1706:	9c 83       	std	Y+4, r25	; 0x04
    1708:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    170a:	8f 81       	ldd	r24, Y+7	; 0x07
    170c:	98 85       	ldd	r25, Y+8	; 0x08
    170e:	9a 83       	std	Y+2, r25	; 0x02
    1710:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1712:	89 81       	ldd	r24, Y+1	; 0x01
    1714:	eb 81       	ldd	r30, Y+3	; 0x03
    1716:	fc 81       	ldd	r31, Y+4	; 0x04
    1718:	80 83       	st	Z, r24
	pxTopOfStack--;
    171a:	8b 81       	ldd	r24, Y+3	; 0x03
    171c:	9c 81       	ldd	r25, Y+4	; 0x04
    171e:	01 97       	sbiw	r24, 0x01	; 1
    1720:	9c 83       	std	Y+4, r25	; 0x04
    1722:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1724:	89 81       	ldd	r24, Y+1	; 0x01
    1726:	9a 81       	ldd	r25, Y+2	; 0x02
    1728:	89 2f       	mov	r24, r25
    172a:	99 27       	eor	r25, r25
    172c:	9a 83       	std	Y+2, r25	; 0x02
    172e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1730:	89 81       	ldd	r24, Y+1	; 0x01
    1732:	eb 81       	ldd	r30, Y+3	; 0x03
    1734:	fc 81       	ldd	r31, Y+4	; 0x04
    1736:	80 83       	st	Z, r24
	pxTopOfStack--;
    1738:	8b 81       	ldd	r24, Y+3	; 0x03
    173a:	9c 81       	ldd	r25, Y+4	; 0x04
    173c:	01 97       	sbiw	r24, 0x01	; 1
    173e:	9c 83       	std	Y+4, r25	; 0x04
    1740:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1742:	eb 81       	ldd	r30, Y+3	; 0x03
    1744:	fc 81       	ldd	r31, Y+4	; 0x04
    1746:	86 e2       	ldi	r24, 0x26	; 38
    1748:	80 83       	st	Z, r24
	pxTopOfStack--;
    174a:	8b 81       	ldd	r24, Y+3	; 0x03
    174c:	9c 81       	ldd	r25, Y+4	; 0x04
    174e:	01 97       	sbiw	r24, 0x01	; 1
    1750:	9c 83       	std	Y+4, r25	; 0x04
    1752:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1754:	eb 81       	ldd	r30, Y+3	; 0x03
    1756:	fc 81       	ldd	r31, Y+4	; 0x04
    1758:	87 e2       	ldi	r24, 0x27	; 39
    175a:	80 83       	st	Z, r24
	pxTopOfStack--;
    175c:	8b 81       	ldd	r24, Y+3	; 0x03
    175e:	9c 81       	ldd	r25, Y+4	; 0x04
    1760:	01 97       	sbiw	r24, 0x01	; 1
    1762:	9c 83       	std	Y+4, r25	; 0x04
    1764:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1766:	eb 81       	ldd	r30, Y+3	; 0x03
    1768:	fc 81       	ldd	r31, Y+4	; 0x04
    176a:	88 e2       	ldi	r24, 0x28	; 40
    176c:	80 83       	st	Z, r24
	pxTopOfStack--;
    176e:	8b 81       	ldd	r24, Y+3	; 0x03
    1770:	9c 81       	ldd	r25, Y+4	; 0x04
    1772:	01 97       	sbiw	r24, 0x01	; 1
    1774:	9c 83       	std	Y+4, r25	; 0x04
    1776:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1778:	eb 81       	ldd	r30, Y+3	; 0x03
    177a:	fc 81       	ldd	r31, Y+4	; 0x04
    177c:	89 e2       	ldi	r24, 0x29	; 41
    177e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1780:	8b 81       	ldd	r24, Y+3	; 0x03
    1782:	9c 81       	ldd	r25, Y+4	; 0x04
    1784:	01 97       	sbiw	r24, 0x01	; 1
    1786:	9c 83       	std	Y+4, r25	; 0x04
    1788:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    178a:	eb 81       	ldd	r30, Y+3	; 0x03
    178c:	fc 81       	ldd	r31, Y+4	; 0x04
    178e:	80 e3       	ldi	r24, 0x30	; 48
    1790:	80 83       	st	Z, r24
	pxTopOfStack--;
    1792:	8b 81       	ldd	r24, Y+3	; 0x03
    1794:	9c 81       	ldd	r25, Y+4	; 0x04
    1796:	01 97       	sbiw	r24, 0x01	; 1
    1798:	9c 83       	std	Y+4, r25	; 0x04
    179a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    179c:	eb 81       	ldd	r30, Y+3	; 0x03
    179e:	fc 81       	ldd	r31, Y+4	; 0x04
    17a0:	81 e3       	ldi	r24, 0x31	; 49
    17a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    17a4:	8b 81       	ldd	r24, Y+3	; 0x03
    17a6:	9c 81       	ldd	r25, Y+4	; 0x04
    17a8:	01 97       	sbiw	r24, 0x01	; 1
    17aa:	9c 83       	std	Y+4, r25	; 0x04
    17ac:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    17ae:	8b 81       	ldd	r24, Y+3	; 0x03
    17b0:	9c 81       	ldd	r25, Y+4	; 0x04
}
    17b2:	28 96       	adiw	r28, 0x08	; 8
    17b4:	0f b6       	in	r0, 0x3f	; 63
    17b6:	f8 94       	cli
    17b8:	de bf       	out	0x3e, r29	; 62
    17ba:	0f be       	out	0x3f, r0	; 63
    17bc:	cd bf       	out	0x3d, r28	; 61
    17be:	cf 91       	pop	r28
    17c0:	df 91       	pop	r29
    17c2:	08 95       	ret

000017c4 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    17c4:	df 93       	push	r29
    17c6:	cf 93       	push	r28
    17c8:	cd b7       	in	r28, 0x3d	; 61
    17ca:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    17cc:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    17d0:	a0 91 a0 07 	lds	r26, 0x07A0
    17d4:	b0 91 a1 07 	lds	r27, 0x07A1
    17d8:	cd 91       	ld	r28, X+
    17da:	cd bf       	out	0x3d, r28	; 61
    17dc:	dd 91       	ld	r29, X+
    17de:	de bf       	out	0x3e, r29	; 62
    17e0:	ff 91       	pop	r31
    17e2:	ef 91       	pop	r30
    17e4:	df 91       	pop	r29
    17e6:	cf 91       	pop	r28
    17e8:	bf 91       	pop	r27
    17ea:	af 91       	pop	r26
    17ec:	9f 91       	pop	r25
    17ee:	8f 91       	pop	r24
    17f0:	7f 91       	pop	r23
    17f2:	6f 91       	pop	r22
    17f4:	5f 91       	pop	r21
    17f6:	4f 91       	pop	r20
    17f8:	3f 91       	pop	r19
    17fa:	2f 91       	pop	r18
    17fc:	1f 91       	pop	r17
    17fe:	0f 91       	pop	r16
    1800:	ff 90       	pop	r15
    1802:	ef 90       	pop	r14
    1804:	df 90       	pop	r13
    1806:	cf 90       	pop	r12
    1808:	bf 90       	pop	r11
    180a:	af 90       	pop	r10
    180c:	9f 90       	pop	r9
    180e:	8f 90       	pop	r8
    1810:	7f 90       	pop	r7
    1812:	6f 90       	pop	r6
    1814:	5f 90       	pop	r5
    1816:	4f 90       	pop	r4
    1818:	3f 90       	pop	r3
    181a:	2f 90       	pop	r2
    181c:	1f 90       	pop	r1
    181e:	0f 90       	pop	r0
    1820:	0f be       	out	0x3f, r0	; 63
    1822:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1824:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1826:	81 e0       	ldi	r24, 0x01	; 1
}
    1828:	cf 91       	pop	r28
    182a:	df 91       	pop	r29
    182c:	08 95       	ret

0000182e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    182e:	df 93       	push	r29
    1830:	cf 93       	push	r28
    1832:	cd b7       	in	r28, 0x3d	; 61
    1834:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1836:	cf 91       	pop	r28
    1838:	df 91       	pop	r29
    183a:	08 95       	ret

0000183c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    183c:	0f 92       	push	r0
    183e:	0f b6       	in	r0, 0x3f	; 63
    1840:	f8 94       	cli
    1842:	0f 92       	push	r0
    1844:	1f 92       	push	r1
    1846:	11 24       	eor	r1, r1
    1848:	2f 92       	push	r2
    184a:	3f 92       	push	r3
    184c:	4f 92       	push	r4
    184e:	5f 92       	push	r5
    1850:	6f 92       	push	r6
    1852:	7f 92       	push	r7
    1854:	8f 92       	push	r8
    1856:	9f 92       	push	r9
    1858:	af 92       	push	r10
    185a:	bf 92       	push	r11
    185c:	cf 92       	push	r12
    185e:	df 92       	push	r13
    1860:	ef 92       	push	r14
    1862:	ff 92       	push	r15
    1864:	0f 93       	push	r16
    1866:	1f 93       	push	r17
    1868:	2f 93       	push	r18
    186a:	3f 93       	push	r19
    186c:	4f 93       	push	r20
    186e:	5f 93       	push	r21
    1870:	6f 93       	push	r22
    1872:	7f 93       	push	r23
    1874:	8f 93       	push	r24
    1876:	9f 93       	push	r25
    1878:	af 93       	push	r26
    187a:	bf 93       	push	r27
    187c:	cf 93       	push	r28
    187e:	df 93       	push	r29
    1880:	ef 93       	push	r30
    1882:	ff 93       	push	r31
    1884:	a0 91 a0 07 	lds	r26, 0x07A0
    1888:	b0 91 a1 07 	lds	r27, 0x07A1
    188c:	0d b6       	in	r0, 0x3d	; 61
    188e:	0d 92       	st	X+, r0
    1890:	0e b6       	in	r0, 0x3e	; 62
    1892:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1894:	0e 94 1e 20 	call	0x403c	; 0x403c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1898:	a0 91 a0 07 	lds	r26, 0x07A0
    189c:	b0 91 a1 07 	lds	r27, 0x07A1
    18a0:	cd 91       	ld	r28, X+
    18a2:	cd bf       	out	0x3d, r28	; 61
    18a4:	dd 91       	ld	r29, X+
    18a6:	de bf       	out	0x3e, r29	; 62
    18a8:	ff 91       	pop	r31
    18aa:	ef 91       	pop	r30
    18ac:	df 91       	pop	r29
    18ae:	cf 91       	pop	r28
    18b0:	bf 91       	pop	r27
    18b2:	af 91       	pop	r26
    18b4:	9f 91       	pop	r25
    18b6:	8f 91       	pop	r24
    18b8:	7f 91       	pop	r23
    18ba:	6f 91       	pop	r22
    18bc:	5f 91       	pop	r21
    18be:	4f 91       	pop	r20
    18c0:	3f 91       	pop	r19
    18c2:	2f 91       	pop	r18
    18c4:	1f 91       	pop	r17
    18c6:	0f 91       	pop	r16
    18c8:	ff 90       	pop	r15
    18ca:	ef 90       	pop	r14
    18cc:	df 90       	pop	r13
    18ce:	cf 90       	pop	r12
    18d0:	bf 90       	pop	r11
    18d2:	af 90       	pop	r10
    18d4:	9f 90       	pop	r9
    18d6:	8f 90       	pop	r8
    18d8:	7f 90       	pop	r7
    18da:	6f 90       	pop	r6
    18dc:	5f 90       	pop	r5
    18de:	4f 90       	pop	r4
    18e0:	3f 90       	pop	r3
    18e2:	2f 90       	pop	r2
    18e4:	1f 90       	pop	r1
    18e6:	0f 90       	pop	r0
    18e8:	0f be       	out	0x3f, r0	; 63
    18ea:	0f 90       	pop	r0

	asm volatile ( "ret" );
    18ec:	08 95       	ret

000018ee <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    18ee:	0f 92       	push	r0
    18f0:	0f b6       	in	r0, 0x3f	; 63
    18f2:	f8 94       	cli
    18f4:	0f 92       	push	r0
    18f6:	1f 92       	push	r1
    18f8:	11 24       	eor	r1, r1
    18fa:	2f 92       	push	r2
    18fc:	3f 92       	push	r3
    18fe:	4f 92       	push	r4
    1900:	5f 92       	push	r5
    1902:	6f 92       	push	r6
    1904:	7f 92       	push	r7
    1906:	8f 92       	push	r8
    1908:	9f 92       	push	r9
    190a:	af 92       	push	r10
    190c:	bf 92       	push	r11
    190e:	cf 92       	push	r12
    1910:	df 92       	push	r13
    1912:	ef 92       	push	r14
    1914:	ff 92       	push	r15
    1916:	0f 93       	push	r16
    1918:	1f 93       	push	r17
    191a:	2f 93       	push	r18
    191c:	3f 93       	push	r19
    191e:	4f 93       	push	r20
    1920:	5f 93       	push	r21
    1922:	6f 93       	push	r22
    1924:	7f 93       	push	r23
    1926:	8f 93       	push	r24
    1928:	9f 93       	push	r25
    192a:	af 93       	push	r26
    192c:	bf 93       	push	r27
    192e:	cf 93       	push	r28
    1930:	df 93       	push	r29
    1932:	ef 93       	push	r30
    1934:	ff 93       	push	r31
    1936:	a0 91 a0 07 	lds	r26, 0x07A0
    193a:	b0 91 a1 07 	lds	r27, 0x07A1
    193e:	0d b6       	in	r0, 0x3d	; 61
    1940:	0d 92       	st	X+, r0
    1942:	0e b6       	in	r0, 0x3e	; 62
    1944:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1946:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <xTaskIncrementTick>
    194a:	88 23       	and	r24, r24
    194c:	11 f0       	breq	.+4      	; 0x1952 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    194e:	0e 94 1e 20 	call	0x403c	; 0x403c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1952:	a0 91 a0 07 	lds	r26, 0x07A0
    1956:	b0 91 a1 07 	lds	r27, 0x07A1
    195a:	cd 91       	ld	r28, X+
    195c:	cd bf       	out	0x3d, r28	; 61
    195e:	dd 91       	ld	r29, X+
    1960:	de bf       	out	0x3e, r29	; 62
    1962:	ff 91       	pop	r31
    1964:	ef 91       	pop	r30
    1966:	df 91       	pop	r29
    1968:	cf 91       	pop	r28
    196a:	bf 91       	pop	r27
    196c:	af 91       	pop	r26
    196e:	9f 91       	pop	r25
    1970:	8f 91       	pop	r24
    1972:	7f 91       	pop	r23
    1974:	6f 91       	pop	r22
    1976:	5f 91       	pop	r21
    1978:	4f 91       	pop	r20
    197a:	3f 91       	pop	r19
    197c:	2f 91       	pop	r18
    197e:	1f 91       	pop	r17
    1980:	0f 91       	pop	r16
    1982:	ff 90       	pop	r15
    1984:	ef 90       	pop	r14
    1986:	df 90       	pop	r13
    1988:	cf 90       	pop	r12
    198a:	bf 90       	pop	r11
    198c:	af 90       	pop	r10
    198e:	9f 90       	pop	r9
    1990:	8f 90       	pop	r8
    1992:	7f 90       	pop	r7
    1994:	6f 90       	pop	r6
    1996:	5f 90       	pop	r5
    1998:	4f 90       	pop	r4
    199a:	3f 90       	pop	r3
    199c:	2f 90       	pop	r2
    199e:	1f 90       	pop	r1
    19a0:	0f 90       	pop	r0
    19a2:	0f be       	out	0x3f, r0	; 63
    19a4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    19a6:	08 95       	ret

000019a8 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    19a8:	df 93       	push	r29
    19aa:	cf 93       	push	r28
    19ac:	00 d0       	rcall	.+0      	; 0x19ae <prvSetupTimerInterrupt+0x6>
    19ae:	00 d0       	rcall	.+0      	; 0x19b0 <prvSetupTimerInterrupt+0x8>
    19b0:	00 d0       	rcall	.+0      	; 0x19b2 <prvSetupTimerInterrupt+0xa>
    19b2:	cd b7       	in	r28, 0x3d	; 61
    19b4:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    19b6:	88 e8       	ldi	r24, 0x88	; 136
    19b8:	93 e1       	ldi	r25, 0x13	; 19
    19ba:	a0 e0       	ldi	r26, 0x00	; 0
    19bc:	b0 e0       	ldi	r27, 0x00	; 0
    19be:	8b 83       	std	Y+3, r24	; 0x03
    19c0:	9c 83       	std	Y+4, r25	; 0x04
    19c2:	ad 83       	std	Y+5, r26	; 0x05
    19c4:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    19c6:	8b 81       	ldd	r24, Y+3	; 0x03
    19c8:	9c 81       	ldd	r25, Y+4	; 0x04
    19ca:	ad 81       	ldd	r26, Y+5	; 0x05
    19cc:	be 81       	ldd	r27, Y+6	; 0x06
    19ce:	68 94       	set
    19d0:	15 f8       	bld	r1, 5
    19d2:	b6 95       	lsr	r27
    19d4:	a7 95       	ror	r26
    19d6:	97 95       	ror	r25
    19d8:	87 95       	ror	r24
    19da:	16 94       	lsr	r1
    19dc:	d1 f7       	brne	.-12     	; 0x19d2 <prvSetupTimerInterrupt+0x2a>
    19de:	8b 83       	std	Y+3, r24	; 0x03
    19e0:	9c 83       	std	Y+4, r25	; 0x04
    19e2:	ad 83       	std	Y+5, r26	; 0x05
    19e4:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    19e6:	8b 81       	ldd	r24, Y+3	; 0x03
    19e8:	9c 81       	ldd	r25, Y+4	; 0x04
    19ea:	ad 81       	ldd	r26, Y+5	; 0x05
    19ec:	be 81       	ldd	r27, Y+6	; 0x06
    19ee:	01 97       	sbiw	r24, 0x01	; 1
    19f0:	a1 09       	sbc	r26, r1
    19f2:	b1 09       	sbc	r27, r1
    19f4:	8b 83       	std	Y+3, r24	; 0x03
    19f6:	9c 83       	std	Y+4, r25	; 0x04
    19f8:	ad 83       	std	Y+5, r26	; 0x05
    19fa:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    19fc:	8b 81       	ldd	r24, Y+3	; 0x03
    19fe:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1a00:	8b 81       	ldd	r24, Y+3	; 0x03
    1a02:	9c 81       	ldd	r25, Y+4	; 0x04
    1a04:	ad 81       	ldd	r26, Y+5	; 0x05
    1a06:	be 81       	ldd	r27, Y+6	; 0x06
    1a08:	89 2f       	mov	r24, r25
    1a0a:	9a 2f       	mov	r25, r26
    1a0c:	ab 2f       	mov	r26, r27
    1a0e:	bb 27       	eor	r27, r27
    1a10:	8b 83       	std	Y+3, r24	; 0x03
    1a12:	9c 83       	std	Y+4, r25	; 0x04
    1a14:	ad 83       	std	Y+5, r26	; 0x05
    1a16:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1a18:	8b 81       	ldd	r24, Y+3	; 0x03
    1a1a:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1a1c:	eb e4       	ldi	r30, 0x4B	; 75
    1a1e:	f0 e0       	ldi	r31, 0x00	; 0
    1a20:	8a 81       	ldd	r24, Y+2	; 0x02
    1a22:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1a24:	ea e4       	ldi	r30, 0x4A	; 74
    1a26:	f0 e0       	ldi	r31, 0x00	; 0
    1a28:	89 81       	ldd	r24, Y+1	; 0x01
    1a2a:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1a2c:	8b e0       	ldi	r24, 0x0B	; 11
    1a2e:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1a30:	ee e4       	ldi	r30, 0x4E	; 78
    1a32:	f0 e0       	ldi	r31, 0x00	; 0
    1a34:	89 81       	ldd	r24, Y+1	; 0x01
    1a36:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1a38:	e9 e5       	ldi	r30, 0x59	; 89
    1a3a:	f0 e0       	ldi	r31, 0x00	; 0
    1a3c:	80 81       	ld	r24, Z
    1a3e:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1a40:	89 81       	ldd	r24, Y+1	; 0x01
    1a42:	80 61       	ori	r24, 0x10	; 16
    1a44:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1a46:	e9 e5       	ldi	r30, 0x59	; 89
    1a48:	f0 e0       	ldi	r31, 0x00	; 0
    1a4a:	89 81       	ldd	r24, Y+1	; 0x01
    1a4c:	80 83       	st	Z, r24
}
    1a4e:	26 96       	adiw	r28, 0x06	; 6
    1a50:	0f b6       	in	r0, 0x3f	; 63
    1a52:	f8 94       	cli
    1a54:	de bf       	out	0x3e, r29	; 62
    1a56:	0f be       	out	0x3f, r0	; 63
    1a58:	cd bf       	out	0x3d, r28	; 61
    1a5a:	cf 91       	pop	r28
    1a5c:	df 91       	pop	r29
    1a5e:	08 95       	ret

00001a60 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1a60:	0e 94 77 0c 	call	0x18ee	; 0x18ee <vPortYieldFromTick>
		asm volatile ( "reti" );
    1a64:	18 95       	reti

00001a66 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    1a66:	df 93       	push	r29
    1a68:	cf 93       	push	r28
    1a6a:	00 d0       	rcall	.+0      	; 0x1a6c <xEventGroupCreate+0x6>
    1a6c:	cd b7       	in	r28, 0x3d	; 61
    1a6e:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1a70:	8c e0       	ldi	r24, 0x0C	; 12
    1a72:	90 e0       	ldi	r25, 0x00	; 0
    1a74:	0e 94 17 07 	call	0xe2e	; 0xe2e <pvPortMalloc>
    1a78:	9a 83       	std	Y+2, r25	; 0x02
    1a7a:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    1a7c:	89 81       	ldd	r24, Y+1	; 0x01
    1a7e:	9a 81       	ldd	r25, Y+2	; 0x02
    1a80:	00 97       	sbiw	r24, 0x00	; 0
    1a82:	49 f0       	breq	.+18     	; 0x1a96 <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    1a84:	e9 81       	ldd	r30, Y+1	; 0x01
    1a86:	fa 81       	ldd	r31, Y+2	; 0x02
    1a88:	11 82       	std	Z+1, r1	; 0x01
    1a8a:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1a8c:	89 81       	ldd	r24, Y+1	; 0x01
    1a8e:	9a 81       	ldd	r25, Y+2	; 0x02
    1a90:	02 96       	adiw	r24, 0x02	; 2
    1a92:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    1a96:	89 81       	ldd	r24, Y+1	; 0x01
    1a98:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    1a9a:	0f 90       	pop	r0
    1a9c:	0f 90       	pop	r0
    1a9e:	cf 91       	pop	r28
    1aa0:	df 91       	pop	r29
    1aa2:	08 95       	ret

00001aa4 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    1aa4:	df 93       	push	r29
    1aa6:	cf 93       	push	r28
    1aa8:	cd b7       	in	r28, 0x3d	; 61
    1aaa:	de b7       	in	r29, 0x3e	; 62
    1aac:	60 97       	sbiw	r28, 0x10	; 16
    1aae:	0f b6       	in	r0, 0x3f	; 63
    1ab0:	f8 94       	cli
    1ab2:	de bf       	out	0x3e, r29	; 62
    1ab4:	0f be       	out	0x3f, r0	; 63
    1ab6:	cd bf       	out	0x3d, r28	; 61
    1ab8:	9a 87       	std	Y+10, r25	; 0x0a
    1aba:	89 87       	std	Y+9, r24	; 0x09
    1abc:	7c 87       	std	Y+12, r23	; 0x0c
    1abe:	6b 87       	std	Y+11, r22	; 0x0b
    1ac0:	5e 87       	std	Y+14, r21	; 0x0e
    1ac2:	4d 87       	std	Y+13, r20	; 0x0d
    1ac4:	38 8b       	std	Y+16, r19	; 0x10
    1ac6:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    1ac8:	89 85       	ldd	r24, Y+9	; 0x09
    1aca:	9a 85       	ldd	r25, Y+10	; 0x0a
    1acc:	9c 83       	std	Y+4, r25	; 0x04
    1ace:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1ad0:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    1ad2:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    1ad6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ad8:	fc 81       	ldd	r31, Y+4	; 0x04
    1ada:	80 81       	ld	r24, Z
    1adc:	91 81       	ldd	r25, Z+1	; 0x01
    1ade:	98 87       	std	Y+8, r25	; 0x08
    1ae0:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1ae2:	89 85       	ldd	r24, Y+9	; 0x09
    1ae4:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ae6:	2b 85       	ldd	r18, Y+11	; 0x0b
    1ae8:	3c 85       	ldd	r19, Y+12	; 0x0c
    1aea:	b9 01       	movw	r22, r18
    1aec:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1af0:	2f 81       	ldd	r18, Y+7	; 0x07
    1af2:	38 85       	ldd	r19, Y+8	; 0x08
    1af4:	8b 85       	ldd	r24, Y+11	; 0x0b
    1af6:	9c 85       	ldd	r25, Y+12	; 0x0c
    1af8:	28 2b       	or	r18, r24
    1afa:	39 2b       	or	r19, r25
    1afc:	8d 85       	ldd	r24, Y+13	; 0x0d
    1afe:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b00:	28 23       	and	r18, r24
    1b02:	39 23       	and	r19, r25
    1b04:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b06:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b08:	28 17       	cp	r18, r24
    1b0a:	39 07       	cpc	r19, r25
    1b0c:	c9 f4       	brne	.+50     	; 0x1b40 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1b0e:	2f 81       	ldd	r18, Y+7	; 0x07
    1b10:	38 85       	ldd	r19, Y+8	; 0x08
    1b12:	8b 85       	ldd	r24, Y+11	; 0x0b
    1b14:	9c 85       	ldd	r25, Y+12	; 0x0c
    1b16:	82 2b       	or	r24, r18
    1b18:	93 2b       	or	r25, r19
    1b1a:	9e 83       	std	Y+6, r25	; 0x06
    1b1c:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1b1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b20:	fc 81       	ldd	r31, Y+4	; 0x04
    1b22:	20 81       	ld	r18, Z
    1b24:	31 81       	ldd	r19, Z+1	; 0x01
    1b26:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b28:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b2a:	80 95       	com	r24
    1b2c:	90 95       	com	r25
    1b2e:	82 23       	and	r24, r18
    1b30:	93 23       	and	r25, r19
    1b32:	eb 81       	ldd	r30, Y+3	; 0x03
    1b34:	fc 81       	ldd	r31, Y+4	; 0x04
    1b36:	91 83       	std	Z+1, r25	; 0x01
    1b38:	80 83       	st	Z, r24

            xTicksToWait = 0;
    1b3a:	18 8a       	std	Y+16, r1	; 0x10
    1b3c:	1f 86       	std	Y+15, r1	; 0x0f
    1b3e:	1e c0       	rjmp	.+60     	; 0x1b7c <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    1b40:	8f 85       	ldd	r24, Y+15	; 0x0f
    1b42:	98 89       	ldd	r25, Y+16	; 0x10
    1b44:	00 97       	sbiw	r24, 0x00	; 0
    1b46:	91 f0       	breq	.+36     	; 0x1b6c <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1b48:	8b 81       	ldd	r24, Y+3	; 0x03
    1b4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b4c:	bc 01       	movw	r22, r24
    1b4e:	6e 5f       	subi	r22, 0xFE	; 254
    1b50:	7f 4f       	sbci	r23, 0xFF	; 255
    1b52:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b54:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b56:	9c 01       	movw	r18, r24
    1b58:	35 60       	ori	r19, 0x05	; 5
    1b5a:	4f 85       	ldd	r20, Y+15	; 0x0f
    1b5c:	58 89       	ldd	r21, Y+16	; 0x10
    1b5e:	cb 01       	movw	r24, r22
    1b60:	b9 01       	movw	r22, r18
    1b62:	0e 94 ad 20 	call	0x415a	; 0x415a <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    1b66:	1e 82       	std	Y+6, r1	; 0x06
    1b68:	1d 82       	std	Y+5, r1	; 0x05
    1b6a:	08 c0       	rjmp	.+16     	; 0x1b7c <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1b6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b70:	80 81       	ld	r24, Z
    1b72:	91 81       	ldd	r25, Z+1	; 0x01
    1b74:	9e 83       	std	Y+6, r25	; 0x06
    1b76:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    1b78:	81 e0       	ldi	r24, 0x01	; 1
    1b7a:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1b7c:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
    1b80:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    1b82:	8f 85       	ldd	r24, Y+15	; 0x0f
    1b84:	98 89       	ldd	r25, Y+16	; 0x10
    1b86:	00 97       	sbiw	r24, 0x00	; 0
    1b88:	09 f4       	brne	.+2      	; 0x1b8c <xEventGroupSync+0xe8>
    1b8a:	3a c0       	rjmp	.+116    	; 0x1c00 <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    1b8c:	8a 81       	ldd	r24, Y+2	; 0x02
    1b8e:	88 23       	and	r24, r24
    1b90:	11 f4       	brne	.+4      	; 0x1b96 <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    1b92:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1b96:	0e 94 68 24 	call	0x48d0	; 0x48d0 <uxTaskResetEventItemValue>
    1b9a:	9e 83       	std	Y+6, r25	; 0x06
    1b9c:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1b9e:	8d 81       	ldd	r24, Y+5	; 0x05
    1ba0:	9e 81       	ldd	r25, Y+6	; 0x06
    1ba2:	80 70       	andi	r24, 0x00	; 0
    1ba4:	92 70       	andi	r25, 0x02	; 2
    1ba6:	00 97       	sbiw	r24, 0x00	; 0
    1ba8:	31 f5       	brne	.+76     	; 0x1bf6 <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    1baa:	0f b6       	in	r0, 0x3f	; 63
    1bac:	f8 94       	cli
    1bae:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    1bb0:	eb 81       	ldd	r30, Y+3	; 0x03
    1bb2:	fc 81       	ldd	r31, Y+4	; 0x04
    1bb4:	80 81       	ld	r24, Z
    1bb6:	91 81       	ldd	r25, Z+1	; 0x01
    1bb8:	9e 83       	std	Y+6, r25	; 0x06
    1bba:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1bbc:	2d 81       	ldd	r18, Y+5	; 0x05
    1bbe:	3e 81       	ldd	r19, Y+6	; 0x06
    1bc0:	8d 85       	ldd	r24, Y+13	; 0x0d
    1bc2:	9e 85       	ldd	r25, Y+14	; 0x0e
    1bc4:	28 23       	and	r18, r24
    1bc6:	39 23       	and	r19, r25
    1bc8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1bca:	9e 85       	ldd	r25, Y+14	; 0x0e
    1bcc:	28 17       	cp	r18, r24
    1bce:	39 07       	cpc	r19, r25
    1bd0:	71 f4       	brne	.+28     	; 0x1bee <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1bd2:	eb 81       	ldd	r30, Y+3	; 0x03
    1bd4:	fc 81       	ldd	r31, Y+4	; 0x04
    1bd6:	20 81       	ld	r18, Z
    1bd8:	31 81       	ldd	r19, Z+1	; 0x01
    1bda:	8d 85       	ldd	r24, Y+13	; 0x0d
    1bdc:	9e 85       	ldd	r25, Y+14	; 0x0e
    1bde:	80 95       	com	r24
    1be0:	90 95       	com	r25
    1be2:	82 23       	and	r24, r18
    1be4:	93 23       	and	r25, r19
    1be6:	eb 81       	ldd	r30, Y+3	; 0x03
    1be8:	fc 81       	ldd	r31, Y+4	; 0x04
    1bea:	91 83       	std	Z+1, r25	; 0x01
    1bec:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    1bee:	0f 90       	pop	r0
    1bf0:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    1bf2:	81 e0       	ldi	r24, 0x01	; 1
    1bf4:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1bf6:	8d 81       	ldd	r24, Y+5	; 0x05
    1bf8:	9e 81       	ldd	r25, Y+6	; 0x06
    1bfa:	90 70       	andi	r25, 0x00	; 0
    1bfc:	9e 83       	std	Y+6, r25	; 0x06
    1bfe:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1c00:	8d 81       	ldd	r24, Y+5	; 0x05
    1c02:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1c04:	60 96       	adiw	r28, 0x10	; 16
    1c06:	0f b6       	in	r0, 0x3f	; 63
    1c08:	f8 94       	cli
    1c0a:	de bf       	out	0x3e, r29	; 62
    1c0c:	0f be       	out	0x3f, r0	; 63
    1c0e:	cd bf       	out	0x3d, r28	; 61
    1c10:	cf 91       	pop	r28
    1c12:	df 91       	pop	r29
    1c14:	08 95       	ret

00001c16 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    1c16:	0f 93       	push	r16
    1c18:	1f 93       	push	r17
    1c1a:	df 93       	push	r29
    1c1c:	cf 93       	push	r28
    1c1e:	cd b7       	in	r28, 0x3d	; 61
    1c20:	de b7       	in	r29, 0x3e	; 62
    1c22:	63 97       	sbiw	r28, 0x13	; 19
    1c24:	0f b6       	in	r0, 0x3f	; 63
    1c26:	f8 94       	cli
    1c28:	de bf       	out	0x3e, r29	; 62
    1c2a:	0f be       	out	0x3f, r0	; 63
    1c2c:	cd bf       	out	0x3d, r28	; 61
    1c2e:	9d 87       	std	Y+13, r25	; 0x0d
    1c30:	8c 87       	std	Y+12, r24	; 0x0c
    1c32:	7f 87       	std	Y+15, r23	; 0x0f
    1c34:	6e 87       	std	Y+14, r22	; 0x0e
    1c36:	48 8b       	std	Y+16, r20	; 0x10
    1c38:	29 8b       	std	Y+17, r18	; 0x11
    1c3a:	1b 8b       	std	Y+19, r17	; 0x13
    1c3c:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    1c3e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c40:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c42:	9b 87       	std	Y+11, r25	; 0x0b
    1c44:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    1c46:	1f 82       	std	Y+7, r1	; 0x07
    1c48:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1c4a:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    1c4c:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1c50:	ea 85       	ldd	r30, Y+10	; 0x0a
    1c52:	fb 85       	ldd	r31, Y+11	; 0x0b
    1c54:	80 81       	ld	r24, Z
    1c56:	91 81       	ldd	r25, Z+1	; 0x01
    1c58:	9a 83       	std	Y+2, r25	; 0x02
    1c5a:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    1c5c:	89 81       	ldd	r24, Y+1	; 0x01
    1c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c60:	2e 85       	ldd	r18, Y+14	; 0x0e
    1c62:	3f 85       	ldd	r19, Y+15	; 0x0f
    1c64:	b9 01       	movw	r22, r18
    1c66:	49 89       	ldd	r20, Y+17	; 0x11
    1c68:	0e 94 46 10 	call	0x208c	; 0x208c <prvTestWaitCondition>
    1c6c:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    1c6e:	8d 81       	ldd	r24, Y+5	; 0x05
    1c70:	88 23       	and	r24, r24
    1c72:	c1 f0       	breq	.+48     	; 0x1ca4 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    1c74:	89 81       	ldd	r24, Y+1	; 0x01
    1c76:	9a 81       	ldd	r25, Y+2	; 0x02
    1c78:	99 87       	std	Y+9, r25	; 0x09
    1c7a:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    1c7c:	1b 8a       	std	Y+19, r1	; 0x13
    1c7e:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    1c80:	88 89       	ldd	r24, Y+16	; 0x10
    1c82:	88 23       	and	r24, r24
    1c84:	e9 f1       	breq	.+122    	; 0x1d00 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1c86:	ea 85       	ldd	r30, Y+10	; 0x0a
    1c88:	fb 85       	ldd	r31, Y+11	; 0x0b
    1c8a:	20 81       	ld	r18, Z
    1c8c:	31 81       	ldd	r19, Z+1	; 0x01
    1c8e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c90:	9f 85       	ldd	r25, Y+15	; 0x0f
    1c92:	80 95       	com	r24
    1c94:	90 95       	com	r25
    1c96:	82 23       	and	r24, r18
    1c98:	93 23       	and	r25, r19
    1c9a:	ea 85       	ldd	r30, Y+10	; 0x0a
    1c9c:	fb 85       	ldd	r31, Y+11	; 0x0b
    1c9e:	91 83       	std	Z+1, r25	; 0x01
    1ca0:	80 83       	st	Z, r24
    1ca2:	2e c0       	rjmp	.+92     	; 0x1d00 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    1ca4:	8a 89       	ldd	r24, Y+18	; 0x12
    1ca6:	9b 89       	ldd	r25, Y+19	; 0x13
    1ca8:	00 97       	sbiw	r24, 0x00	; 0
    1caa:	39 f4       	brne	.+14     	; 0x1cba <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    1cac:	89 81       	ldd	r24, Y+1	; 0x01
    1cae:	9a 81       	ldd	r25, Y+2	; 0x02
    1cb0:	99 87       	std	Y+9, r25	; 0x09
    1cb2:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
    1cb6:	8b 83       	std	Y+3, r24	; 0x03
    1cb8:	23 c0       	rjmp	.+70     	; 0x1d00 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    1cba:	88 89       	ldd	r24, Y+16	; 0x10
    1cbc:	88 23       	and	r24, r24
    1cbe:	29 f0       	breq	.+10     	; 0x1cca <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1cc0:	8e 81       	ldd	r24, Y+6	; 0x06
    1cc2:	9f 81       	ldd	r25, Y+7	; 0x07
    1cc4:	91 60       	ori	r25, 0x01	; 1
    1cc6:	9f 83       	std	Y+7, r25	; 0x07
    1cc8:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    1cca:	89 89       	ldd	r24, Y+17	; 0x11
    1ccc:	88 23       	and	r24, r24
    1cce:	29 f0       	breq	.+10     	; 0x1cda <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    1cd0:	8e 81       	ldd	r24, Y+6	; 0x06
    1cd2:	9f 81       	ldd	r25, Y+7	; 0x07
    1cd4:	94 60       	ori	r25, 0x04	; 4
    1cd6:	9f 83       	std	Y+7, r25	; 0x07
    1cd8:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1cda:	8a 85       	ldd	r24, Y+10	; 0x0a
    1cdc:	9b 85       	ldd	r25, Y+11	; 0x0b
    1cde:	bc 01       	movw	r22, r24
    1ce0:	6e 5f       	subi	r22, 0xFE	; 254
    1ce2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ce4:	2e 85       	ldd	r18, Y+14	; 0x0e
    1ce6:	3f 85       	ldd	r19, Y+15	; 0x0f
    1ce8:	8e 81       	ldd	r24, Y+6	; 0x06
    1cea:	9f 81       	ldd	r25, Y+7	; 0x07
    1cec:	28 2b       	or	r18, r24
    1cee:	39 2b       	or	r19, r25
    1cf0:	4a 89       	ldd	r20, Y+18	; 0x12
    1cf2:	5b 89       	ldd	r21, Y+19	; 0x13
    1cf4:	cb 01       	movw	r24, r22
    1cf6:	b9 01       	movw	r22, r18
    1cf8:	0e 94 ad 20 	call	0x415a	; 0x415a <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    1cfc:	19 86       	std	Y+9, r1	; 0x09
    1cfe:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1d00:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
    1d04:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    1d06:	8a 89       	ldd	r24, Y+18	; 0x12
    1d08:	9b 89       	ldd	r25, Y+19	; 0x13
    1d0a:	00 97       	sbiw	r24, 0x00	; 0
    1d0c:	09 f4       	brne	.+2      	; 0x1d10 <xEventGroupWaitBits+0xfa>
    1d0e:	3c c0       	rjmp	.+120    	; 0x1d88 <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    1d10:	8c 81       	ldd	r24, Y+4	; 0x04
    1d12:	88 23       	and	r24, r24
    1d14:	11 f4       	brne	.+4      	; 0x1d1a <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    1d16:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1d1a:	0e 94 68 24 	call	0x48d0	; 0x48d0 <uxTaskResetEventItemValue>
    1d1e:	99 87       	std	Y+9, r25	; 0x09
    1d20:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1d22:	88 85       	ldd	r24, Y+8	; 0x08
    1d24:	99 85       	ldd	r25, Y+9	; 0x09
    1d26:	80 70       	andi	r24, 0x00	; 0
    1d28:	92 70       	andi	r25, 0x02	; 2
    1d2a:	00 97       	sbiw	r24, 0x00	; 0
    1d2c:	41 f5       	brne	.+80     	; 0x1d7e <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    1d2e:	0f b6       	in	r0, 0x3f	; 63
    1d30:	f8 94       	cli
    1d32:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1d34:	ea 85       	ldd	r30, Y+10	; 0x0a
    1d36:	fb 85       	ldd	r31, Y+11	; 0x0b
    1d38:	80 81       	ld	r24, Z
    1d3a:	91 81       	ldd	r25, Z+1	; 0x01
    1d3c:	99 87       	std	Y+9, r25	; 0x09
    1d3e:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1d40:	88 85       	ldd	r24, Y+8	; 0x08
    1d42:	99 85       	ldd	r25, Y+9	; 0x09
    1d44:	2e 85       	ldd	r18, Y+14	; 0x0e
    1d46:	3f 85       	ldd	r19, Y+15	; 0x0f
    1d48:	b9 01       	movw	r22, r18
    1d4a:	49 89       	ldd	r20, Y+17	; 0x11
    1d4c:	0e 94 46 10 	call	0x208c	; 0x208c <prvTestWaitCondition>
    1d50:	88 23       	and	r24, r24
    1d52:	89 f0       	breq	.+34     	; 0x1d76 <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    1d54:	88 89       	ldd	r24, Y+16	; 0x10
    1d56:	88 23       	and	r24, r24
    1d58:	71 f0       	breq	.+28     	; 0x1d76 <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1d5a:	ea 85       	ldd	r30, Y+10	; 0x0a
    1d5c:	fb 85       	ldd	r31, Y+11	; 0x0b
    1d5e:	20 81       	ld	r18, Z
    1d60:	31 81       	ldd	r19, Z+1	; 0x01
    1d62:	8e 85       	ldd	r24, Y+14	; 0x0e
    1d64:	9f 85       	ldd	r25, Y+15	; 0x0f
    1d66:	80 95       	com	r24
    1d68:	90 95       	com	r25
    1d6a:	82 23       	and	r24, r18
    1d6c:	93 23       	and	r25, r19
    1d6e:	ea 85       	ldd	r30, Y+10	; 0x0a
    1d70:	fb 85       	ldd	r31, Y+11	; 0x0b
    1d72:	91 83       	std	Z+1, r25	; 0x01
    1d74:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    1d76:	81 e0       	ldi	r24, 0x01	; 1
    1d78:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    1d7a:	0f 90       	pop	r0
    1d7c:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1d7e:	88 85       	ldd	r24, Y+8	; 0x08
    1d80:	99 85       	ldd	r25, Y+9	; 0x09
    1d82:	90 70       	andi	r25, 0x00	; 0
    1d84:	99 87       	std	Y+9, r25	; 0x09
    1d86:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1d88:	88 85       	ldd	r24, Y+8	; 0x08
    1d8a:	99 85       	ldd	r25, Y+9	; 0x09
}
    1d8c:	63 96       	adiw	r28, 0x13	; 19
    1d8e:	0f b6       	in	r0, 0x3f	; 63
    1d90:	f8 94       	cli
    1d92:	de bf       	out	0x3e, r29	; 62
    1d94:	0f be       	out	0x3f, r0	; 63
    1d96:	cd bf       	out	0x3d, r28	; 61
    1d98:	cf 91       	pop	r28
    1d9a:	df 91       	pop	r29
    1d9c:	1f 91       	pop	r17
    1d9e:	0f 91       	pop	r16
    1da0:	08 95       	ret

00001da2 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    1da2:	df 93       	push	r29
    1da4:	cf 93       	push	r28
    1da6:	cd b7       	in	r28, 0x3d	; 61
    1da8:	de b7       	in	r29, 0x3e	; 62
    1daa:	28 97       	sbiw	r28, 0x08	; 8
    1dac:	0f b6       	in	r0, 0x3f	; 63
    1dae:	f8 94       	cli
    1db0:	de bf       	out	0x3e, r29	; 62
    1db2:	0f be       	out	0x3f, r0	; 63
    1db4:	cd bf       	out	0x3d, r28	; 61
    1db6:	9e 83       	std	Y+6, r25	; 0x06
    1db8:	8d 83       	std	Y+5, r24	; 0x05
    1dba:	78 87       	std	Y+8, r23	; 0x08
    1dbc:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    1dbe:	8d 81       	ldd	r24, Y+5	; 0x05
    1dc0:	9e 81       	ldd	r25, Y+6	; 0x06
    1dc2:	9c 83       	std	Y+4, r25	; 0x04
    1dc4:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    1dc6:	0f b6       	in	r0, 0x3f	; 63
    1dc8:	f8 94       	cli
    1dca:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    1dcc:	eb 81       	ldd	r30, Y+3	; 0x03
    1dce:	fc 81       	ldd	r31, Y+4	; 0x04
    1dd0:	80 81       	ld	r24, Z
    1dd2:	91 81       	ldd	r25, Z+1	; 0x01
    1dd4:	9a 83       	std	Y+2, r25	; 0x02
    1dd6:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1dd8:	eb 81       	ldd	r30, Y+3	; 0x03
    1dda:	fc 81       	ldd	r31, Y+4	; 0x04
    1ddc:	20 81       	ld	r18, Z
    1dde:	31 81       	ldd	r19, Z+1	; 0x01
    1de0:	8f 81       	ldd	r24, Y+7	; 0x07
    1de2:	98 85       	ldd	r25, Y+8	; 0x08
    1de4:	80 95       	com	r24
    1de6:	90 95       	com	r25
    1de8:	82 23       	and	r24, r18
    1dea:	93 23       	and	r25, r19
    1dec:	eb 81       	ldd	r30, Y+3	; 0x03
    1dee:	fc 81       	ldd	r31, Y+4	; 0x04
    1df0:	91 83       	std	Z+1, r25	; 0x01
    1df2:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    1df4:	0f 90       	pop	r0
    1df6:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    1df8:	89 81       	ldd	r24, Y+1	; 0x01
    1dfa:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1dfc:	28 96       	adiw	r28, 0x08	; 8
    1dfe:	0f b6       	in	r0, 0x3f	; 63
    1e00:	f8 94       	cli
    1e02:	de bf       	out	0x3e, r29	; 62
    1e04:	0f be       	out	0x3f, r0	; 63
    1e06:	cd bf       	out	0x3d, r28	; 61
    1e08:	cf 91       	pop	r28
    1e0a:	df 91       	pop	r29
    1e0c:	08 95       	ret

00001e0e <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1e0e:	df 93       	push	r29
    1e10:	cf 93       	push	r28
    1e12:	cd b7       	in	r28, 0x3d	; 61
    1e14:	de b7       	in	r29, 0x3e	; 62
    1e16:	27 97       	sbiw	r28, 0x07	; 7
    1e18:	0f b6       	in	r0, 0x3f	; 63
    1e1a:	f8 94       	cli
    1e1c:	de bf       	out	0x3e, r29	; 62
    1e1e:	0f be       	out	0x3f, r0	; 63
    1e20:	cd bf       	out	0x3d, r28	; 61
    1e22:	9f 83       	std	Y+7, r25	; 0x07
    1e24:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    1e26:	8e 81       	ldd	r24, Y+6	; 0x06
    1e28:	9f 81       	ldd	r25, Y+7	; 0x07
    1e2a:	9c 83       	std	Y+4, r25	; 0x04
    1e2c:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1e2e:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    1e30:	eb 81       	ldd	r30, Y+3	; 0x03
    1e32:	fc 81       	ldd	r31, Y+4	; 0x04
    1e34:	80 81       	ld	r24, Z
    1e36:	91 81       	ldd	r25, Z+1	; 0x01
    1e38:	9a 83       	std	Y+2, r25	; 0x02
    1e3a:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    1e3c:	89 81       	ldd	r24, Y+1	; 0x01
    1e3e:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1e40:	27 96       	adiw	r28, 0x07	; 7
    1e42:	0f b6       	in	r0, 0x3f	; 63
    1e44:	f8 94       	cli
    1e46:	de bf       	out	0x3e, r29	; 62
    1e48:	0f be       	out	0x3f, r0	; 63
    1e4a:	cd bf       	out	0x3d, r28	; 61
    1e4c:	cf 91       	pop	r28
    1e4e:	df 91       	pop	r29
    1e50:	08 95       	ret

00001e52 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    1e52:	df 93       	push	r29
    1e54:	cf 93       	push	r28
    1e56:	cd b7       	in	r28, 0x3d	; 61
    1e58:	de b7       	in	r29, 0x3e	; 62
    1e5a:	65 97       	sbiw	r28, 0x15	; 21
    1e5c:	0f b6       	in	r0, 0x3f	; 63
    1e5e:	f8 94       	cli
    1e60:	de bf       	out	0x3e, r29	; 62
    1e62:	0f be       	out	0x3f, r0	; 63
    1e64:	cd bf       	out	0x3d, r28	; 61
    1e66:	9b 8b       	std	Y+19, r25	; 0x13
    1e68:	8a 8b       	std	Y+18, r24	; 0x12
    1e6a:	7d 8b       	std	Y+21, r23	; 0x15
    1e6c:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1e6e:	19 86       	std	Y+9, r1	; 0x09
    1e70:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    1e72:	8a 89       	ldd	r24, Y+18	; 0x12
    1e74:	9b 89       	ldd	r25, Y+19	; 0x13
    1e76:	9b 83       	std	Y+3, r25	; 0x03
    1e78:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    1e7a:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    1e7c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e7e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e80:	02 96       	adiw	r24, 0x02	; 2
    1e82:	9b 87       	std	Y+11, r25	; 0x0b
    1e84:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1e86:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e88:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e8a:	03 96       	adiw	r24, 0x03	; 3
    1e8c:	9d 87       	std	Y+13, r25	; 0x0d
    1e8e:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    1e90:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    1e94:	ea 85       	ldd	r30, Y+10	; 0x0a
    1e96:	fb 85       	ldd	r31, Y+11	; 0x0b
    1e98:	85 81       	ldd	r24, Z+5	; 0x05
    1e9a:	96 81       	ldd	r25, Z+6	; 0x06
    1e9c:	99 8b       	std	Y+17, r25	; 0x11
    1e9e:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    1ea0:	ea 81       	ldd	r30, Y+2	; 0x02
    1ea2:	fb 81       	ldd	r31, Y+3	; 0x03
    1ea4:	20 81       	ld	r18, Z
    1ea6:	31 81       	ldd	r19, Z+1	; 0x01
    1ea8:	8c 89       	ldd	r24, Y+20	; 0x14
    1eaa:	9d 89       	ldd	r25, Y+21	; 0x15
    1eac:	82 2b       	or	r24, r18
    1eae:	93 2b       	or	r25, r19
    1eb0:	ea 81       	ldd	r30, Y+2	; 0x02
    1eb2:	fb 81       	ldd	r31, Y+3	; 0x03
    1eb4:	91 83       	std	Z+1, r25	; 0x01
    1eb6:	80 83       	st	Z, r24
    1eb8:	59 c0       	rjmp	.+178    	; 0x1f6c <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    1eba:	e8 89       	ldd	r30, Y+16	; 0x10
    1ebc:	f9 89       	ldd	r31, Y+17	; 0x11
    1ebe:	82 81       	ldd	r24, Z+2	; 0x02
    1ec0:	93 81       	ldd	r25, Z+3	; 0x03
    1ec2:	9f 87       	std	Y+15, r25	; 0x0f
    1ec4:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1ec6:	e8 89       	ldd	r30, Y+16	; 0x10
    1ec8:	f9 89       	ldd	r31, Y+17	; 0x11
    1eca:	80 81       	ld	r24, Z
    1ecc:	91 81       	ldd	r25, Z+1	; 0x01
    1ece:	9f 83       	std	Y+7, r25	; 0x07
    1ed0:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    1ed2:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1ed4:	8e 81       	ldd	r24, Y+6	; 0x06
    1ed6:	9f 81       	ldd	r25, Y+7	; 0x07
    1ed8:	80 70       	andi	r24, 0x00	; 0
    1eda:	9d 83       	std	Y+5, r25	; 0x05
    1edc:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1ede:	8e 81       	ldd	r24, Y+6	; 0x06
    1ee0:	9f 81       	ldd	r25, Y+7	; 0x07
    1ee2:	90 70       	andi	r25, 0x00	; 0
    1ee4:	9f 83       	std	Y+7, r25	; 0x07
    1ee6:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1ee8:	8c 81       	ldd	r24, Y+4	; 0x04
    1eea:	9d 81       	ldd	r25, Y+5	; 0x05
    1eec:	80 70       	andi	r24, 0x00	; 0
    1eee:	94 70       	andi	r25, 0x04	; 4
    1ef0:	00 97       	sbiw	r24, 0x00	; 0
    1ef2:	69 f4       	brne	.+26     	; 0x1f0e <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1ef4:	ea 81       	ldd	r30, Y+2	; 0x02
    1ef6:	fb 81       	ldd	r31, Y+3	; 0x03
    1ef8:	20 81       	ld	r18, Z
    1efa:	31 81       	ldd	r19, Z+1	; 0x01
    1efc:	8e 81       	ldd	r24, Y+6	; 0x06
    1efe:	9f 81       	ldd	r25, Y+7	; 0x07
    1f00:	82 23       	and	r24, r18
    1f02:	93 23       	and	r25, r19
    1f04:	00 97       	sbiw	r24, 0x00	; 0
    1f06:	91 f0       	breq	.+36     	; 0x1f2c <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    1f08:	81 e0       	ldi	r24, 0x01	; 1
    1f0a:	89 83       	std	Y+1, r24	; 0x01
    1f0c:	0f c0       	rjmp	.+30     	; 0x1f2c <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1f0e:	ea 81       	ldd	r30, Y+2	; 0x02
    1f10:	fb 81       	ldd	r31, Y+3	; 0x03
    1f12:	20 81       	ld	r18, Z
    1f14:	31 81       	ldd	r19, Z+1	; 0x01
    1f16:	8e 81       	ldd	r24, Y+6	; 0x06
    1f18:	9f 81       	ldd	r25, Y+7	; 0x07
    1f1a:	28 23       	and	r18, r24
    1f1c:	39 23       	and	r19, r25
    1f1e:	8e 81       	ldd	r24, Y+6	; 0x06
    1f20:	9f 81       	ldd	r25, Y+7	; 0x07
    1f22:	28 17       	cp	r18, r24
    1f24:	39 07       	cpc	r19, r25
    1f26:	11 f4       	brne	.+4      	; 0x1f2c <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    1f28:	81 e0       	ldi	r24, 0x01	; 1
    1f2a:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    1f2c:	89 81       	ldd	r24, Y+1	; 0x01
    1f2e:	88 23       	and	r24, r24
    1f30:	c9 f0       	breq	.+50     	; 0x1f64 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1f32:	8c 81       	ldd	r24, Y+4	; 0x04
    1f34:	9d 81       	ldd	r25, Y+5	; 0x05
    1f36:	80 70       	andi	r24, 0x00	; 0
    1f38:	91 70       	andi	r25, 0x01	; 1
    1f3a:	00 97       	sbiw	r24, 0x00	; 0
    1f3c:	41 f0       	breq	.+16     	; 0x1f4e <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    1f3e:	88 85       	ldd	r24, Y+8	; 0x08
    1f40:	99 85       	ldd	r25, Y+9	; 0x09
    1f42:	2e 81       	ldd	r18, Y+6	; 0x06
    1f44:	3f 81       	ldd	r19, Y+7	; 0x07
    1f46:	82 2b       	or	r24, r18
    1f48:	93 2b       	or	r25, r19
    1f4a:	99 87       	std	Y+9, r25	; 0x09
    1f4c:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1f4e:	ea 81       	ldd	r30, Y+2	; 0x02
    1f50:	fb 81       	ldd	r31, Y+3	; 0x03
    1f52:	80 81       	ld	r24, Z
    1f54:	91 81       	ldd	r25, Z+1	; 0x01
    1f56:	9c 01       	movw	r18, r24
    1f58:	32 60       	ori	r19, 0x02	; 2
    1f5a:	88 89       	ldd	r24, Y+16	; 0x10
    1f5c:	99 89       	ldd	r25, Y+17	; 0x11
    1f5e:	b9 01       	movw	r22, r18
    1f60:	0e 94 48 21 	call	0x4290	; 0x4290 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    1f64:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f66:	9f 85       	ldd	r25, Y+15	; 0x0f
    1f68:	99 8b       	std	Y+17, r25	; 0x11
    1f6a:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    1f6c:	28 89       	ldd	r18, Y+16	; 0x10
    1f6e:	39 89       	ldd	r19, Y+17	; 0x11
    1f70:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f72:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f74:	28 17       	cp	r18, r24
    1f76:	39 07       	cpc	r19, r25
    1f78:	09 f0       	breq	.+2      	; 0x1f7c <xEventGroupSetBits+0x12a>
    1f7a:	9f cf       	rjmp	.-194    	; 0x1eba <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1f7c:	ea 81       	ldd	r30, Y+2	; 0x02
    1f7e:	fb 81       	ldd	r31, Y+3	; 0x03
    1f80:	20 81       	ld	r18, Z
    1f82:	31 81       	ldd	r19, Z+1	; 0x01
    1f84:	88 85       	ldd	r24, Y+8	; 0x08
    1f86:	99 85       	ldd	r25, Y+9	; 0x09
    1f88:	80 95       	com	r24
    1f8a:	90 95       	com	r25
    1f8c:	82 23       	and	r24, r18
    1f8e:	93 23       	and	r25, r19
    1f90:	ea 81       	ldd	r30, Y+2	; 0x02
    1f92:	fb 81       	ldd	r31, Y+3	; 0x03
    1f94:	91 83       	std	Z+1, r25	; 0x01
    1f96:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    1f98:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    1f9c:	ea 81       	ldd	r30, Y+2	; 0x02
    1f9e:	fb 81       	ldd	r31, Y+3	; 0x03
    1fa0:	80 81       	ld	r24, Z
    1fa2:	91 81       	ldd	r25, Z+1	; 0x01
}
    1fa4:	65 96       	adiw	r28, 0x15	; 21
    1fa6:	0f b6       	in	r0, 0x3f	; 63
    1fa8:	f8 94       	cli
    1faa:	de bf       	out	0x3e, r29	; 62
    1fac:	0f be       	out	0x3f, r0	; 63
    1fae:	cd bf       	out	0x3d, r28	; 61
    1fb0:	cf 91       	pop	r28
    1fb2:	df 91       	pop	r29
    1fb4:	08 95       	ret

00001fb6 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1fb6:	df 93       	push	r29
    1fb8:	cf 93       	push	r28
    1fba:	00 d0       	rcall	.+0      	; 0x1fbc <vEventGroupDelete+0x6>
    1fbc:	00 d0       	rcall	.+0      	; 0x1fbe <vEventGroupDelete+0x8>
    1fbe:	00 d0       	rcall	.+0      	; 0x1fc0 <vEventGroupDelete+0xa>
    1fc0:	cd b7       	in	r28, 0x3d	; 61
    1fc2:	de b7       	in	r29, 0x3e	; 62
    1fc4:	9e 83       	std	Y+6, r25	; 0x06
    1fc6:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    1fc8:	8d 81       	ldd	r24, Y+5	; 0x05
    1fca:	9e 81       	ldd	r25, Y+6	; 0x06
    1fcc:	9c 83       	std	Y+4, r25	; 0x04
    1fce:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1fd0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd4:	02 96       	adiw	r24, 0x02	; 2
    1fd6:	9a 83       	std	Y+2, r25	; 0x02
    1fd8:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    1fda:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
    1fde:	08 c0       	rjmp	.+16     	; 0x1ff0 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1fe0:	e9 81       	ldd	r30, Y+1	; 0x01
    1fe2:	fa 81       	ldd	r31, Y+2	; 0x02
    1fe4:	85 81       	ldd	r24, Z+5	; 0x05
    1fe6:	96 81       	ldd	r25, Z+6	; 0x06
    1fe8:	60 e0       	ldi	r22, 0x00	; 0
    1fea:	72 e0       	ldi	r23, 0x02	; 2
    1fec:	0e 94 48 21 	call	0x4290	; 0x4290 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1ff0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ff2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ff4:	80 81       	ld	r24, Z
    1ff6:	88 23       	and	r24, r24
    1ff8:	99 f7       	brne	.-26     	; 0x1fe0 <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    1ffa:	8b 81       	ldd	r24, Y+3	; 0x03
    1ffc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ffe:	0e 94 25 08 	call	0x104a	; 0x104a <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    2002:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
}
    2006:	26 96       	adiw	r28, 0x06	; 6
    2008:	0f b6       	in	r0, 0x3f	; 63
    200a:	f8 94       	cli
    200c:	de bf       	out	0x3e, r29	; 62
    200e:	0f be       	out	0x3f, r0	; 63
    2010:	cd bf       	out	0x3d, r28	; 61
    2012:	cf 91       	pop	r28
    2014:	df 91       	pop	r29
    2016:	08 95       	ret

00002018 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    2018:	df 93       	push	r29
    201a:	cf 93       	push	r28
    201c:	00 d0       	rcall	.+0      	; 0x201e <vEventGroupSetBitsCallback+0x6>
    201e:	00 d0       	rcall	.+0      	; 0x2020 <vEventGroupSetBitsCallback+0x8>
    2020:	00 d0       	rcall	.+0      	; 0x2022 <vEventGroupSetBitsCallback+0xa>
    2022:	cd b7       	in	r28, 0x3d	; 61
    2024:	de b7       	in	r29, 0x3e	; 62
    2026:	9a 83       	std	Y+2, r25	; 0x02
    2028:	89 83       	std	Y+1, r24	; 0x01
    202a:	4b 83       	std	Y+3, r20	; 0x03
    202c:	5c 83       	std	Y+4, r21	; 0x04
    202e:	6d 83       	std	Y+5, r22	; 0x05
    2030:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2032:	89 81       	ldd	r24, Y+1	; 0x01
    2034:	9a 81       	ldd	r25, Y+2	; 0x02
    2036:	2b 81       	ldd	r18, Y+3	; 0x03
    2038:	3c 81       	ldd	r19, Y+4	; 0x04
    203a:	b9 01       	movw	r22, r18
    203c:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <xEventGroupSetBits>
}
    2040:	26 96       	adiw	r28, 0x06	; 6
    2042:	0f b6       	in	r0, 0x3f	; 63
    2044:	f8 94       	cli
    2046:	de bf       	out	0x3e, r29	; 62
    2048:	0f be       	out	0x3f, r0	; 63
    204a:	cd bf       	out	0x3d, r28	; 61
    204c:	cf 91       	pop	r28
    204e:	df 91       	pop	r29
    2050:	08 95       	ret

00002052 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    2052:	df 93       	push	r29
    2054:	cf 93       	push	r28
    2056:	00 d0       	rcall	.+0      	; 0x2058 <vEventGroupClearBitsCallback+0x6>
    2058:	00 d0       	rcall	.+0      	; 0x205a <vEventGroupClearBitsCallback+0x8>
    205a:	00 d0       	rcall	.+0      	; 0x205c <vEventGroupClearBitsCallback+0xa>
    205c:	cd b7       	in	r28, 0x3d	; 61
    205e:	de b7       	in	r29, 0x3e	; 62
    2060:	9a 83       	std	Y+2, r25	; 0x02
    2062:	89 83       	std	Y+1, r24	; 0x01
    2064:	4b 83       	std	Y+3, r20	; 0x03
    2066:	5c 83       	std	Y+4, r21	; 0x04
    2068:	6d 83       	std	Y+5, r22	; 0x05
    206a:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    206c:	89 81       	ldd	r24, Y+1	; 0x01
    206e:	9a 81       	ldd	r25, Y+2	; 0x02
    2070:	2b 81       	ldd	r18, Y+3	; 0x03
    2072:	3c 81       	ldd	r19, Y+4	; 0x04
    2074:	b9 01       	movw	r22, r18
    2076:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <xEventGroupClearBits>
}
    207a:	26 96       	adiw	r28, 0x06	; 6
    207c:	0f b6       	in	r0, 0x3f	; 63
    207e:	f8 94       	cli
    2080:	de bf       	out	0x3e, r29	; 62
    2082:	0f be       	out	0x3f, r0	; 63
    2084:	cd bf       	out	0x3d, r28	; 61
    2086:	cf 91       	pop	r28
    2088:	df 91       	pop	r29
    208a:	08 95       	ret

0000208c <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    208c:	df 93       	push	r29
    208e:	cf 93       	push	r28
    2090:	00 d0       	rcall	.+0      	; 0x2092 <prvTestWaitCondition+0x6>
    2092:	00 d0       	rcall	.+0      	; 0x2094 <prvTestWaitCondition+0x8>
    2094:	00 d0       	rcall	.+0      	; 0x2096 <prvTestWaitCondition+0xa>
    2096:	cd b7       	in	r28, 0x3d	; 61
    2098:	de b7       	in	r29, 0x3e	; 62
    209a:	9b 83       	std	Y+3, r25	; 0x03
    209c:	8a 83       	std	Y+2, r24	; 0x02
    209e:	7d 83       	std	Y+5, r23	; 0x05
    20a0:	6c 83       	std	Y+4, r22	; 0x04
    20a2:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    20a4:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    20a6:	8e 81       	ldd	r24, Y+6	; 0x06
    20a8:	88 23       	and	r24, r24
    20aa:	59 f4       	brne	.+22     	; 0x20c2 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    20ac:	8a 81       	ldd	r24, Y+2	; 0x02
    20ae:	9b 81       	ldd	r25, Y+3	; 0x03
    20b0:	2c 81       	ldd	r18, Y+4	; 0x04
    20b2:	3d 81       	ldd	r19, Y+5	; 0x05
    20b4:	82 23       	and	r24, r18
    20b6:	93 23       	and	r25, r19
    20b8:	00 97       	sbiw	r24, 0x00	; 0
    20ba:	81 f0       	breq	.+32     	; 0x20dc <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    20bc:	81 e0       	ldi	r24, 0x01	; 1
    20be:	89 83       	std	Y+1, r24	; 0x01
    20c0:	0d c0       	rjmp	.+26     	; 0x20dc <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    20c2:	2a 81       	ldd	r18, Y+2	; 0x02
    20c4:	3b 81       	ldd	r19, Y+3	; 0x03
    20c6:	8c 81       	ldd	r24, Y+4	; 0x04
    20c8:	9d 81       	ldd	r25, Y+5	; 0x05
    20ca:	28 23       	and	r18, r24
    20cc:	39 23       	and	r19, r25
    20ce:	8c 81       	ldd	r24, Y+4	; 0x04
    20d0:	9d 81       	ldd	r25, Y+5	; 0x05
    20d2:	28 17       	cp	r18, r24
    20d4:	39 07       	cpc	r19, r25
    20d6:	11 f4       	brne	.+4      	; 0x20dc <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    20d8:	81 e0       	ldi	r24, 0x01	; 1
    20da:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    20dc:	89 81       	ldd	r24, Y+1	; 0x01
}
    20de:	26 96       	adiw	r28, 0x06	; 6
    20e0:	0f b6       	in	r0, 0x3f	; 63
    20e2:	f8 94       	cli
    20e4:	de bf       	out	0x3e, r29	; 62
    20e6:	0f be       	out	0x3f, r0	; 63
    20e8:	cd bf       	out	0x3d, r28	; 61
    20ea:	cf 91       	pop	r28
    20ec:	df 91       	pop	r29
    20ee:	08 95       	ret

000020f0 <uxEventGroupGetNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    UBaseType_t uxEventGroupGetNumber( void * xEventGroup )
    {
    20f0:	df 93       	push	r29
    20f2:	cf 93       	push	r28
    20f4:	00 d0       	rcall	.+0      	; 0x20f6 <uxEventGroupGetNumber+0x6>
    20f6:	00 d0       	rcall	.+0      	; 0x20f8 <uxEventGroupGetNumber+0x8>
    20f8:	0f 92       	push	r0
    20fa:	cd b7       	in	r28, 0x3d	; 61
    20fc:	de b7       	in	r29, 0x3e	; 62
    20fe:	9d 83       	std	Y+5, r25	; 0x05
    2100:	8c 83       	std	Y+4, r24	; 0x04
        UBaseType_t xReturn;
        EventGroup_t const * pxEventBits = ( EventGroup_t * ) xEventGroup; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
    2102:	8c 81       	ldd	r24, Y+4	; 0x04
    2104:	9d 81       	ldd	r25, Y+5	; 0x05
    2106:	9a 83       	std	Y+2, r25	; 0x02
    2108:	89 83       	std	Y+1, r24	; 0x01

        if( xEventGroup == NULL )
    210a:	8c 81       	ldd	r24, Y+4	; 0x04
    210c:	9d 81       	ldd	r25, Y+5	; 0x05
    210e:	00 97       	sbiw	r24, 0x00	; 0
    2110:	11 f4       	brne	.+4      	; 0x2116 <uxEventGroupGetNumber+0x26>
        {
            xReturn = 0;
    2112:	1b 82       	std	Y+3, r1	; 0x03
    2114:	04 c0       	rjmp	.+8      	; 0x211e <uxEventGroupGetNumber+0x2e>
        }
        else
        {
            xReturn = pxEventBits->uxEventGroupNumber;
    2116:	e9 81       	ldd	r30, Y+1	; 0x01
    2118:	fa 81       	ldd	r31, Y+2	; 0x02
    211a:	83 85       	ldd	r24, Z+11	; 0x0b
    211c:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    211e:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    2120:	0f 90       	pop	r0
    2122:	0f 90       	pop	r0
    2124:	0f 90       	pop	r0
    2126:	0f 90       	pop	r0
    2128:	0f 90       	pop	r0
    212a:	cf 91       	pop	r28
    212c:	df 91       	pop	r29
    212e:	08 95       	ret

00002130 <vEventGroupSetNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

    void vEventGroupSetNumber( void * xEventGroup,
                               UBaseType_t uxEventGroupNumber )
    {
    2130:	df 93       	push	r29
    2132:	cf 93       	push	r28
    2134:	00 d0       	rcall	.+0      	; 0x2136 <vEventGroupSetNumber+0x6>
    2136:	0f 92       	push	r0
    2138:	cd b7       	in	r28, 0x3d	; 61
    213a:	de b7       	in	r29, 0x3e	; 62
    213c:	9a 83       	std	Y+2, r25	; 0x02
    213e:	89 83       	std	Y+1, r24	; 0x01
    2140:	6b 83       	std	Y+3, r22	; 0x03
        ( ( EventGroup_t * ) xEventGroup )->uxEventGroupNumber = uxEventGroupNumber; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
    2142:	e9 81       	ldd	r30, Y+1	; 0x01
    2144:	fa 81       	ldd	r31, Y+2	; 0x02
    2146:	8b 81       	ldd	r24, Y+3	; 0x03
    2148:	83 87       	std	Z+11, r24	; 0x0b
    }
    214a:	0f 90       	pop	r0
    214c:	0f 90       	pop	r0
    214e:	0f 90       	pop	r0
    2150:	cf 91       	pop	r28
    2152:	df 91       	pop	r29
    2154:	08 95       	ret

00002156 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2156:	df 93       	push	r29
    2158:	cf 93       	push	r28
    215a:	00 d0       	rcall	.+0      	; 0x215c <vListInitialise+0x6>
    215c:	cd b7       	in	r28, 0x3d	; 61
    215e:	de b7       	in	r29, 0x3e	; 62
    2160:	9a 83       	std	Y+2, r25	; 0x02
    2162:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2164:	89 81       	ldd	r24, Y+1	; 0x01
    2166:	9a 81       	ldd	r25, Y+2	; 0x02
    2168:	03 96       	adiw	r24, 0x03	; 3
    216a:	e9 81       	ldd	r30, Y+1	; 0x01
    216c:	fa 81       	ldd	r31, Y+2	; 0x02
    216e:	92 83       	std	Z+2, r25	; 0x02
    2170:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2172:	e9 81       	ldd	r30, Y+1	; 0x01
    2174:	fa 81       	ldd	r31, Y+2	; 0x02
    2176:	8f ef       	ldi	r24, 0xFF	; 255
    2178:	9f ef       	ldi	r25, 0xFF	; 255
    217a:	94 83       	std	Z+4, r25	; 0x04
    217c:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    217e:	89 81       	ldd	r24, Y+1	; 0x01
    2180:	9a 81       	ldd	r25, Y+2	; 0x02
    2182:	03 96       	adiw	r24, 0x03	; 3
    2184:	e9 81       	ldd	r30, Y+1	; 0x01
    2186:	fa 81       	ldd	r31, Y+2	; 0x02
    2188:	96 83       	std	Z+6, r25	; 0x06
    218a:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    218c:	89 81       	ldd	r24, Y+1	; 0x01
    218e:	9a 81       	ldd	r25, Y+2	; 0x02
    2190:	03 96       	adiw	r24, 0x03	; 3
    2192:	e9 81       	ldd	r30, Y+1	; 0x01
    2194:	fa 81       	ldd	r31, Y+2	; 0x02
    2196:	90 87       	std	Z+8, r25	; 0x08
    2198:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    219a:	e9 81       	ldd	r30, Y+1	; 0x01
    219c:	fa 81       	ldd	r31, Y+2	; 0x02
    219e:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    21a0:	0f 90       	pop	r0
    21a2:	0f 90       	pop	r0
    21a4:	cf 91       	pop	r28
    21a6:	df 91       	pop	r29
    21a8:	08 95       	ret

000021aa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    21aa:	df 93       	push	r29
    21ac:	cf 93       	push	r28
    21ae:	00 d0       	rcall	.+0      	; 0x21b0 <vListInitialiseItem+0x6>
    21b0:	cd b7       	in	r28, 0x3d	; 61
    21b2:	de b7       	in	r29, 0x3e	; 62
    21b4:	9a 83       	std	Y+2, r25	; 0x02
    21b6:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    21b8:	e9 81       	ldd	r30, Y+1	; 0x01
    21ba:	fa 81       	ldd	r31, Y+2	; 0x02
    21bc:	11 86       	std	Z+9, r1	; 0x09
    21be:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    21c0:	0f 90       	pop	r0
    21c2:	0f 90       	pop	r0
    21c4:	cf 91       	pop	r28
    21c6:	df 91       	pop	r29
    21c8:	08 95       	ret

000021ca <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    21ca:	df 93       	push	r29
    21cc:	cf 93       	push	r28
    21ce:	00 d0       	rcall	.+0      	; 0x21d0 <vListInsertEnd+0x6>
    21d0:	00 d0       	rcall	.+0      	; 0x21d2 <vListInsertEnd+0x8>
    21d2:	00 d0       	rcall	.+0      	; 0x21d4 <vListInsertEnd+0xa>
    21d4:	cd b7       	in	r28, 0x3d	; 61
    21d6:	de b7       	in	r29, 0x3e	; 62
    21d8:	9c 83       	std	Y+4, r25	; 0x04
    21da:	8b 83       	std	Y+3, r24	; 0x03
    21dc:	7e 83       	std	Y+6, r23	; 0x06
    21de:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    21e0:	eb 81       	ldd	r30, Y+3	; 0x03
    21e2:	fc 81       	ldd	r31, Y+4	; 0x04
    21e4:	81 81       	ldd	r24, Z+1	; 0x01
    21e6:	92 81       	ldd	r25, Z+2	; 0x02
    21e8:	9a 83       	std	Y+2, r25	; 0x02
    21ea:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    21ec:	ed 81       	ldd	r30, Y+5	; 0x05
    21ee:	fe 81       	ldd	r31, Y+6	; 0x06
    21f0:	89 81       	ldd	r24, Y+1	; 0x01
    21f2:	9a 81       	ldd	r25, Y+2	; 0x02
    21f4:	93 83       	std	Z+3, r25	; 0x03
    21f6:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    21f8:	e9 81       	ldd	r30, Y+1	; 0x01
    21fa:	fa 81       	ldd	r31, Y+2	; 0x02
    21fc:	84 81       	ldd	r24, Z+4	; 0x04
    21fe:	95 81       	ldd	r25, Z+5	; 0x05
    2200:	ed 81       	ldd	r30, Y+5	; 0x05
    2202:	fe 81       	ldd	r31, Y+6	; 0x06
    2204:	95 83       	std	Z+5, r25	; 0x05
    2206:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    2208:	e9 81       	ldd	r30, Y+1	; 0x01
    220a:	fa 81       	ldd	r31, Y+2	; 0x02
    220c:	04 80       	ldd	r0, Z+4	; 0x04
    220e:	f5 81       	ldd	r31, Z+5	; 0x05
    2210:	e0 2d       	mov	r30, r0
    2212:	8d 81       	ldd	r24, Y+5	; 0x05
    2214:	9e 81       	ldd	r25, Y+6	; 0x06
    2216:	93 83       	std	Z+3, r25	; 0x03
    2218:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    221a:	e9 81       	ldd	r30, Y+1	; 0x01
    221c:	fa 81       	ldd	r31, Y+2	; 0x02
    221e:	8d 81       	ldd	r24, Y+5	; 0x05
    2220:	9e 81       	ldd	r25, Y+6	; 0x06
    2222:	95 83       	std	Z+5, r25	; 0x05
    2224:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    2226:	ed 81       	ldd	r30, Y+5	; 0x05
    2228:	fe 81       	ldd	r31, Y+6	; 0x06
    222a:	8b 81       	ldd	r24, Y+3	; 0x03
    222c:	9c 81       	ldd	r25, Y+4	; 0x04
    222e:	91 87       	std	Z+9, r25	; 0x09
    2230:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    2232:	eb 81       	ldd	r30, Y+3	; 0x03
    2234:	fc 81       	ldd	r31, Y+4	; 0x04
    2236:	80 81       	ld	r24, Z
    2238:	8f 5f       	subi	r24, 0xFF	; 255
    223a:	eb 81       	ldd	r30, Y+3	; 0x03
    223c:	fc 81       	ldd	r31, Y+4	; 0x04
    223e:	80 83       	st	Z, r24
}
    2240:	26 96       	adiw	r28, 0x06	; 6
    2242:	0f b6       	in	r0, 0x3f	; 63
    2244:	f8 94       	cli
    2246:	de bf       	out	0x3e, r29	; 62
    2248:	0f be       	out	0x3f, r0	; 63
    224a:	cd bf       	out	0x3d, r28	; 61
    224c:	cf 91       	pop	r28
    224e:	df 91       	pop	r29
    2250:	08 95       	ret

00002252 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    2252:	df 93       	push	r29
    2254:	cf 93       	push	r28
    2256:	cd b7       	in	r28, 0x3d	; 61
    2258:	de b7       	in	r29, 0x3e	; 62
    225a:	28 97       	sbiw	r28, 0x08	; 8
    225c:	0f b6       	in	r0, 0x3f	; 63
    225e:	f8 94       	cli
    2260:	de bf       	out	0x3e, r29	; 62
    2262:	0f be       	out	0x3f, r0	; 63
    2264:	cd bf       	out	0x3d, r28	; 61
    2266:	9e 83       	std	Y+6, r25	; 0x06
    2268:	8d 83       	std	Y+5, r24	; 0x05
    226a:	78 87       	std	Y+8, r23	; 0x08
    226c:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    226e:	ef 81       	ldd	r30, Y+7	; 0x07
    2270:	f8 85       	ldd	r31, Y+8	; 0x08
    2272:	80 81       	ld	r24, Z
    2274:	91 81       	ldd	r25, Z+1	; 0x01
    2276:	9a 83       	std	Y+2, r25	; 0x02
    2278:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    227a:	89 81       	ldd	r24, Y+1	; 0x01
    227c:	9a 81       	ldd	r25, Y+2	; 0x02
    227e:	2f ef       	ldi	r18, 0xFF	; 255
    2280:	8f 3f       	cpi	r24, 0xFF	; 255
    2282:	92 07       	cpc	r25, r18
    2284:	39 f4       	brne	.+14     	; 0x2294 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    2286:	ed 81       	ldd	r30, Y+5	; 0x05
    2288:	fe 81       	ldd	r31, Y+6	; 0x06
    228a:	87 81       	ldd	r24, Z+7	; 0x07
    228c:	90 85       	ldd	r25, Z+8	; 0x08
    228e:	9c 83       	std	Y+4, r25	; 0x04
    2290:	8b 83       	std	Y+3, r24	; 0x03
    2292:	18 c0       	rjmp	.+48     	; 0x22c4 <vListInsert+0x72>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2294:	8d 81       	ldd	r24, Y+5	; 0x05
    2296:	9e 81       	ldd	r25, Y+6	; 0x06
    2298:	03 96       	adiw	r24, 0x03	; 3
    229a:	9c 83       	std	Y+4, r25	; 0x04
    229c:	8b 83       	std	Y+3, r24	; 0x03
    229e:	06 c0       	rjmp	.+12     	; 0x22ac <vListInsert+0x5a>
    22a0:	eb 81       	ldd	r30, Y+3	; 0x03
    22a2:	fc 81       	ldd	r31, Y+4	; 0x04
    22a4:	82 81       	ldd	r24, Z+2	; 0x02
    22a6:	93 81       	ldd	r25, Z+3	; 0x03
    22a8:	9c 83       	std	Y+4, r25	; 0x04
    22aa:	8b 83       	std	Y+3, r24	; 0x03
    22ac:	eb 81       	ldd	r30, Y+3	; 0x03
    22ae:	fc 81       	ldd	r31, Y+4	; 0x04
    22b0:	02 80       	ldd	r0, Z+2	; 0x02
    22b2:	f3 81       	ldd	r31, Z+3	; 0x03
    22b4:	e0 2d       	mov	r30, r0
    22b6:	20 81       	ld	r18, Z
    22b8:	31 81       	ldd	r19, Z+1	; 0x01
    22ba:	89 81       	ldd	r24, Y+1	; 0x01
    22bc:	9a 81       	ldd	r25, Y+2	; 0x02
    22be:	82 17       	cp	r24, r18
    22c0:	93 07       	cpc	r25, r19
    22c2:	70 f7       	brcc	.-36     	; 0x22a0 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    22c4:	eb 81       	ldd	r30, Y+3	; 0x03
    22c6:	fc 81       	ldd	r31, Y+4	; 0x04
    22c8:	82 81       	ldd	r24, Z+2	; 0x02
    22ca:	93 81       	ldd	r25, Z+3	; 0x03
    22cc:	ef 81       	ldd	r30, Y+7	; 0x07
    22ce:	f8 85       	ldd	r31, Y+8	; 0x08
    22d0:	93 83       	std	Z+3, r25	; 0x03
    22d2:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    22d4:	ef 81       	ldd	r30, Y+7	; 0x07
    22d6:	f8 85       	ldd	r31, Y+8	; 0x08
    22d8:	02 80       	ldd	r0, Z+2	; 0x02
    22da:	f3 81       	ldd	r31, Z+3	; 0x03
    22dc:	e0 2d       	mov	r30, r0
    22de:	8f 81       	ldd	r24, Y+7	; 0x07
    22e0:	98 85       	ldd	r25, Y+8	; 0x08
    22e2:	95 83       	std	Z+5, r25	; 0x05
    22e4:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    22e6:	ef 81       	ldd	r30, Y+7	; 0x07
    22e8:	f8 85       	ldd	r31, Y+8	; 0x08
    22ea:	8b 81       	ldd	r24, Y+3	; 0x03
    22ec:	9c 81       	ldd	r25, Y+4	; 0x04
    22ee:	95 83       	std	Z+5, r25	; 0x05
    22f0:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    22f2:	eb 81       	ldd	r30, Y+3	; 0x03
    22f4:	fc 81       	ldd	r31, Y+4	; 0x04
    22f6:	8f 81       	ldd	r24, Y+7	; 0x07
    22f8:	98 85       	ldd	r25, Y+8	; 0x08
    22fa:	93 83       	std	Z+3, r25	; 0x03
    22fc:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    22fe:	ef 81       	ldd	r30, Y+7	; 0x07
    2300:	f8 85       	ldd	r31, Y+8	; 0x08
    2302:	8d 81       	ldd	r24, Y+5	; 0x05
    2304:	9e 81       	ldd	r25, Y+6	; 0x06
    2306:	91 87       	std	Z+9, r25	; 0x09
    2308:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    230a:	ed 81       	ldd	r30, Y+5	; 0x05
    230c:	fe 81       	ldd	r31, Y+6	; 0x06
    230e:	80 81       	ld	r24, Z
    2310:	8f 5f       	subi	r24, 0xFF	; 255
    2312:	ed 81       	ldd	r30, Y+5	; 0x05
    2314:	fe 81       	ldd	r31, Y+6	; 0x06
    2316:	80 83       	st	Z, r24
}
    2318:	28 96       	adiw	r28, 0x08	; 8
    231a:	0f b6       	in	r0, 0x3f	; 63
    231c:	f8 94       	cli
    231e:	de bf       	out	0x3e, r29	; 62
    2320:	0f be       	out	0x3f, r0	; 63
    2322:	cd bf       	out	0x3d, r28	; 61
    2324:	cf 91       	pop	r28
    2326:	df 91       	pop	r29
    2328:	08 95       	ret

0000232a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    232a:	df 93       	push	r29
    232c:	cf 93       	push	r28
    232e:	00 d0       	rcall	.+0      	; 0x2330 <uxListRemove+0x6>
    2330:	00 d0       	rcall	.+0      	; 0x2332 <uxListRemove+0x8>
    2332:	cd b7       	in	r28, 0x3d	; 61
    2334:	de b7       	in	r29, 0x3e	; 62
    2336:	9c 83       	std	Y+4, r25	; 0x04
    2338:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    233a:	eb 81       	ldd	r30, Y+3	; 0x03
    233c:	fc 81       	ldd	r31, Y+4	; 0x04
    233e:	80 85       	ldd	r24, Z+8	; 0x08
    2340:	91 85       	ldd	r25, Z+9	; 0x09
    2342:	9a 83       	std	Y+2, r25	; 0x02
    2344:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2346:	eb 81       	ldd	r30, Y+3	; 0x03
    2348:	fc 81       	ldd	r31, Y+4	; 0x04
    234a:	a2 81       	ldd	r26, Z+2	; 0x02
    234c:	b3 81       	ldd	r27, Z+3	; 0x03
    234e:	eb 81       	ldd	r30, Y+3	; 0x03
    2350:	fc 81       	ldd	r31, Y+4	; 0x04
    2352:	84 81       	ldd	r24, Z+4	; 0x04
    2354:	95 81       	ldd	r25, Z+5	; 0x05
    2356:	15 96       	adiw	r26, 0x05	; 5
    2358:	9c 93       	st	X, r25
    235a:	8e 93       	st	-X, r24
    235c:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    235e:	eb 81       	ldd	r30, Y+3	; 0x03
    2360:	fc 81       	ldd	r31, Y+4	; 0x04
    2362:	a4 81       	ldd	r26, Z+4	; 0x04
    2364:	b5 81       	ldd	r27, Z+5	; 0x05
    2366:	eb 81       	ldd	r30, Y+3	; 0x03
    2368:	fc 81       	ldd	r31, Y+4	; 0x04
    236a:	82 81       	ldd	r24, Z+2	; 0x02
    236c:	93 81       	ldd	r25, Z+3	; 0x03
    236e:	13 96       	adiw	r26, 0x03	; 3
    2370:	9c 93       	st	X, r25
    2372:	8e 93       	st	-X, r24
    2374:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    2376:	e9 81       	ldd	r30, Y+1	; 0x01
    2378:	fa 81       	ldd	r31, Y+2	; 0x02
    237a:	21 81       	ldd	r18, Z+1	; 0x01
    237c:	32 81       	ldd	r19, Z+2	; 0x02
    237e:	8b 81       	ldd	r24, Y+3	; 0x03
    2380:	9c 81       	ldd	r25, Y+4	; 0x04
    2382:	28 17       	cp	r18, r24
    2384:	39 07       	cpc	r19, r25
    2386:	41 f4       	brne	.+16     	; 0x2398 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    2388:	eb 81       	ldd	r30, Y+3	; 0x03
    238a:	fc 81       	ldd	r31, Y+4	; 0x04
    238c:	84 81       	ldd	r24, Z+4	; 0x04
    238e:	95 81       	ldd	r25, Z+5	; 0x05
    2390:	e9 81       	ldd	r30, Y+1	; 0x01
    2392:	fa 81       	ldd	r31, Y+2	; 0x02
    2394:	92 83       	std	Z+2, r25	; 0x02
    2396:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2398:	eb 81       	ldd	r30, Y+3	; 0x03
    239a:	fc 81       	ldd	r31, Y+4	; 0x04
    239c:	11 86       	std	Z+9, r1	; 0x09
    239e:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    23a0:	e9 81       	ldd	r30, Y+1	; 0x01
    23a2:	fa 81       	ldd	r31, Y+2	; 0x02
    23a4:	80 81       	ld	r24, Z
    23a6:	81 50       	subi	r24, 0x01	; 1
    23a8:	e9 81       	ldd	r30, Y+1	; 0x01
    23aa:	fa 81       	ldd	r31, Y+2	; 0x02
    23ac:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    23ae:	e9 81       	ldd	r30, Y+1	; 0x01
    23b0:	fa 81       	ldd	r31, Y+2	; 0x02
    23b2:	80 81       	ld	r24, Z
}
    23b4:	0f 90       	pop	r0
    23b6:	0f 90       	pop	r0
    23b8:	0f 90       	pop	r0
    23ba:	0f 90       	pop	r0
    23bc:	cf 91       	pop	r28
    23be:	df 91       	pop	r29
    23c0:	08 95       	ret

000023c2 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    23c2:	df 93       	push	r29
    23c4:	cf 93       	push	r28
    23c6:	00 d0       	rcall	.+0      	; 0x23c8 <xQueueGenericReset+0x6>
    23c8:	00 d0       	rcall	.+0      	; 0x23ca <xQueueGenericReset+0x8>
    23ca:	0f 92       	push	r0
    23cc:	cd b7       	in	r28, 0x3d	; 61
    23ce:	de b7       	in	r29, 0x3e	; 62
    23d0:	9c 83       	std	Y+4, r25	; 0x04
    23d2:	8b 83       	std	Y+3, r24	; 0x03
    23d4:	6d 83       	std	Y+5, r22	; 0x05
    Queue_t * const pxQueue = xQueue;
    23d6:	8b 81       	ldd	r24, Y+3	; 0x03
    23d8:	9c 81       	ldd	r25, Y+4	; 0x04
    23da:	9a 83       	std	Y+2, r25	; 0x02
    23dc:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    23de:	0f b6       	in	r0, 0x3f	; 63
    23e0:	f8 94       	cli
    23e2:	0f 92       	push	r0
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    23e4:	e9 81       	ldd	r30, Y+1	; 0x01
    23e6:	fa 81       	ldd	r31, Y+2	; 0x02
    23e8:	40 81       	ld	r20, Z
    23ea:	51 81       	ldd	r21, Z+1	; 0x01
    23ec:	e9 81       	ldd	r30, Y+1	; 0x01
    23ee:	fa 81       	ldd	r31, Y+2	; 0x02
    23f0:	83 8d       	ldd	r24, Z+27	; 0x1b
    23f2:	28 2f       	mov	r18, r24
    23f4:	30 e0       	ldi	r19, 0x00	; 0
    23f6:	e9 81       	ldd	r30, Y+1	; 0x01
    23f8:	fa 81       	ldd	r31, Y+2	; 0x02
    23fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    23fc:	88 2f       	mov	r24, r24
    23fe:	90 e0       	ldi	r25, 0x00	; 0
    2400:	bc 01       	movw	r22, r24
    2402:	26 9f       	mul	r18, r22
    2404:	c0 01       	movw	r24, r0
    2406:	27 9f       	mul	r18, r23
    2408:	90 0d       	add	r25, r0
    240a:	36 9f       	mul	r19, r22
    240c:	90 0d       	add	r25, r0
    240e:	11 24       	eor	r1, r1
    2410:	84 0f       	add	r24, r20
    2412:	95 1f       	adc	r25, r21
    2414:	e9 81       	ldd	r30, Y+1	; 0x01
    2416:	fa 81       	ldd	r31, Y+2	; 0x02
    2418:	95 83       	std	Z+5, r25	; 0x05
    241a:	84 83       	std	Z+4, r24	; 0x04
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    241c:	e9 81       	ldd	r30, Y+1	; 0x01
    241e:	fa 81       	ldd	r31, Y+2	; 0x02
    2420:	12 8e       	std	Z+26, r1	; 0x1a
        pxQueue->pcWriteTo = pxQueue->pcHead;
    2422:	e9 81       	ldd	r30, Y+1	; 0x01
    2424:	fa 81       	ldd	r31, Y+2	; 0x02
    2426:	80 81       	ld	r24, Z
    2428:	91 81       	ldd	r25, Z+1	; 0x01
    242a:	e9 81       	ldd	r30, Y+1	; 0x01
    242c:	fa 81       	ldd	r31, Y+2	; 0x02
    242e:	93 83       	std	Z+3, r25	; 0x03
    2430:	82 83       	std	Z+2, r24	; 0x02
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2432:	e9 81       	ldd	r30, Y+1	; 0x01
    2434:	fa 81       	ldd	r31, Y+2	; 0x02
    2436:	40 81       	ld	r20, Z
    2438:	51 81       	ldd	r21, Z+1	; 0x01
    243a:	e9 81       	ldd	r30, Y+1	; 0x01
    243c:	fa 81       	ldd	r31, Y+2	; 0x02
    243e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2440:	88 2f       	mov	r24, r24
    2442:	90 e0       	ldi	r25, 0x00	; 0
    2444:	9c 01       	movw	r18, r24
    2446:	21 50       	subi	r18, 0x01	; 1
    2448:	30 40       	sbci	r19, 0x00	; 0
    244a:	e9 81       	ldd	r30, Y+1	; 0x01
    244c:	fa 81       	ldd	r31, Y+2	; 0x02
    244e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2450:	88 2f       	mov	r24, r24
    2452:	90 e0       	ldi	r25, 0x00	; 0
    2454:	bc 01       	movw	r22, r24
    2456:	26 9f       	mul	r18, r22
    2458:	c0 01       	movw	r24, r0
    245a:	27 9f       	mul	r18, r23
    245c:	90 0d       	add	r25, r0
    245e:	36 9f       	mul	r19, r22
    2460:	90 0d       	add	r25, r0
    2462:	11 24       	eor	r1, r1
    2464:	84 0f       	add	r24, r20
    2466:	95 1f       	adc	r25, r21
    2468:	e9 81       	ldd	r30, Y+1	; 0x01
    246a:	fa 81       	ldd	r31, Y+2	; 0x02
    246c:	97 83       	std	Z+7, r25	; 0x07
    246e:	86 83       	std	Z+6, r24	; 0x06
        pxQueue->cRxLock = queueUNLOCKED;
    2470:	e9 81       	ldd	r30, Y+1	; 0x01
    2472:	fa 81       	ldd	r31, Y+2	; 0x02
    2474:	8f ef       	ldi	r24, 0xFF	; 255
    2476:	85 8f       	std	Z+29, r24	; 0x1d
        pxQueue->cTxLock = queueUNLOCKED;
    2478:	e9 81       	ldd	r30, Y+1	; 0x01
    247a:	fa 81       	ldd	r31, Y+2	; 0x02
    247c:	8f ef       	ldi	r24, 0xFF	; 255
    247e:	86 8f       	std	Z+30, r24	; 0x1e

        if( xNewQueue == pdFALSE )
    2480:	8d 81       	ldd	r24, Y+5	; 0x05
    2482:	88 23       	and	r24, r24
    2484:	79 f4       	brne	.+30     	; 0x24a4 <xQueueGenericReset+0xe2>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2486:	e9 81       	ldd	r30, Y+1	; 0x01
    2488:	fa 81       	ldd	r31, Y+2	; 0x02
    248a:	80 85       	ldd	r24, Z+8	; 0x08
    248c:	88 23       	and	r24, r24
    248e:	a1 f0       	breq	.+40     	; 0x24b8 <xQueueGenericReset+0xf6>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2490:	89 81       	ldd	r24, Y+1	; 0x01
    2492:	9a 81       	ldd	r25, Y+2	; 0x02
    2494:	08 96       	adiw	r24, 0x08	; 8
    2496:	0e 94 dd 20 	call	0x41ba	; 0x41ba <xTaskRemoveFromEventList>
    249a:	88 23       	and	r24, r24
    249c:	69 f0       	breq	.+26     	; 0x24b8 <xQueueGenericReset+0xf6>
                {
                    queueYIELD_IF_USING_PREEMPTION();
    249e:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
    24a2:	0a c0       	rjmp	.+20     	; 0x24b8 <xQueueGenericReset+0xf6>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    24a4:	89 81       	ldd	r24, Y+1	; 0x01
    24a6:	9a 81       	ldd	r25, Y+2	; 0x02
    24a8:	08 96       	adiw	r24, 0x08	; 8
    24aa:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    24ae:	89 81       	ldd	r24, Y+1	; 0x01
    24b0:	9a 81       	ldd	r25, Y+2	; 0x02
    24b2:	41 96       	adiw	r24, 0x11	; 17
    24b4:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
        }
    }
    taskEXIT_CRITICAL();
    24b8:	0f 90       	pop	r0
    24ba:	0f be       	out	0x3f, r0	; 63

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
    24bc:	81 e0       	ldi	r24, 0x01	; 1
}
    24be:	0f 90       	pop	r0
    24c0:	0f 90       	pop	r0
    24c2:	0f 90       	pop	r0
    24c4:	0f 90       	pop	r0
    24c6:	0f 90       	pop	r0
    24c8:	cf 91       	pop	r28
    24ca:	df 91       	pop	r29
    24cc:	08 95       	ret

000024ce <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    24ce:	0f 93       	push	r16
    24d0:	1f 93       	push	r17
    24d2:	df 93       	push	r29
    24d4:	cf 93       	push	r28
    24d6:	cd b7       	in	r28, 0x3d	; 61
    24d8:	de b7       	in	r29, 0x3e	; 62
    24da:	29 97       	sbiw	r28, 0x09	; 9
    24dc:	0f b6       	in	r0, 0x3f	; 63
    24de:	f8 94       	cli
    24e0:	de bf       	out	0x3e, r29	; 62
    24e2:	0f be       	out	0x3f, r0	; 63
    24e4:	cd bf       	out	0x3d, r28	; 61
    24e6:	8f 83       	std	Y+7, r24	; 0x07
    24e8:	68 87       	std	Y+8, r22	; 0x08
    24ea:	49 87       	std	Y+9, r20	; 0x09
        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

        /* Allocate enough space to hold the maximum number of items that
         * can be in the queue at any time.  It is valid for uxItemSize to be
         * zero in the case the queue is used as a semaphore. */
        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    24ec:	8f 81       	ldd	r24, Y+7	; 0x07
    24ee:	28 2f       	mov	r18, r24
    24f0:	30 e0       	ldi	r19, 0x00	; 0
    24f2:	88 85       	ldd	r24, Y+8	; 0x08
    24f4:	88 2f       	mov	r24, r24
    24f6:	90 e0       	ldi	r25, 0x00	; 0
    24f8:	ac 01       	movw	r20, r24
    24fa:	24 9f       	mul	r18, r20
    24fc:	c0 01       	movw	r24, r0
    24fe:	25 9f       	mul	r18, r21
    2500:	90 0d       	add	r25, r0
    2502:	34 9f       	mul	r19, r20
    2504:	90 0d       	add	r25, r0
    2506:	11 24       	eor	r1, r1
    2508:	9c 83       	std	Y+4, r25	; 0x04
    250a:	8b 83       	std	Y+3, r24	; 0x03
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    250c:	8b 81       	ldd	r24, Y+3	; 0x03
    250e:	9c 81       	ldd	r25, Y+4	; 0x04
    2510:	81 96       	adiw	r24, 0x21	; 33
    2512:	0e 94 17 07 	call	0xe2e	; 0xe2e <pvPortMalloc>
    2516:	9e 83       	std	Y+6, r25	; 0x06
    2518:	8d 83       	std	Y+5, r24	; 0x05

        if( pxNewQueue != NULL )
    251a:	8d 81       	ldd	r24, Y+5	; 0x05
    251c:	9e 81       	ldd	r25, Y+6	; 0x06
    251e:	00 97       	sbiw	r24, 0x00	; 0
    2520:	a1 f0       	breq	.+40     	; 0x254a <xQueueGenericCreate+0x7c>
        {
            /* Jump past the queue structure to find the location of the queue
             * storage area. */
            pucQueueStorage = ( uint8_t * ) pxNewQueue;
    2522:	8d 81       	ldd	r24, Y+5	; 0x05
    2524:	9e 81       	ldd	r25, Y+6	; 0x06
    2526:	9a 83       	std	Y+2, r25	; 0x02
    2528:	89 83       	std	Y+1, r24	; 0x01
            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    252a:	89 81       	ldd	r24, Y+1	; 0x01
    252c:	9a 81       	ldd	r25, Y+2	; 0x02
    252e:	81 96       	adiw	r24, 0x21	; 33
    2530:	9a 83       	std	Y+2, r25	; 0x02
    2532:	89 83       	std	Y+1, r24	; 0x01
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
            #endif /* configSUPPORT_STATIC_ALLOCATION */

            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    2534:	29 81       	ldd	r18, Y+1	; 0x01
    2536:	3a 81       	ldd	r19, Y+2	; 0x02
    2538:	ed 81       	ldd	r30, Y+5	; 0x05
    253a:	fe 81       	ldd	r31, Y+6	; 0x06
    253c:	8f 81       	ldd	r24, Y+7	; 0x07
    253e:	68 85       	ldd	r22, Y+8	; 0x08
    2540:	a9 01       	movw	r20, r18
    2542:	29 85       	ldd	r18, Y+9	; 0x09
    2544:	8f 01       	movw	r16, r30
    2546:	0e 94 b2 12 	call	0x2564	; 0x2564 <prvInitialiseNewQueue>
        {
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    254a:	8d 81       	ldd	r24, Y+5	; 0x05
    254c:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    254e:	29 96       	adiw	r28, 0x09	; 9
    2550:	0f b6       	in	r0, 0x3f	; 63
    2552:	f8 94       	cli
    2554:	de bf       	out	0x3e, r29	; 62
    2556:	0f be       	out	0x3f, r0	; 63
    2558:	cd bf       	out	0x3d, r28	; 61
    255a:	cf 91       	pop	r28
    255c:	df 91       	pop	r29
    255e:	1f 91       	pop	r17
    2560:	0f 91       	pop	r16
    2562:	08 95       	ret

00002564 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    2564:	0f 93       	push	r16
    2566:	1f 93       	push	r17
    2568:	df 93       	push	r29
    256a:	cf 93       	push	r28
    256c:	cd b7       	in	r28, 0x3d	; 61
    256e:	de b7       	in	r29, 0x3e	; 62
    2570:	27 97       	sbiw	r28, 0x07	; 7
    2572:	0f b6       	in	r0, 0x3f	; 63
    2574:	f8 94       	cli
    2576:	de bf       	out	0x3e, r29	; 62
    2578:	0f be       	out	0x3f, r0	; 63
    257a:	cd bf       	out	0x3d, r28	; 61
    257c:	89 83       	std	Y+1, r24	; 0x01
    257e:	6a 83       	std	Y+2, r22	; 0x02
    2580:	5c 83       	std	Y+4, r21	; 0x04
    2582:	4b 83       	std	Y+3, r20	; 0x03
    2584:	2d 83       	std	Y+5, r18	; 0x05
    2586:	1f 83       	std	Y+7, r17	; 0x07
    2588:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    258a:	8a 81       	ldd	r24, Y+2	; 0x02
    258c:	88 23       	and	r24, r24
    258e:	39 f4       	brne	.+14     	; 0x259e <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2590:	8e 81       	ldd	r24, Y+6	; 0x06
    2592:	9f 81       	ldd	r25, Y+7	; 0x07
    2594:	ee 81       	ldd	r30, Y+6	; 0x06
    2596:	ff 81       	ldd	r31, Y+7	; 0x07
    2598:	91 83       	std	Z+1, r25	; 0x01
    259a:	80 83       	st	Z, r24
    259c:	06 c0       	rjmp	.+12     	; 0x25aa <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    259e:	8b 81       	ldd	r24, Y+3	; 0x03
    25a0:	9c 81       	ldd	r25, Y+4	; 0x04
    25a2:	ee 81       	ldd	r30, Y+6	; 0x06
    25a4:	ff 81       	ldd	r31, Y+7	; 0x07
    25a6:	91 83       	std	Z+1, r25	; 0x01
    25a8:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    25aa:	ee 81       	ldd	r30, Y+6	; 0x06
    25ac:	ff 81       	ldd	r31, Y+7	; 0x07
    25ae:	89 81       	ldd	r24, Y+1	; 0x01
    25b0:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    25b2:	ee 81       	ldd	r30, Y+6	; 0x06
    25b4:	ff 81       	ldd	r31, Y+7	; 0x07
    25b6:	8a 81       	ldd	r24, Y+2	; 0x02
    25b8:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    25ba:	8e 81       	ldd	r24, Y+6	; 0x06
    25bc:	9f 81       	ldd	r25, Y+7	; 0x07
    25be:	61 e0       	ldi	r22, 0x01	; 1
    25c0:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <xQueueGenericReset>

    #if ( configUSE_TRACE_FACILITY == 1 )
        {
            pxNewQueue->ucQueueType = ucQueueType;
    25c4:	ee 81       	ldd	r30, Y+6	; 0x06
    25c6:	ff 81       	ldd	r31, Y+7	; 0x07
    25c8:	8d 81       	ldd	r24, Y+5	; 0x05
    25ca:	80 a3       	std	Z+32, r24	; 0x20
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    25cc:	27 96       	adiw	r28, 0x07	; 7
    25ce:	0f b6       	in	r0, 0x3f	; 63
    25d0:	f8 94       	cli
    25d2:	de bf       	out	0x3e, r29	; 62
    25d4:	0f be       	out	0x3f, r0	; 63
    25d6:	cd bf       	out	0x3d, r28	; 61
    25d8:	cf 91       	pop	r28
    25da:	df 91       	pop	r29
    25dc:	1f 91       	pop	r17
    25de:	0f 91       	pop	r16
    25e0:	08 95       	ret

000025e2 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    25e2:	df 93       	push	r29
    25e4:	cf 93       	push	r28
    25e6:	cd b7       	in	r28, 0x3d	; 61
    25e8:	de b7       	in	r29, 0x3e	; 62
    25ea:	2f 97       	sbiw	r28, 0x0f	; 15
    25ec:	0f b6       	in	r0, 0x3f	; 63
    25ee:	f8 94       	cli
    25f0:	de bf       	out	0x3e, r29	; 62
    25f2:	0f be       	out	0x3f, r0	; 63
    25f4:	cd bf       	out	0x3d, r28	; 61
    25f6:	99 87       	std	Y+9, r25	; 0x09
    25f8:	88 87       	std	Y+8, r24	; 0x08
    25fa:	7b 87       	std	Y+11, r23	; 0x0b
    25fc:	6a 87       	std	Y+10, r22	; 0x0a
    25fe:	5d 87       	std	Y+13, r21	; 0x0d
    2600:	4c 87       	std	Y+12, r20	; 0x0c
    2602:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2604:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2606:	88 85       	ldd	r24, Y+8	; 0x08
    2608:	99 85       	ldd	r25, Y+9	; 0x09
    260a:	9a 83       	std	Y+2, r25	; 0x02
    260c:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    260e:	0f b6       	in	r0, 0x3f	; 63
    2610:	f8 94       	cli
    2612:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2614:	e9 81       	ldd	r30, Y+1	; 0x01
    2616:	fa 81       	ldd	r31, Y+2	; 0x02
    2618:	92 8d       	ldd	r25, Z+26	; 0x1a
    261a:	e9 81       	ldd	r30, Y+1	; 0x01
    261c:	fa 81       	ldd	r31, Y+2	; 0x02
    261e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2620:	98 17       	cp	r25, r24
    2622:	18 f0       	brcs	.+6      	; 0x262a <xQueueGenericSend+0x48>
    2624:	8e 85       	ldd	r24, Y+14	; 0x0e
    2626:	82 30       	cpi	r24, 0x02	; 2
    2628:	11 f5       	brne	.+68     	; 0x266e <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    262a:	89 81       	ldd	r24, Y+1	; 0x01
    262c:	9a 81       	ldd	r25, Y+2	; 0x02
    262e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2630:	3b 85       	ldd	r19, Y+11	; 0x0b
    2632:	b9 01       	movw	r22, r18
    2634:	4e 85       	ldd	r20, Y+14	; 0x0e
    2636:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <prvCopyDataToQueue>
    263a:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    263c:	e9 81       	ldd	r30, Y+1	; 0x01
    263e:	fa 81       	ldd	r31, Y+2	; 0x02
    2640:	81 89       	ldd	r24, Z+17	; 0x11
    2642:	88 23       	and	r24, r24
    2644:	51 f0       	breq	.+20     	; 0x265a <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2646:	89 81       	ldd	r24, Y+1	; 0x01
    2648:	9a 81       	ldd	r25, Y+2	; 0x02
    264a:	41 96       	adiw	r24, 0x11	; 17
    264c:	0e 94 dd 20 	call	0x41ba	; 0x41ba <xTaskRemoveFromEventList>
    2650:	88 23       	and	r24, r24
    2652:	41 f0       	breq	.+16     	; 0x2664 <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    2654:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
    2658:	05 c0       	rjmp	.+10     	; 0x2664 <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    265a:	8b 81       	ldd	r24, Y+3	; 0x03
    265c:	88 23       	and	r24, r24
    265e:	11 f0       	breq	.+4      	; 0x2664 <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    2660:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    2664:	0f 90       	pop	r0
    2666:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2668:	81 e0       	ldi	r24, 0x01	; 1
    266a:	8f 87       	std	Y+15, r24	; 0x0f
    266c:	5c c0       	rjmp	.+184    	; 0x2726 <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    266e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2670:	9d 85       	ldd	r25, Y+13	; 0x0d
    2672:	00 97       	sbiw	r24, 0x00	; 0
    2674:	21 f4       	brne	.+8      	; 0x267e <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2676:	0f 90       	pop	r0
    2678:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    267a:	1f 86       	std	Y+15, r1	; 0x0f
    267c:	54 c0       	rjmp	.+168    	; 0x2726 <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    267e:	8c 81       	ldd	r24, Y+4	; 0x04
    2680:	88 23       	and	r24, r24
    2682:	31 f4       	brne	.+12     	; 0x2690 <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2684:	ce 01       	movw	r24, r28
    2686:	05 96       	adiw	r24, 0x05	; 5
    2688:	0e 94 c3 21 	call	0x4386	; 0x4386 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    268c:	81 e0       	ldi	r24, 0x01	; 1
    268e:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2690:	0f 90       	pop	r0
    2692:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2694:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2698:	0f b6       	in	r0, 0x3f	; 63
    269a:	f8 94       	cli
    269c:	0f 92       	push	r0
    269e:	e9 81       	ldd	r30, Y+1	; 0x01
    26a0:	fa 81       	ldd	r31, Y+2	; 0x02
    26a2:	85 8d       	ldd	r24, Z+29	; 0x1d
    26a4:	8f 3f       	cpi	r24, 0xFF	; 255
    26a6:	19 f4       	brne	.+6      	; 0x26ae <xQueueGenericSend+0xcc>
    26a8:	e9 81       	ldd	r30, Y+1	; 0x01
    26aa:	fa 81       	ldd	r31, Y+2	; 0x02
    26ac:	15 8e       	std	Z+29, r1	; 0x1d
    26ae:	e9 81       	ldd	r30, Y+1	; 0x01
    26b0:	fa 81       	ldd	r31, Y+2	; 0x02
    26b2:	86 8d       	ldd	r24, Z+30	; 0x1e
    26b4:	8f 3f       	cpi	r24, 0xFF	; 255
    26b6:	19 f4       	brne	.+6      	; 0x26be <xQueueGenericSend+0xdc>
    26b8:	e9 81       	ldd	r30, Y+1	; 0x01
    26ba:	fa 81       	ldd	r31, Y+2	; 0x02
    26bc:	16 8e       	std	Z+30, r1	; 0x1e
    26be:	0f 90       	pop	r0
    26c0:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    26c2:	ce 01       	movw	r24, r28
    26c4:	05 96       	adiw	r24, 0x05	; 5
    26c6:	9e 01       	movw	r18, r28
    26c8:	24 5f       	subi	r18, 0xF4	; 244
    26ca:	3f 4f       	sbci	r19, 0xFF	; 255
    26cc:	b9 01       	movw	r22, r18
    26ce:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <xTaskCheckForTimeOut>
    26d2:	88 23       	and	r24, r24
    26d4:	09 f5       	brne	.+66     	; 0x2718 <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    26d6:	89 81       	ldd	r24, Y+1	; 0x01
    26d8:	9a 81       	ldd	r25, Y+2	; 0x02
    26da:	0e 94 f4 18 	call	0x31e8	; 0x31e8 <prvIsQueueFull>
    26de:	88 23       	and	r24, r24
    26e0:	a1 f0       	breq	.+40     	; 0x270a <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    26e2:	89 81       	ldd	r24, Y+1	; 0x01
    26e4:	9a 81       	ldd	r25, Y+2	; 0x02
    26e6:	08 96       	adiw	r24, 0x08	; 8
    26e8:	2c 85       	ldd	r18, Y+12	; 0x0c
    26ea:	3d 85       	ldd	r19, Y+13	; 0x0d
    26ec:	b9 01       	movw	r22, r18
    26ee:	0e 94 8b 20 	call	0x4116	; 0x4116 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    26f2:	89 81       	ldd	r24, Y+1	; 0x01
    26f4:	9a 81       	ldd	r25, Y+2	; 0x02
    26f6:	0e 94 65 18 	call	0x30ca	; 0x30ca <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    26fa:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
    26fe:	88 23       	and	r24, r24
    2700:	09 f0       	breq	.+2      	; 0x2704 <xQueueGenericSend+0x122>
    2702:	85 cf       	rjmp	.-246    	; 0x260e <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    2704:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
    2708:	82 cf       	rjmp	.-252    	; 0x260e <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    270a:	89 81       	ldd	r24, Y+1	; 0x01
    270c:	9a 81       	ldd	r25, Y+2	; 0x02
    270e:	0e 94 65 18 	call	0x30ca	; 0x30ca <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2712:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
    2716:	7b cf       	rjmp	.-266    	; 0x260e <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    2718:	89 81       	ldd	r24, Y+1	; 0x01
    271a:	9a 81       	ldd	r25, Y+2	; 0x02
    271c:	0e 94 65 18 	call	0x30ca	; 0x30ca <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2720:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    2724:	1f 86       	std	Y+15, r1	; 0x0f
    2726:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    2728:	2f 96       	adiw	r28, 0x0f	; 15
    272a:	0f b6       	in	r0, 0x3f	; 63
    272c:	f8 94       	cli
    272e:	de bf       	out	0x3e, r29	; 62
    2730:	0f be       	out	0x3f, r0	; 63
    2732:	cd bf       	out	0x3d, r28	; 61
    2734:	cf 91       	pop	r28
    2736:	df 91       	pop	r29
    2738:	08 95       	ret

0000273a <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    273a:	df 93       	push	r29
    273c:	cf 93       	push	r28
    273e:	cd b7       	in	r28, 0x3d	; 61
    2740:	de b7       	in	r29, 0x3e	; 62
    2742:	2d 97       	sbiw	r28, 0x0d	; 13
    2744:	0f b6       	in	r0, 0x3f	; 63
    2746:	f8 94       	cli
    2748:	de bf       	out	0x3e, r29	; 62
    274a:	0f be       	out	0x3f, r0	; 63
    274c:	cd bf       	out	0x3d, r28	; 61
    274e:	98 87       	std	Y+8, r25	; 0x08
    2750:	8f 83       	std	Y+7, r24	; 0x07
    2752:	7a 87       	std	Y+10, r23	; 0x0a
    2754:	69 87       	std	Y+9, r22	; 0x09
    2756:	5c 87       	std	Y+12, r21	; 0x0c
    2758:	4b 87       	std	Y+11, r20	; 0x0b
    275a:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    275c:	8f 81       	ldd	r24, Y+7	; 0x07
    275e:	98 85       	ldd	r25, Y+8	; 0x08
    2760:	9c 83       	std	Y+4, r25	; 0x04
    2762:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2764:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2766:	eb 81       	ldd	r30, Y+3	; 0x03
    2768:	fc 81       	ldd	r31, Y+4	; 0x04
    276a:	92 8d       	ldd	r25, Z+26	; 0x1a
    276c:	eb 81       	ldd	r30, Y+3	; 0x03
    276e:	fc 81       	ldd	r31, Y+4	; 0x04
    2770:	83 8d       	ldd	r24, Z+27	; 0x1b
    2772:	98 17       	cp	r25, r24
    2774:	18 f0       	brcs	.+6      	; 0x277c <xQueueGenericSendFromISR+0x42>
    2776:	8d 85       	ldd	r24, Y+13	; 0x0d
    2778:	82 30       	cpi	r24, 0x02	; 2
    277a:	81 f5       	brne	.+96     	; 0x27dc <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    277c:	eb 81       	ldd	r30, Y+3	; 0x03
    277e:	fc 81       	ldd	r31, Y+4	; 0x04
    2780:	86 8d       	ldd	r24, Z+30	; 0x1e
    2782:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    2784:	eb 81       	ldd	r30, Y+3	; 0x03
    2786:	fc 81       	ldd	r31, Y+4	; 0x04
    2788:	82 8d       	ldd	r24, Z+26	; 0x1a
    278a:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    278c:	8b 81       	ldd	r24, Y+3	; 0x03
    278e:	9c 81       	ldd	r25, Y+4	; 0x04
    2790:	29 85       	ldd	r18, Y+9	; 0x09
    2792:	3a 85       	ldd	r19, Y+10	; 0x0a
    2794:	b9 01       	movw	r22, r18
    2796:	4d 85       	ldd	r20, Y+13	; 0x0d
    2798:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    279c:	8a 81       	ldd	r24, Y+2	; 0x02
    279e:	8f 3f       	cpi	r24, 0xFF	; 255
    27a0:	a9 f4       	brne	.+42     	; 0x27cc <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    27a2:	eb 81       	ldd	r30, Y+3	; 0x03
    27a4:	fc 81       	ldd	r31, Y+4	; 0x04
    27a6:	81 89       	ldd	r24, Z+17	; 0x11
    27a8:	88 23       	and	r24, r24
    27aa:	a9 f0       	breq	.+42     	; 0x27d6 <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    27ac:	8b 81       	ldd	r24, Y+3	; 0x03
    27ae:	9c 81       	ldd	r25, Y+4	; 0x04
    27b0:	41 96       	adiw	r24, 0x11	; 17
    27b2:	0e 94 dd 20 	call	0x41ba	; 0x41ba <xTaskRemoveFromEventList>
    27b6:	88 23       	and	r24, r24
    27b8:	71 f0       	breq	.+28     	; 0x27d6 <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    27ba:	8b 85       	ldd	r24, Y+11	; 0x0b
    27bc:	9c 85       	ldd	r25, Y+12	; 0x0c
    27be:	00 97       	sbiw	r24, 0x00	; 0
    27c0:	51 f0       	breq	.+20     	; 0x27d6 <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    27c2:	eb 85       	ldd	r30, Y+11	; 0x0b
    27c4:	fc 85       	ldd	r31, Y+12	; 0x0c
    27c6:	81 e0       	ldi	r24, 0x01	; 1
    27c8:	80 83       	st	Z, r24
    27ca:	05 c0       	rjmp	.+10     	; 0x27d6 <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    27cc:	8a 81       	ldd	r24, Y+2	; 0x02
    27ce:	8f 5f       	subi	r24, 0xFF	; 255
    27d0:	eb 81       	ldd	r30, Y+3	; 0x03
    27d2:	fc 81       	ldd	r31, Y+4	; 0x04
    27d4:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    27d6:	81 e0       	ldi	r24, 0x01	; 1
    27d8:	8e 83       	std	Y+6, r24	; 0x06
    27da:	01 c0       	rjmp	.+2      	; 0x27de <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    27dc:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    27de:	8e 81       	ldd	r24, Y+6	; 0x06
}
    27e0:	2d 96       	adiw	r28, 0x0d	; 13
    27e2:	0f b6       	in	r0, 0x3f	; 63
    27e4:	f8 94       	cli
    27e6:	de bf       	out	0x3e, r29	; 62
    27e8:	0f be       	out	0x3f, r0	; 63
    27ea:	cd bf       	out	0x3d, r28	; 61
    27ec:	cf 91       	pop	r28
    27ee:	df 91       	pop	r29
    27f0:	08 95       	ret

000027f2 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    27f2:	df 93       	push	r29
    27f4:	cf 93       	push	r28
    27f6:	cd b7       	in	r28, 0x3d	; 61
    27f8:	de b7       	in	r29, 0x3e	; 62
    27fa:	2a 97       	sbiw	r28, 0x0a	; 10
    27fc:	0f b6       	in	r0, 0x3f	; 63
    27fe:	f8 94       	cli
    2800:	de bf       	out	0x3e, r29	; 62
    2802:	0f be       	out	0x3f, r0	; 63
    2804:	cd bf       	out	0x3d, r28	; 61
    2806:	98 87       	std	Y+8, r25	; 0x08
    2808:	8f 83       	std	Y+7, r24	; 0x07
    280a:	7a 87       	std	Y+10, r23	; 0x0a
    280c:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    280e:	8f 81       	ldd	r24, Y+7	; 0x07
    2810:	98 85       	ldd	r25, Y+8	; 0x08
    2812:	9c 83       	std	Y+4, r25	; 0x04
    2814:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2816:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2818:	eb 81       	ldd	r30, Y+3	; 0x03
    281a:	fc 81       	ldd	r31, Y+4	; 0x04
    281c:	82 8d       	ldd	r24, Z+26	; 0x1a
    281e:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    2820:	eb 81       	ldd	r30, Y+3	; 0x03
    2822:	fc 81       	ldd	r31, Y+4	; 0x04
    2824:	93 8d       	ldd	r25, Z+27	; 0x1b
    2826:	8a 81       	ldd	r24, Y+2	; 0x02
    2828:	89 17       	cp	r24, r25
    282a:	48 f5       	brcc	.+82     	; 0x287e <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    282c:	eb 81       	ldd	r30, Y+3	; 0x03
    282e:	fc 81       	ldd	r31, Y+4	; 0x04
    2830:	86 8d       	ldd	r24, Z+30	; 0x1e
    2832:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2834:	8a 81       	ldd	r24, Y+2	; 0x02
    2836:	8f 5f       	subi	r24, 0xFF	; 255
    2838:	eb 81       	ldd	r30, Y+3	; 0x03
    283a:	fc 81       	ldd	r31, Y+4	; 0x04
    283c:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    283e:	89 81       	ldd	r24, Y+1	; 0x01
    2840:	8f 3f       	cpi	r24, 0xFF	; 255
    2842:	a9 f4       	brne	.+42     	; 0x286e <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2844:	eb 81       	ldd	r30, Y+3	; 0x03
    2846:	fc 81       	ldd	r31, Y+4	; 0x04
    2848:	81 89       	ldd	r24, Z+17	; 0x11
    284a:	88 23       	and	r24, r24
    284c:	a9 f0       	breq	.+42     	; 0x2878 <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    284e:	8b 81       	ldd	r24, Y+3	; 0x03
    2850:	9c 81       	ldd	r25, Y+4	; 0x04
    2852:	41 96       	adiw	r24, 0x11	; 17
    2854:	0e 94 dd 20 	call	0x41ba	; 0x41ba <xTaskRemoveFromEventList>
    2858:	88 23       	and	r24, r24
    285a:	71 f0       	breq	.+28     	; 0x2878 <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    285c:	89 85       	ldd	r24, Y+9	; 0x09
    285e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2860:	00 97       	sbiw	r24, 0x00	; 0
    2862:	51 f0       	breq	.+20     	; 0x2878 <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2864:	e9 85       	ldd	r30, Y+9	; 0x09
    2866:	fa 85       	ldd	r31, Y+10	; 0x0a
    2868:	81 e0       	ldi	r24, 0x01	; 1
    286a:	80 83       	st	Z, r24
    286c:	05 c0       	rjmp	.+10     	; 0x2878 <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    286e:	89 81       	ldd	r24, Y+1	; 0x01
    2870:	8f 5f       	subi	r24, 0xFF	; 255
    2872:	eb 81       	ldd	r30, Y+3	; 0x03
    2874:	fc 81       	ldd	r31, Y+4	; 0x04
    2876:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    2878:	81 e0       	ldi	r24, 0x01	; 1
    287a:	8e 83       	std	Y+6, r24	; 0x06
    287c:	01 c0       	rjmp	.+2      	; 0x2880 <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    287e:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2880:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2882:	2a 96       	adiw	r28, 0x0a	; 10
    2884:	0f b6       	in	r0, 0x3f	; 63
    2886:	f8 94       	cli
    2888:	de bf       	out	0x3e, r29	; 62
    288a:	0f be       	out	0x3f, r0	; 63
    288c:	cd bf       	out	0x3d, r28	; 61
    288e:	cf 91       	pop	r28
    2890:	df 91       	pop	r29
    2892:	08 95       	ret

00002894 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    2894:	df 93       	push	r29
    2896:	cf 93       	push	r28
    2898:	cd b7       	in	r28, 0x3d	; 61
    289a:	de b7       	in	r29, 0x3e	; 62
    289c:	2e 97       	sbiw	r28, 0x0e	; 14
    289e:	0f b6       	in	r0, 0x3f	; 63
    28a0:	f8 94       	cli
    28a2:	de bf       	out	0x3e, r29	; 62
    28a4:	0f be       	out	0x3f, r0	; 63
    28a6:	cd bf       	out	0x3d, r28	; 61
    28a8:	99 87       	std	Y+9, r25	; 0x09
    28aa:	88 87       	std	Y+8, r24	; 0x08
    28ac:	7b 87       	std	Y+11, r23	; 0x0b
    28ae:	6a 87       	std	Y+10, r22	; 0x0a
    28b0:	5d 87       	std	Y+13, r21	; 0x0d
    28b2:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    28b4:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    28b6:	88 85       	ldd	r24, Y+8	; 0x08
    28b8:	99 85       	ldd	r25, Y+9	; 0x09
    28ba:	9b 83       	std	Y+3, r25	; 0x03
    28bc:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    28be:	0f b6       	in	r0, 0x3f	; 63
    28c0:	f8 94       	cli
    28c2:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    28c4:	ea 81       	ldd	r30, Y+2	; 0x02
    28c6:	fb 81       	ldd	r31, Y+3	; 0x03
    28c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    28ca:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    28cc:	89 81       	ldd	r24, Y+1	; 0x01
    28ce:	88 23       	and	r24, r24
    28d0:	f9 f0       	breq	.+62     	; 0x2910 <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    28d2:	8a 81       	ldd	r24, Y+2	; 0x02
    28d4:	9b 81       	ldd	r25, Y+3	; 0x03
    28d6:	2a 85       	ldd	r18, Y+10	; 0x0a
    28d8:	3b 85       	ldd	r19, Y+11	; 0x0b
    28da:	b9 01       	movw	r22, r18
    28dc:	0e 94 1e 18 	call	0x303c	; 0x303c <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    28e0:	89 81       	ldd	r24, Y+1	; 0x01
    28e2:	81 50       	subi	r24, 0x01	; 1
    28e4:	ea 81       	ldd	r30, Y+2	; 0x02
    28e6:	fb 81       	ldd	r31, Y+3	; 0x03
    28e8:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    28ea:	ea 81       	ldd	r30, Y+2	; 0x02
    28ec:	fb 81       	ldd	r31, Y+3	; 0x03
    28ee:	80 85       	ldd	r24, Z+8	; 0x08
    28f0:	88 23       	and	r24, r24
    28f2:	49 f0       	breq	.+18     	; 0x2906 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    28f4:	8a 81       	ldd	r24, Y+2	; 0x02
    28f6:	9b 81       	ldd	r25, Y+3	; 0x03
    28f8:	08 96       	adiw	r24, 0x08	; 8
    28fa:	0e 94 dd 20 	call	0x41ba	; 0x41ba <xTaskRemoveFromEventList>
    28fe:	88 23       	and	r24, r24
    2900:	11 f0       	breq	.+4      	; 0x2906 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2902:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2906:	0f 90       	pop	r0
    2908:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    290a:	81 e0       	ldi	r24, 0x01	; 1
    290c:	8e 87       	std	Y+14, r24	; 0x0e
    290e:	63 c0       	rjmp	.+198    	; 0x29d6 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2910:	8c 85       	ldd	r24, Y+12	; 0x0c
    2912:	9d 85       	ldd	r25, Y+13	; 0x0d
    2914:	00 97       	sbiw	r24, 0x00	; 0
    2916:	21 f4       	brne	.+8      	; 0x2920 <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2918:	0f 90       	pop	r0
    291a:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    291c:	1e 86       	std	Y+14, r1	; 0x0e
    291e:	5b c0       	rjmp	.+182    	; 0x29d6 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    2920:	8c 81       	ldd	r24, Y+4	; 0x04
    2922:	88 23       	and	r24, r24
    2924:	31 f4       	brne	.+12     	; 0x2932 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2926:	ce 01       	movw	r24, r28
    2928:	05 96       	adiw	r24, 0x05	; 5
    292a:	0e 94 c3 21 	call	0x4386	; 0x4386 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    292e:	81 e0       	ldi	r24, 0x01	; 1
    2930:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2932:	0f 90       	pop	r0
    2934:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2936:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    293a:	0f b6       	in	r0, 0x3f	; 63
    293c:	f8 94       	cli
    293e:	0f 92       	push	r0
    2940:	ea 81       	ldd	r30, Y+2	; 0x02
    2942:	fb 81       	ldd	r31, Y+3	; 0x03
    2944:	85 8d       	ldd	r24, Z+29	; 0x1d
    2946:	8f 3f       	cpi	r24, 0xFF	; 255
    2948:	19 f4       	brne	.+6      	; 0x2950 <xQueueReceive+0xbc>
    294a:	ea 81       	ldd	r30, Y+2	; 0x02
    294c:	fb 81       	ldd	r31, Y+3	; 0x03
    294e:	15 8e       	std	Z+29, r1	; 0x1d
    2950:	ea 81       	ldd	r30, Y+2	; 0x02
    2952:	fb 81       	ldd	r31, Y+3	; 0x03
    2954:	86 8d       	ldd	r24, Z+30	; 0x1e
    2956:	8f 3f       	cpi	r24, 0xFF	; 255
    2958:	19 f4       	brne	.+6      	; 0x2960 <xQueueReceive+0xcc>
    295a:	ea 81       	ldd	r30, Y+2	; 0x02
    295c:	fb 81       	ldd	r31, Y+3	; 0x03
    295e:	16 8e       	std	Z+30, r1	; 0x1e
    2960:	0f 90       	pop	r0
    2962:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2964:	ce 01       	movw	r24, r28
    2966:	05 96       	adiw	r24, 0x05	; 5
    2968:	9e 01       	movw	r18, r28
    296a:	24 5f       	subi	r18, 0xF4	; 244
    296c:	3f 4f       	sbci	r19, 0xFF	; 255
    296e:	b9 01       	movw	r22, r18
    2970:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <xTaskCheckForTimeOut>
    2974:	88 23       	and	r24, r24
    2976:	09 f5       	brne	.+66     	; 0x29ba <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2978:	8a 81       	ldd	r24, Y+2	; 0x02
    297a:	9b 81       	ldd	r25, Y+3	; 0x03
    297c:	0e 94 b8 18 	call	0x3170	; 0x3170 <prvIsQueueEmpty>
    2980:	88 23       	and	r24, r24
    2982:	a1 f0       	breq	.+40     	; 0x29ac <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2984:	8a 81       	ldd	r24, Y+2	; 0x02
    2986:	9b 81       	ldd	r25, Y+3	; 0x03
    2988:	41 96       	adiw	r24, 0x11	; 17
    298a:	2c 85       	ldd	r18, Y+12	; 0x0c
    298c:	3d 85       	ldd	r19, Y+13	; 0x0d
    298e:	b9 01       	movw	r22, r18
    2990:	0e 94 8b 20 	call	0x4116	; 0x4116 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2994:	8a 81       	ldd	r24, Y+2	; 0x02
    2996:	9b 81       	ldd	r25, Y+3	; 0x03
    2998:	0e 94 65 18 	call	0x30ca	; 0x30ca <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    299c:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
    29a0:	88 23       	and	r24, r24
    29a2:	09 f0       	breq	.+2      	; 0x29a6 <xQueueReceive+0x112>
    29a4:	8c cf       	rjmp	.-232    	; 0x28be <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    29a6:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
    29aa:	89 cf       	rjmp	.-238    	; 0x28be <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    29ac:	8a 81       	ldd	r24, Y+2	; 0x02
    29ae:	9b 81       	ldd	r25, Y+3	; 0x03
    29b0:	0e 94 65 18 	call	0x30ca	; 0x30ca <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    29b4:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
    29b8:	82 cf       	rjmp	.-252    	; 0x28be <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    29ba:	8a 81       	ldd	r24, Y+2	; 0x02
    29bc:	9b 81       	ldd	r25, Y+3	; 0x03
    29be:	0e 94 65 18 	call	0x30ca	; 0x30ca <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    29c2:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    29c6:	8a 81       	ldd	r24, Y+2	; 0x02
    29c8:	9b 81       	ldd	r25, Y+3	; 0x03
    29ca:	0e 94 b8 18 	call	0x3170	; 0x3170 <prvIsQueueEmpty>
    29ce:	88 23       	and	r24, r24
    29d0:	09 f4       	brne	.+2      	; 0x29d4 <xQueueReceive+0x140>
    29d2:	75 cf       	rjmp	.-278    	; 0x28be <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    29d4:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    29d6:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    29d8:	2e 96       	adiw	r28, 0x0e	; 14
    29da:	0f b6       	in	r0, 0x3f	; 63
    29dc:	f8 94       	cli
    29de:	de bf       	out	0x3e, r29	; 62
    29e0:	0f be       	out	0x3f, r0	; 63
    29e2:	cd bf       	out	0x3d, r28	; 61
    29e4:	cf 91       	pop	r28
    29e6:	df 91       	pop	r29
    29e8:	08 95       	ret

000029ea <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    29ea:	df 93       	push	r29
    29ec:	cf 93       	push	r28
    29ee:	cd b7       	in	r28, 0x3d	; 61
    29f0:	de b7       	in	r29, 0x3e	; 62
    29f2:	2c 97       	sbiw	r28, 0x0c	; 12
    29f4:	0f b6       	in	r0, 0x3f	; 63
    29f6:	f8 94       	cli
    29f8:	de bf       	out	0x3e, r29	; 62
    29fa:	0f be       	out	0x3f, r0	; 63
    29fc:	cd bf       	out	0x3d, r28	; 61
    29fe:	99 87       	std	Y+9, r25	; 0x09
    2a00:	88 87       	std	Y+8, r24	; 0x08
    2a02:	7b 87       	std	Y+11, r23	; 0x0b
    2a04:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    2a06:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2a08:	88 85       	ldd	r24, Y+8	; 0x08
    2a0a:	99 85       	ldd	r25, Y+9	; 0x09
    2a0c:	9b 83       	std	Y+3, r25	; 0x03
    2a0e:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2a10:	0f b6       	in	r0, 0x3f	; 63
    2a12:	f8 94       	cli
    2a14:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2a16:	ea 81       	ldd	r30, Y+2	; 0x02
    2a18:	fb 81       	ldd	r31, Y+3	; 0x03
    2a1a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a1c:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2a1e:	89 81       	ldd	r24, Y+1	; 0x01
    2a20:	88 23       	and	r24, r24
    2a22:	c1 f0       	breq	.+48     	; 0x2a54 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2a24:	89 81       	ldd	r24, Y+1	; 0x01
    2a26:	81 50       	subi	r24, 0x01	; 1
    2a28:	ea 81       	ldd	r30, Y+2	; 0x02
    2a2a:	fb 81       	ldd	r31, Y+3	; 0x03
    2a2c:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a2e:	ea 81       	ldd	r30, Y+2	; 0x02
    2a30:	fb 81       	ldd	r31, Y+3	; 0x03
    2a32:	80 85       	ldd	r24, Z+8	; 0x08
    2a34:	88 23       	and	r24, r24
    2a36:	49 f0       	breq	.+18     	; 0x2a4a <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2a38:	8a 81       	ldd	r24, Y+2	; 0x02
    2a3a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a3c:	08 96       	adiw	r24, 0x08	; 8
    2a3e:	0e 94 dd 20 	call	0x41ba	; 0x41ba <xTaskRemoveFromEventList>
    2a42:	88 23       	and	r24, r24
    2a44:	11 f0       	breq	.+4      	; 0x2a4a <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2a46:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2a4a:	0f 90       	pop	r0
    2a4c:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2a4e:	81 e0       	ldi	r24, 0x01	; 1
    2a50:	8c 87       	std	Y+12, r24	; 0x0c
    2a52:	63 c0       	rjmp	.+198    	; 0x2b1a <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2a54:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a56:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a58:	00 97       	sbiw	r24, 0x00	; 0
    2a5a:	21 f4       	brne	.+8      	; 0x2a64 <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    2a5c:	0f 90       	pop	r0
    2a5e:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2a60:	1c 86       	std	Y+12, r1	; 0x0c
    2a62:	5b c0       	rjmp	.+182    	; 0x2b1a <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    2a64:	8c 81       	ldd	r24, Y+4	; 0x04
    2a66:	88 23       	and	r24, r24
    2a68:	31 f4       	brne	.+12     	; 0x2a76 <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2a6a:	ce 01       	movw	r24, r28
    2a6c:	05 96       	adiw	r24, 0x05	; 5
    2a6e:	0e 94 c3 21 	call	0x4386	; 0x4386 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2a72:	81 e0       	ldi	r24, 0x01	; 1
    2a74:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2a76:	0f 90       	pop	r0
    2a78:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2a7a:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2a7e:	0f b6       	in	r0, 0x3f	; 63
    2a80:	f8 94       	cli
    2a82:	0f 92       	push	r0
    2a84:	ea 81       	ldd	r30, Y+2	; 0x02
    2a86:	fb 81       	ldd	r31, Y+3	; 0x03
    2a88:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a8a:	8f 3f       	cpi	r24, 0xFF	; 255
    2a8c:	19 f4       	brne	.+6      	; 0x2a94 <xQueueSemaphoreTake+0xaa>
    2a8e:	ea 81       	ldd	r30, Y+2	; 0x02
    2a90:	fb 81       	ldd	r31, Y+3	; 0x03
    2a92:	15 8e       	std	Z+29, r1	; 0x1d
    2a94:	ea 81       	ldd	r30, Y+2	; 0x02
    2a96:	fb 81       	ldd	r31, Y+3	; 0x03
    2a98:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a9a:	8f 3f       	cpi	r24, 0xFF	; 255
    2a9c:	19 f4       	brne	.+6      	; 0x2aa4 <xQueueSemaphoreTake+0xba>
    2a9e:	ea 81       	ldd	r30, Y+2	; 0x02
    2aa0:	fb 81       	ldd	r31, Y+3	; 0x03
    2aa2:	16 8e       	std	Z+30, r1	; 0x1e
    2aa4:	0f 90       	pop	r0
    2aa6:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2aa8:	ce 01       	movw	r24, r28
    2aaa:	05 96       	adiw	r24, 0x05	; 5
    2aac:	9e 01       	movw	r18, r28
    2aae:	26 5f       	subi	r18, 0xF6	; 246
    2ab0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ab2:	b9 01       	movw	r22, r18
    2ab4:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <xTaskCheckForTimeOut>
    2ab8:	88 23       	and	r24, r24
    2aba:	09 f5       	brne	.+66     	; 0x2afe <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2abc:	8a 81       	ldd	r24, Y+2	; 0x02
    2abe:	9b 81       	ldd	r25, Y+3	; 0x03
    2ac0:	0e 94 b8 18 	call	0x3170	; 0x3170 <prvIsQueueEmpty>
    2ac4:	88 23       	and	r24, r24
    2ac6:	a1 f0       	breq	.+40     	; 0x2af0 <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2ac8:	8a 81       	ldd	r24, Y+2	; 0x02
    2aca:	9b 81       	ldd	r25, Y+3	; 0x03
    2acc:	41 96       	adiw	r24, 0x11	; 17
    2ace:	2a 85       	ldd	r18, Y+10	; 0x0a
    2ad0:	3b 85       	ldd	r19, Y+11	; 0x0b
    2ad2:	b9 01       	movw	r22, r18
    2ad4:	0e 94 8b 20 	call	0x4116	; 0x4116 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2ad8:	8a 81       	ldd	r24, Y+2	; 0x02
    2ada:	9b 81       	ldd	r25, Y+3	; 0x03
    2adc:	0e 94 65 18 	call	0x30ca	; 0x30ca <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2ae0:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
    2ae4:	88 23       	and	r24, r24
    2ae6:	09 f0       	breq	.+2      	; 0x2aea <xQueueSemaphoreTake+0x100>
    2ae8:	93 cf       	rjmp	.-218    	; 0x2a10 <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    2aea:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
    2aee:	90 cf       	rjmp	.-224    	; 0x2a10 <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    2af0:	8a 81       	ldd	r24, Y+2	; 0x02
    2af2:	9b 81       	ldd	r25, Y+3	; 0x03
    2af4:	0e 94 65 18 	call	0x30ca	; 0x30ca <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2af8:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
    2afc:	89 cf       	rjmp	.-238    	; 0x2a10 <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    2afe:	8a 81       	ldd	r24, Y+2	; 0x02
    2b00:	9b 81       	ldd	r25, Y+3	; 0x03
    2b02:	0e 94 65 18 	call	0x30ca	; 0x30ca <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2b06:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2b0a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b0c:	9b 81       	ldd	r25, Y+3	; 0x03
    2b0e:	0e 94 b8 18 	call	0x3170	; 0x3170 <prvIsQueueEmpty>
    2b12:	88 23       	and	r24, r24
    2b14:	09 f4       	brne	.+2      	; 0x2b18 <xQueueSemaphoreTake+0x12e>
    2b16:	7c cf       	rjmp	.-264    	; 0x2a10 <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2b18:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2b1a:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2b1c:	2c 96       	adiw	r28, 0x0c	; 12
    2b1e:	0f b6       	in	r0, 0x3f	; 63
    2b20:	f8 94       	cli
    2b22:	de bf       	out	0x3e, r29	; 62
    2b24:	0f be       	out	0x3f, r0	; 63
    2b26:	cd bf       	out	0x3d, r28	; 61
    2b28:	cf 91       	pop	r28
    2b2a:	df 91       	pop	r29
    2b2c:	08 95       	ret

00002b2e <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    2b2e:	df 93       	push	r29
    2b30:	cf 93       	push	r28
    2b32:	cd b7       	in	r28, 0x3d	; 61
    2b34:	de b7       	in	r29, 0x3e	; 62
    2b36:	60 97       	sbiw	r28, 0x10	; 16
    2b38:	0f b6       	in	r0, 0x3f	; 63
    2b3a:	f8 94       	cli
    2b3c:	de bf       	out	0x3e, r29	; 62
    2b3e:	0f be       	out	0x3f, r0	; 63
    2b40:	cd bf       	out	0x3d, r28	; 61
    2b42:	9b 87       	std	Y+11, r25	; 0x0b
    2b44:	8a 87       	std	Y+10, r24	; 0x0a
    2b46:	7d 87       	std	Y+13, r23	; 0x0d
    2b48:	6c 87       	std	Y+12, r22	; 0x0c
    2b4a:	5f 87       	std	Y+15, r21	; 0x0f
    2b4c:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    2b4e:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2b50:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b52:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b54:	9b 83       	std	Y+3, r25	; 0x03
    2b56:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2b58:	0f b6       	in	r0, 0x3f	; 63
    2b5a:	f8 94       	cli
    2b5c:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2b5e:	ea 81       	ldd	r30, Y+2	; 0x02
    2b60:	fb 81       	ldd	r31, Y+3	; 0x03
    2b62:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b64:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2b66:	89 81       	ldd	r24, Y+1	; 0x01
    2b68:	88 23       	and	r24, r24
    2b6a:	31 f1       	breq	.+76     	; 0x2bb8 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2b6c:	ea 81       	ldd	r30, Y+2	; 0x02
    2b6e:	fb 81       	ldd	r31, Y+3	; 0x03
    2b70:	86 81       	ldd	r24, Z+6	; 0x06
    2b72:	97 81       	ldd	r25, Z+7	; 0x07
    2b74:	9d 83       	std	Y+5, r25	; 0x05
    2b76:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2b78:	8a 81       	ldd	r24, Y+2	; 0x02
    2b7a:	9b 81       	ldd	r25, Y+3	; 0x03
    2b7c:	2c 85       	ldd	r18, Y+12	; 0x0c
    2b7e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2b80:	b9 01       	movw	r22, r18
    2b82:	0e 94 1e 18 	call	0x303c	; 0x303c <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2b86:	ea 81       	ldd	r30, Y+2	; 0x02
    2b88:	fb 81       	ldd	r31, Y+3	; 0x03
    2b8a:	8c 81       	ldd	r24, Y+4	; 0x04
    2b8c:	9d 81       	ldd	r25, Y+5	; 0x05
    2b8e:	97 83       	std	Z+7, r25	; 0x07
    2b90:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2b92:	ea 81       	ldd	r30, Y+2	; 0x02
    2b94:	fb 81       	ldd	r31, Y+3	; 0x03
    2b96:	81 89       	ldd	r24, Z+17	; 0x11
    2b98:	88 23       	and	r24, r24
    2b9a:	49 f0       	breq	.+18     	; 0x2bae <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2b9c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b9e:	9b 81       	ldd	r25, Y+3	; 0x03
    2ba0:	41 96       	adiw	r24, 0x11	; 17
    2ba2:	0e 94 dd 20 	call	0x41ba	; 0x41ba <xTaskRemoveFromEventList>
    2ba6:	88 23       	and	r24, r24
    2ba8:	11 f0       	breq	.+4      	; 0x2bae <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    2baa:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2bae:	0f 90       	pop	r0
    2bb0:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2bb2:	81 e0       	ldi	r24, 0x01	; 1
    2bb4:	88 8b       	std	Y+16, r24	; 0x10
    2bb6:	63 c0       	rjmp	.+198    	; 0x2c7e <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2bb8:	8e 85       	ldd	r24, Y+14	; 0x0e
    2bba:	9f 85       	ldd	r25, Y+15	; 0x0f
    2bbc:	00 97       	sbiw	r24, 0x00	; 0
    2bbe:	21 f4       	brne	.+8      	; 0x2bc8 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2bc0:	0f 90       	pop	r0
    2bc2:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2bc4:	18 8a       	std	Y+16, r1	; 0x10
    2bc6:	5b c0       	rjmp	.+182    	; 0x2c7e <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    2bc8:	8e 81       	ldd	r24, Y+6	; 0x06
    2bca:	88 23       	and	r24, r24
    2bcc:	31 f4       	brne	.+12     	; 0x2bda <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2bce:	ce 01       	movw	r24, r28
    2bd0:	07 96       	adiw	r24, 0x07	; 7
    2bd2:	0e 94 c3 21 	call	0x4386	; 0x4386 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2bd6:	81 e0       	ldi	r24, 0x01	; 1
    2bd8:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2bda:	0f 90       	pop	r0
    2bdc:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2bde:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2be2:	0f b6       	in	r0, 0x3f	; 63
    2be4:	f8 94       	cli
    2be6:	0f 92       	push	r0
    2be8:	ea 81       	ldd	r30, Y+2	; 0x02
    2bea:	fb 81       	ldd	r31, Y+3	; 0x03
    2bec:	85 8d       	ldd	r24, Z+29	; 0x1d
    2bee:	8f 3f       	cpi	r24, 0xFF	; 255
    2bf0:	19 f4       	brne	.+6      	; 0x2bf8 <xQueuePeek+0xca>
    2bf2:	ea 81       	ldd	r30, Y+2	; 0x02
    2bf4:	fb 81       	ldd	r31, Y+3	; 0x03
    2bf6:	15 8e       	std	Z+29, r1	; 0x1d
    2bf8:	ea 81       	ldd	r30, Y+2	; 0x02
    2bfa:	fb 81       	ldd	r31, Y+3	; 0x03
    2bfc:	86 8d       	ldd	r24, Z+30	; 0x1e
    2bfe:	8f 3f       	cpi	r24, 0xFF	; 255
    2c00:	19 f4       	brne	.+6      	; 0x2c08 <xQueuePeek+0xda>
    2c02:	ea 81       	ldd	r30, Y+2	; 0x02
    2c04:	fb 81       	ldd	r31, Y+3	; 0x03
    2c06:	16 8e       	std	Z+30, r1	; 0x1e
    2c08:	0f 90       	pop	r0
    2c0a:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2c0c:	ce 01       	movw	r24, r28
    2c0e:	07 96       	adiw	r24, 0x07	; 7
    2c10:	9e 01       	movw	r18, r28
    2c12:	22 5f       	subi	r18, 0xF2	; 242
    2c14:	3f 4f       	sbci	r19, 0xFF	; 255
    2c16:	b9 01       	movw	r22, r18
    2c18:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <xTaskCheckForTimeOut>
    2c1c:	88 23       	and	r24, r24
    2c1e:	09 f5       	brne	.+66     	; 0x2c62 <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2c20:	8a 81       	ldd	r24, Y+2	; 0x02
    2c22:	9b 81       	ldd	r25, Y+3	; 0x03
    2c24:	0e 94 b8 18 	call	0x3170	; 0x3170 <prvIsQueueEmpty>
    2c28:	88 23       	and	r24, r24
    2c2a:	a1 f0       	breq	.+40     	; 0x2c54 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2c2c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c2e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c30:	41 96       	adiw	r24, 0x11	; 17
    2c32:	2e 85       	ldd	r18, Y+14	; 0x0e
    2c34:	3f 85       	ldd	r19, Y+15	; 0x0f
    2c36:	b9 01       	movw	r22, r18
    2c38:	0e 94 8b 20 	call	0x4116	; 0x4116 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2c3c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c3e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c40:	0e 94 65 18 	call	0x30ca	; 0x30ca <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2c44:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
    2c48:	88 23       	and	r24, r24
    2c4a:	09 f0       	breq	.+2      	; 0x2c4e <xQueuePeek+0x120>
    2c4c:	85 cf       	rjmp	.-246    	; 0x2b58 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    2c4e:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
    2c52:	82 cf       	rjmp	.-252    	; 0x2b58 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    2c54:	8a 81       	ldd	r24, Y+2	; 0x02
    2c56:	9b 81       	ldd	r25, Y+3	; 0x03
    2c58:	0e 94 65 18 	call	0x30ca	; 0x30ca <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2c5c:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
    2c60:	7b cf       	rjmp	.-266    	; 0x2b58 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    2c62:	8a 81       	ldd	r24, Y+2	; 0x02
    2c64:	9b 81       	ldd	r25, Y+3	; 0x03
    2c66:	0e 94 65 18 	call	0x30ca	; 0x30ca <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2c6a:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2c6e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c70:	9b 81       	ldd	r25, Y+3	; 0x03
    2c72:	0e 94 b8 18 	call	0x3170	; 0x3170 <prvIsQueueEmpty>
    2c76:	88 23       	and	r24, r24
    2c78:	09 f4       	brne	.+2      	; 0x2c7c <xQueuePeek+0x14e>
    2c7a:	6e cf       	rjmp	.-292    	; 0x2b58 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2c7c:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2c7e:	88 89       	ldd	r24, Y+16	; 0x10
}
    2c80:	60 96       	adiw	r28, 0x10	; 16
    2c82:	0f b6       	in	r0, 0x3f	; 63
    2c84:	f8 94       	cli
    2c86:	de bf       	out	0x3e, r29	; 62
    2c88:	0f be       	out	0x3f, r0	; 63
    2c8a:	cd bf       	out	0x3d, r28	; 61
    2c8c:	cf 91       	pop	r28
    2c8e:	df 91       	pop	r29
    2c90:	08 95       	ret

00002c92 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2c92:	df 93       	push	r29
    2c94:	cf 93       	push	r28
    2c96:	cd b7       	in	r28, 0x3d	; 61
    2c98:	de b7       	in	r29, 0x3e	; 62
    2c9a:	2c 97       	sbiw	r28, 0x0c	; 12
    2c9c:	0f b6       	in	r0, 0x3f	; 63
    2c9e:	f8 94       	cli
    2ca0:	de bf       	out	0x3e, r29	; 62
    2ca2:	0f be       	out	0x3f, r0	; 63
    2ca4:	cd bf       	out	0x3d, r28	; 61
    2ca6:	98 87       	std	Y+8, r25	; 0x08
    2ca8:	8f 83       	std	Y+7, r24	; 0x07
    2caa:	7a 87       	std	Y+10, r23	; 0x0a
    2cac:	69 87       	std	Y+9, r22	; 0x09
    2cae:	5c 87       	std	Y+12, r21	; 0x0c
    2cb0:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2cb2:	8f 81       	ldd	r24, Y+7	; 0x07
    2cb4:	98 85       	ldd	r25, Y+8	; 0x08
    2cb6:	9c 83       	std	Y+4, r25	; 0x04
    2cb8:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2cba:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2cbc:	eb 81       	ldd	r30, Y+3	; 0x03
    2cbe:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cc2:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2cc4:	8a 81       	ldd	r24, Y+2	; 0x02
    2cc6:	88 23       	and	r24, r24
    2cc8:	81 f1       	breq	.+96     	; 0x2d2a <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    2cca:	eb 81       	ldd	r30, Y+3	; 0x03
    2ccc:	fc 81       	ldd	r31, Y+4	; 0x04
    2cce:	85 8d       	ldd	r24, Z+29	; 0x1d
    2cd0:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2cd2:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd4:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd6:	29 85       	ldd	r18, Y+9	; 0x09
    2cd8:	3a 85       	ldd	r19, Y+10	; 0x0a
    2cda:	b9 01       	movw	r22, r18
    2cdc:	0e 94 1e 18 	call	0x303c	; 0x303c <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2ce0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ce2:	81 50       	subi	r24, 0x01	; 1
    2ce4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ce6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ce8:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    2cea:	89 81       	ldd	r24, Y+1	; 0x01
    2cec:	8f 3f       	cpi	r24, 0xFF	; 255
    2cee:	a9 f4       	brne	.+42     	; 0x2d1a <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2cf0:	eb 81       	ldd	r30, Y+3	; 0x03
    2cf2:	fc 81       	ldd	r31, Y+4	; 0x04
    2cf4:	80 85       	ldd	r24, Z+8	; 0x08
    2cf6:	88 23       	and	r24, r24
    2cf8:	a9 f0       	breq	.+42     	; 0x2d24 <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2cfa:	8b 81       	ldd	r24, Y+3	; 0x03
    2cfc:	9c 81       	ldd	r25, Y+4	; 0x04
    2cfe:	08 96       	adiw	r24, 0x08	; 8
    2d00:	0e 94 dd 20 	call	0x41ba	; 0x41ba <xTaskRemoveFromEventList>
    2d04:	88 23       	and	r24, r24
    2d06:	71 f0       	breq	.+28     	; 0x2d24 <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    2d08:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d0a:	9c 85       	ldd	r25, Y+12	; 0x0c
    2d0c:	00 97       	sbiw	r24, 0x00	; 0
    2d0e:	51 f0       	breq	.+20     	; 0x2d24 <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    2d10:	eb 85       	ldd	r30, Y+11	; 0x0b
    2d12:	fc 85       	ldd	r31, Y+12	; 0x0c
    2d14:	81 e0       	ldi	r24, 0x01	; 1
    2d16:	80 83       	st	Z, r24
    2d18:	05 c0       	rjmp	.+10     	; 0x2d24 <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2d1a:	89 81       	ldd	r24, Y+1	; 0x01
    2d1c:	8f 5f       	subi	r24, 0xFF	; 255
    2d1e:	eb 81       	ldd	r30, Y+3	; 0x03
    2d20:	fc 81       	ldd	r31, Y+4	; 0x04
    2d22:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    2d24:	81 e0       	ldi	r24, 0x01	; 1
    2d26:	8e 83       	std	Y+6, r24	; 0x06
    2d28:	01 c0       	rjmp	.+2      	; 0x2d2c <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    2d2a:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2d2c:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2d2e:	2c 96       	adiw	r28, 0x0c	; 12
    2d30:	0f b6       	in	r0, 0x3f	; 63
    2d32:	f8 94       	cli
    2d34:	de bf       	out	0x3e, r29	; 62
    2d36:	0f be       	out	0x3f, r0	; 63
    2d38:	cd bf       	out	0x3d, r28	; 61
    2d3a:	cf 91       	pop	r28
    2d3c:	df 91       	pop	r29
    2d3e:	08 95       	ret

00002d40 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    2d40:	df 93       	push	r29
    2d42:	cf 93       	push	r28
    2d44:	cd b7       	in	r28, 0x3d	; 61
    2d46:	de b7       	in	r29, 0x3e	; 62
    2d48:	2a 97       	sbiw	r28, 0x0a	; 10
    2d4a:	0f b6       	in	r0, 0x3f	; 63
    2d4c:	f8 94       	cli
    2d4e:	de bf       	out	0x3e, r29	; 62
    2d50:	0f be       	out	0x3f, r0	; 63
    2d52:	cd bf       	out	0x3d, r28	; 61
    2d54:	98 87       	std	Y+8, r25	; 0x08
    2d56:	8f 83       	std	Y+7, r24	; 0x07
    2d58:	7a 87       	std	Y+10, r23	; 0x0a
    2d5a:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2d5c:	8f 81       	ldd	r24, Y+7	; 0x07
    2d5e:	98 85       	ldd	r25, Y+8	; 0x08
    2d60:	9a 83       	std	Y+2, r25	; 0x02
    2d62:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2d64:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2d66:	e9 81       	ldd	r30, Y+1	; 0x01
    2d68:	fa 81       	ldd	r31, Y+2	; 0x02
    2d6a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d6c:	88 23       	and	r24, r24
    2d6e:	b1 f0       	breq	.+44     	; 0x2d9c <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2d70:	e9 81       	ldd	r30, Y+1	; 0x01
    2d72:	fa 81       	ldd	r31, Y+2	; 0x02
    2d74:	86 81       	ldd	r24, Z+6	; 0x06
    2d76:	97 81       	ldd	r25, Z+7	; 0x07
    2d78:	9c 83       	std	Y+4, r25	; 0x04
    2d7a:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2d7c:	89 81       	ldd	r24, Y+1	; 0x01
    2d7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d80:	29 85       	ldd	r18, Y+9	; 0x09
    2d82:	3a 85       	ldd	r19, Y+10	; 0x0a
    2d84:	b9 01       	movw	r22, r18
    2d86:	0e 94 1e 18 	call	0x303c	; 0x303c <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2d8a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d8c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d90:	9c 81       	ldd	r25, Y+4	; 0x04
    2d92:	97 83       	std	Z+7, r25	; 0x07
    2d94:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    2d96:	81 e0       	ldi	r24, 0x01	; 1
    2d98:	8e 83       	std	Y+6, r24	; 0x06
    2d9a:	01 c0       	rjmp	.+2      	; 0x2d9e <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    2d9c:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2d9e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2da0:	2a 96       	adiw	r28, 0x0a	; 10
    2da2:	0f b6       	in	r0, 0x3f	; 63
    2da4:	f8 94       	cli
    2da6:	de bf       	out	0x3e, r29	; 62
    2da8:	0f be       	out	0x3f, r0	; 63
    2daa:	cd bf       	out	0x3d, r28	; 61
    2dac:	cf 91       	pop	r28
    2dae:	df 91       	pop	r29
    2db0:	08 95       	ret

00002db2 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2db2:	df 93       	push	r29
    2db4:	cf 93       	push	r28
    2db6:	00 d0       	rcall	.+0      	; 0x2db8 <uxQueueMessagesWaiting+0x6>
    2db8:	0f 92       	push	r0
    2dba:	cd b7       	in	r28, 0x3d	; 61
    2dbc:	de b7       	in	r29, 0x3e	; 62
    2dbe:	9b 83       	std	Y+3, r25	; 0x03
    2dc0:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    2dc2:	0f b6       	in	r0, 0x3f	; 63
    2dc4:	f8 94       	cli
    2dc6:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2dc8:	ea 81       	ldd	r30, Y+2	; 0x02
    2dca:	fb 81       	ldd	r31, Y+3	; 0x03
    2dcc:	82 8d       	ldd	r24, Z+26	; 0x1a
    2dce:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    2dd0:	0f 90       	pop	r0
    2dd2:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2dd4:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2dd6:	0f 90       	pop	r0
    2dd8:	0f 90       	pop	r0
    2dda:	0f 90       	pop	r0
    2ddc:	cf 91       	pop	r28
    2dde:	df 91       	pop	r29
    2de0:	08 95       	ret

00002de2 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2de2:	df 93       	push	r29
    2de4:	cf 93       	push	r28
    2de6:	00 d0       	rcall	.+0      	; 0x2de8 <uxQueueSpacesAvailable+0x6>
    2de8:	00 d0       	rcall	.+0      	; 0x2dea <uxQueueSpacesAvailable+0x8>
    2dea:	0f 92       	push	r0
    2dec:	cd b7       	in	r28, 0x3d	; 61
    2dee:	de b7       	in	r29, 0x3e	; 62
    2df0:	9d 83       	std	Y+5, r25	; 0x05
    2df2:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2df4:	8c 81       	ldd	r24, Y+4	; 0x04
    2df6:	9d 81       	ldd	r25, Y+5	; 0x05
    2df8:	9a 83       	std	Y+2, r25	; 0x02
    2dfa:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    2dfc:	0f b6       	in	r0, 0x3f	; 63
    2dfe:	f8 94       	cli
    2e00:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2e02:	e9 81       	ldd	r30, Y+1	; 0x01
    2e04:	fa 81       	ldd	r31, Y+2	; 0x02
    2e06:	93 8d       	ldd	r25, Z+27	; 0x1b
    2e08:	e9 81       	ldd	r30, Y+1	; 0x01
    2e0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e0e:	29 2f       	mov	r18, r25
    2e10:	28 1b       	sub	r18, r24
    2e12:	82 2f       	mov	r24, r18
    2e14:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    2e16:	0f 90       	pop	r0
    2e18:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2e1a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2e1c:	0f 90       	pop	r0
    2e1e:	0f 90       	pop	r0
    2e20:	0f 90       	pop	r0
    2e22:	0f 90       	pop	r0
    2e24:	0f 90       	pop	r0
    2e26:	cf 91       	pop	r28
    2e28:	df 91       	pop	r29
    2e2a:	08 95       	ret

00002e2c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2e2c:	df 93       	push	r29
    2e2e:	cf 93       	push	r28
    2e30:	00 d0       	rcall	.+0      	; 0x2e32 <uxQueueMessagesWaitingFromISR+0x6>
    2e32:	00 d0       	rcall	.+0      	; 0x2e34 <uxQueueMessagesWaitingFromISR+0x8>
    2e34:	0f 92       	push	r0
    2e36:	cd b7       	in	r28, 0x3d	; 61
    2e38:	de b7       	in	r29, 0x3e	; 62
    2e3a:	9d 83       	std	Y+5, r25	; 0x05
    2e3c:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2e3e:	8c 81       	ldd	r24, Y+4	; 0x04
    2e40:	9d 81       	ldd	r25, Y+5	; 0x05
    2e42:	9a 83       	std	Y+2, r25	; 0x02
    2e44:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    2e46:	e9 81       	ldd	r30, Y+1	; 0x01
    2e48:	fa 81       	ldd	r31, Y+2	; 0x02
    2e4a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e4c:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    2e4e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2e50:	0f 90       	pop	r0
    2e52:	0f 90       	pop	r0
    2e54:	0f 90       	pop	r0
    2e56:	0f 90       	pop	r0
    2e58:	0f 90       	pop	r0
    2e5a:	cf 91       	pop	r28
    2e5c:	df 91       	pop	r29
    2e5e:	08 95       	ret

00002e60 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2e60:	df 93       	push	r29
    2e62:	cf 93       	push	r28
    2e64:	00 d0       	rcall	.+0      	; 0x2e66 <vQueueDelete+0x6>
    2e66:	00 d0       	rcall	.+0      	; 0x2e68 <vQueueDelete+0x8>
    2e68:	cd b7       	in	r28, 0x3d	; 61
    2e6a:	de b7       	in	r29, 0x3e	; 62
    2e6c:	9c 83       	std	Y+4, r25	; 0x04
    2e6e:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    2e70:	8b 81       	ldd	r24, Y+3	; 0x03
    2e72:	9c 81       	ldd	r25, Y+4	; 0x04
    2e74:	9a 83       	std	Y+2, r25	; 0x02
    2e76:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    2e78:	89 81       	ldd	r24, Y+1	; 0x01
    2e7a:	9a 81       	ldd	r25, Y+2	; 0x02
    2e7c:	0e 94 25 08 	call	0x104a	; 0x104a <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2e80:	0f 90       	pop	r0
    2e82:	0f 90       	pop	r0
    2e84:	0f 90       	pop	r0
    2e86:	0f 90       	pop	r0
    2e88:	cf 91       	pop	r28
    2e8a:	df 91       	pop	r29
    2e8c:	08 95       	ret

00002e8e <uxQueueGetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
    {
    2e8e:	df 93       	push	r29
    2e90:	cf 93       	push	r28
    2e92:	00 d0       	rcall	.+0      	; 0x2e94 <uxQueueGetQueueNumber+0x6>
    2e94:	cd b7       	in	r28, 0x3d	; 61
    2e96:	de b7       	in	r29, 0x3e	; 62
    2e98:	9a 83       	std	Y+2, r25	; 0x02
    2e9a:	89 83       	std	Y+1, r24	; 0x01
        return ( ( Queue_t * ) xQueue )->uxQueueNumber;
    2e9c:	e9 81       	ldd	r30, Y+1	; 0x01
    2e9e:	fa 81       	ldd	r31, Y+2	; 0x02
    2ea0:	87 8d       	ldd	r24, Z+31	; 0x1f
    }
    2ea2:	0f 90       	pop	r0
    2ea4:	0f 90       	pop	r0
    2ea6:	cf 91       	pop	r28
    2ea8:	df 91       	pop	r29
    2eaa:	08 95       	ret

00002eac <vQueueSetQueueNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

    void vQueueSetQueueNumber( QueueHandle_t xQueue,
                               UBaseType_t uxQueueNumber )
    {
    2eac:	df 93       	push	r29
    2eae:	cf 93       	push	r28
    2eb0:	00 d0       	rcall	.+0      	; 0x2eb2 <vQueueSetQueueNumber+0x6>
    2eb2:	0f 92       	push	r0
    2eb4:	cd b7       	in	r28, 0x3d	; 61
    2eb6:	de b7       	in	r29, 0x3e	; 62
    2eb8:	9a 83       	std	Y+2, r25	; 0x02
    2eba:	89 83       	std	Y+1, r24	; 0x01
    2ebc:	6b 83       	std	Y+3, r22	; 0x03
        ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
    2ebe:	e9 81       	ldd	r30, Y+1	; 0x01
    2ec0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ec2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec4:	87 8f       	std	Z+31, r24	; 0x1f
    }
    2ec6:	0f 90       	pop	r0
    2ec8:	0f 90       	pop	r0
    2eca:	0f 90       	pop	r0
    2ecc:	cf 91       	pop	r28
    2ece:	df 91       	pop	r29
    2ed0:	08 95       	ret

00002ed2 <ucQueueGetQueueType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
    {
    2ed2:	df 93       	push	r29
    2ed4:	cf 93       	push	r28
    2ed6:	00 d0       	rcall	.+0      	; 0x2ed8 <ucQueueGetQueueType+0x6>
    2ed8:	cd b7       	in	r28, 0x3d	; 61
    2eda:	de b7       	in	r29, 0x3e	; 62
    2edc:	9a 83       	std	Y+2, r25	; 0x02
    2ede:	89 83       	std	Y+1, r24	; 0x01
        return ( ( Queue_t * ) xQueue )->ucQueueType;
    2ee0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ee2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ee4:	80 a1       	ldd	r24, Z+32	; 0x20
    }
    2ee6:	0f 90       	pop	r0
    2ee8:	0f 90       	pop	r0
    2eea:	cf 91       	pop	r28
    2eec:	df 91       	pop	r29
    2eee:	08 95       	ret

00002ef0 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    2ef0:	df 93       	push	r29
    2ef2:	cf 93       	push	r28
    2ef4:	cd b7       	in	r28, 0x3d	; 61
    2ef6:	de b7       	in	r29, 0x3e	; 62
    2ef8:	27 97       	sbiw	r28, 0x07	; 7
    2efa:	0f b6       	in	r0, 0x3f	; 63
    2efc:	f8 94       	cli
    2efe:	de bf       	out	0x3e, r29	; 62
    2f00:	0f be       	out	0x3f, r0	; 63
    2f02:	cd bf       	out	0x3d, r28	; 61
    2f04:	9c 83       	std	Y+4, r25	; 0x04
    2f06:	8b 83       	std	Y+3, r24	; 0x03
    2f08:	7e 83       	std	Y+6, r23	; 0x06
    2f0a:	6d 83       	std	Y+5, r22	; 0x05
    2f0c:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    2f0e:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2f10:	eb 81       	ldd	r30, Y+3	; 0x03
    2f12:	fc 81       	ldd	r31, Y+4	; 0x04
    2f14:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f16:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2f18:	eb 81       	ldd	r30, Y+3	; 0x03
    2f1a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f1c:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f1e:	88 23       	and	r24, r24
    2f20:	09 f4       	brne	.+2      	; 0x2f24 <prvCopyDataToQueue+0x34>
    2f22:	7d c0       	rjmp	.+250    	; 0x301e <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    2f24:	8f 81       	ldd	r24, Y+7	; 0x07
    2f26:	88 23       	and	r24, r24
    2f28:	99 f5       	brne	.+102    	; 0x2f90 <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2f2a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f2c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f2e:	62 81       	ldd	r22, Z+2	; 0x02
    2f30:	73 81       	ldd	r23, Z+3	; 0x03
    2f32:	eb 81       	ldd	r30, Y+3	; 0x03
    2f34:	fc 81       	ldd	r31, Y+4	; 0x04
    2f36:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f38:	48 2f       	mov	r20, r24
    2f3a:	50 e0       	ldi	r21, 0x00	; 0
    2f3c:	2d 81       	ldd	r18, Y+5	; 0x05
    2f3e:	3e 81       	ldd	r19, Y+6	; 0x06
    2f40:	cb 01       	movw	r24, r22
    2f42:	b9 01       	movw	r22, r18
    2f44:	0e 94 b4 35 	call	0x6b68	; 0x6b68 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2f48:	eb 81       	ldd	r30, Y+3	; 0x03
    2f4a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f4c:	22 81       	ldd	r18, Z+2	; 0x02
    2f4e:	33 81       	ldd	r19, Z+3	; 0x03
    2f50:	eb 81       	ldd	r30, Y+3	; 0x03
    2f52:	fc 81       	ldd	r31, Y+4	; 0x04
    2f54:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f56:	88 2f       	mov	r24, r24
    2f58:	90 e0       	ldi	r25, 0x00	; 0
    2f5a:	82 0f       	add	r24, r18
    2f5c:	93 1f       	adc	r25, r19
    2f5e:	eb 81       	ldd	r30, Y+3	; 0x03
    2f60:	fc 81       	ldd	r31, Y+4	; 0x04
    2f62:	93 83       	std	Z+3, r25	; 0x03
    2f64:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2f66:	eb 81       	ldd	r30, Y+3	; 0x03
    2f68:	fc 81       	ldd	r31, Y+4	; 0x04
    2f6a:	22 81       	ldd	r18, Z+2	; 0x02
    2f6c:	33 81       	ldd	r19, Z+3	; 0x03
    2f6e:	eb 81       	ldd	r30, Y+3	; 0x03
    2f70:	fc 81       	ldd	r31, Y+4	; 0x04
    2f72:	84 81       	ldd	r24, Z+4	; 0x04
    2f74:	95 81       	ldd	r25, Z+5	; 0x05
    2f76:	28 17       	cp	r18, r24
    2f78:	39 07       	cpc	r19, r25
    2f7a:	08 f4       	brcc	.+2      	; 0x2f7e <prvCopyDataToQueue+0x8e>
    2f7c:	50 c0       	rjmp	.+160    	; 0x301e <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    2f7e:	eb 81       	ldd	r30, Y+3	; 0x03
    2f80:	fc 81       	ldd	r31, Y+4	; 0x04
    2f82:	80 81       	ld	r24, Z
    2f84:	91 81       	ldd	r25, Z+1	; 0x01
    2f86:	eb 81       	ldd	r30, Y+3	; 0x03
    2f88:	fc 81       	ldd	r31, Y+4	; 0x04
    2f8a:	93 83       	std	Z+3, r25	; 0x03
    2f8c:	82 83       	std	Z+2, r24	; 0x02
    2f8e:	47 c0       	rjmp	.+142    	; 0x301e <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2f90:	eb 81       	ldd	r30, Y+3	; 0x03
    2f92:	fc 81       	ldd	r31, Y+4	; 0x04
    2f94:	66 81       	ldd	r22, Z+6	; 0x06
    2f96:	77 81       	ldd	r23, Z+7	; 0x07
    2f98:	eb 81       	ldd	r30, Y+3	; 0x03
    2f9a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f9c:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f9e:	48 2f       	mov	r20, r24
    2fa0:	50 e0       	ldi	r21, 0x00	; 0
    2fa2:	2d 81       	ldd	r18, Y+5	; 0x05
    2fa4:	3e 81       	ldd	r19, Y+6	; 0x06
    2fa6:	cb 01       	movw	r24, r22
    2fa8:	b9 01       	movw	r22, r18
    2faa:	0e 94 b4 35 	call	0x6b68	; 0x6b68 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2fae:	eb 81       	ldd	r30, Y+3	; 0x03
    2fb0:	fc 81       	ldd	r31, Y+4	; 0x04
    2fb2:	26 81       	ldd	r18, Z+6	; 0x06
    2fb4:	37 81       	ldd	r19, Z+7	; 0x07
    2fb6:	eb 81       	ldd	r30, Y+3	; 0x03
    2fb8:	fc 81       	ldd	r31, Y+4	; 0x04
    2fba:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fbc:	88 2f       	mov	r24, r24
    2fbe:	90 e0       	ldi	r25, 0x00	; 0
    2fc0:	90 95       	com	r25
    2fc2:	81 95       	neg	r24
    2fc4:	9f 4f       	sbci	r25, 0xFF	; 255
    2fc6:	82 0f       	add	r24, r18
    2fc8:	93 1f       	adc	r25, r19
    2fca:	eb 81       	ldd	r30, Y+3	; 0x03
    2fcc:	fc 81       	ldd	r31, Y+4	; 0x04
    2fce:	97 83       	std	Z+7, r25	; 0x07
    2fd0:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2fd2:	eb 81       	ldd	r30, Y+3	; 0x03
    2fd4:	fc 81       	ldd	r31, Y+4	; 0x04
    2fd6:	26 81       	ldd	r18, Z+6	; 0x06
    2fd8:	37 81       	ldd	r19, Z+7	; 0x07
    2fda:	eb 81       	ldd	r30, Y+3	; 0x03
    2fdc:	fc 81       	ldd	r31, Y+4	; 0x04
    2fde:	80 81       	ld	r24, Z
    2fe0:	91 81       	ldd	r25, Z+1	; 0x01
    2fe2:	28 17       	cp	r18, r24
    2fe4:	39 07       	cpc	r19, r25
    2fe6:	90 f4       	brcc	.+36     	; 0x300c <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2fe8:	eb 81       	ldd	r30, Y+3	; 0x03
    2fea:	fc 81       	ldd	r31, Y+4	; 0x04
    2fec:	24 81       	ldd	r18, Z+4	; 0x04
    2fee:	35 81       	ldd	r19, Z+5	; 0x05
    2ff0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ff2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ff4:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ff6:	88 2f       	mov	r24, r24
    2ff8:	90 e0       	ldi	r25, 0x00	; 0
    2ffa:	90 95       	com	r25
    2ffc:	81 95       	neg	r24
    2ffe:	9f 4f       	sbci	r25, 0xFF	; 255
    3000:	82 0f       	add	r24, r18
    3002:	93 1f       	adc	r25, r19
    3004:	eb 81       	ldd	r30, Y+3	; 0x03
    3006:	fc 81       	ldd	r31, Y+4	; 0x04
    3008:	97 83       	std	Z+7, r25	; 0x07
    300a:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    300c:	8f 81       	ldd	r24, Y+7	; 0x07
    300e:	82 30       	cpi	r24, 0x02	; 2
    3010:	31 f4       	brne	.+12     	; 0x301e <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3012:	89 81       	ldd	r24, Y+1	; 0x01
    3014:	88 23       	and	r24, r24
    3016:	19 f0       	breq	.+6      	; 0x301e <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    3018:	89 81       	ldd	r24, Y+1	; 0x01
    301a:	81 50       	subi	r24, 0x01	; 1
    301c:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    301e:	89 81       	ldd	r24, Y+1	; 0x01
    3020:	8f 5f       	subi	r24, 0xFF	; 255
    3022:	eb 81       	ldd	r30, Y+3	; 0x03
    3024:	fc 81       	ldd	r31, Y+4	; 0x04
    3026:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    3028:	8a 81       	ldd	r24, Y+2	; 0x02
}
    302a:	27 96       	adiw	r28, 0x07	; 7
    302c:	0f b6       	in	r0, 0x3f	; 63
    302e:	f8 94       	cli
    3030:	de bf       	out	0x3e, r29	; 62
    3032:	0f be       	out	0x3f, r0	; 63
    3034:	cd bf       	out	0x3d, r28	; 61
    3036:	cf 91       	pop	r28
    3038:	df 91       	pop	r29
    303a:	08 95       	ret

0000303c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    303c:	df 93       	push	r29
    303e:	cf 93       	push	r28
    3040:	00 d0       	rcall	.+0      	; 0x3042 <prvCopyDataFromQueue+0x6>
    3042:	00 d0       	rcall	.+0      	; 0x3044 <prvCopyDataFromQueue+0x8>
    3044:	cd b7       	in	r28, 0x3d	; 61
    3046:	de b7       	in	r29, 0x3e	; 62
    3048:	9a 83       	std	Y+2, r25	; 0x02
    304a:	89 83       	std	Y+1, r24	; 0x01
    304c:	7c 83       	std	Y+4, r23	; 0x04
    304e:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3050:	e9 81       	ldd	r30, Y+1	; 0x01
    3052:	fa 81       	ldd	r31, Y+2	; 0x02
    3054:	84 8d       	ldd	r24, Z+28	; 0x1c
    3056:	88 23       	and	r24, r24
    3058:	89 f1       	breq	.+98     	; 0x30bc <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    305a:	e9 81       	ldd	r30, Y+1	; 0x01
    305c:	fa 81       	ldd	r31, Y+2	; 0x02
    305e:	26 81       	ldd	r18, Z+6	; 0x06
    3060:	37 81       	ldd	r19, Z+7	; 0x07
    3062:	e9 81       	ldd	r30, Y+1	; 0x01
    3064:	fa 81       	ldd	r31, Y+2	; 0x02
    3066:	84 8d       	ldd	r24, Z+28	; 0x1c
    3068:	88 2f       	mov	r24, r24
    306a:	90 e0       	ldi	r25, 0x00	; 0
    306c:	82 0f       	add	r24, r18
    306e:	93 1f       	adc	r25, r19
    3070:	e9 81       	ldd	r30, Y+1	; 0x01
    3072:	fa 81       	ldd	r31, Y+2	; 0x02
    3074:	97 83       	std	Z+7, r25	; 0x07
    3076:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3078:	e9 81       	ldd	r30, Y+1	; 0x01
    307a:	fa 81       	ldd	r31, Y+2	; 0x02
    307c:	26 81       	ldd	r18, Z+6	; 0x06
    307e:	37 81       	ldd	r19, Z+7	; 0x07
    3080:	e9 81       	ldd	r30, Y+1	; 0x01
    3082:	fa 81       	ldd	r31, Y+2	; 0x02
    3084:	84 81       	ldd	r24, Z+4	; 0x04
    3086:	95 81       	ldd	r25, Z+5	; 0x05
    3088:	28 17       	cp	r18, r24
    308a:	39 07       	cpc	r19, r25
    308c:	40 f0       	brcs	.+16     	; 0x309e <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    308e:	e9 81       	ldd	r30, Y+1	; 0x01
    3090:	fa 81       	ldd	r31, Y+2	; 0x02
    3092:	80 81       	ld	r24, Z
    3094:	91 81       	ldd	r25, Z+1	; 0x01
    3096:	e9 81       	ldd	r30, Y+1	; 0x01
    3098:	fa 81       	ldd	r31, Y+2	; 0x02
    309a:	97 83       	std	Z+7, r25	; 0x07
    309c:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    309e:	e9 81       	ldd	r30, Y+1	; 0x01
    30a0:	fa 81       	ldd	r31, Y+2	; 0x02
    30a2:	46 81       	ldd	r20, Z+6	; 0x06
    30a4:	57 81       	ldd	r21, Z+7	; 0x07
    30a6:	e9 81       	ldd	r30, Y+1	; 0x01
    30a8:	fa 81       	ldd	r31, Y+2	; 0x02
    30aa:	84 8d       	ldd	r24, Z+28	; 0x1c
    30ac:	28 2f       	mov	r18, r24
    30ae:	30 e0       	ldi	r19, 0x00	; 0
    30b0:	8b 81       	ldd	r24, Y+3	; 0x03
    30b2:	9c 81       	ldd	r25, Y+4	; 0x04
    30b4:	ba 01       	movw	r22, r20
    30b6:	a9 01       	movw	r20, r18
    30b8:	0e 94 b4 35 	call	0x6b68	; 0x6b68 <memcpy>
    }
}
    30bc:	0f 90       	pop	r0
    30be:	0f 90       	pop	r0
    30c0:	0f 90       	pop	r0
    30c2:	0f 90       	pop	r0
    30c4:	cf 91       	pop	r28
    30c6:	df 91       	pop	r29
    30c8:	08 95       	ret

000030ca <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    30ca:	df 93       	push	r29
    30cc:	cf 93       	push	r28
    30ce:	00 d0       	rcall	.+0      	; 0x30d0 <prvUnlockQueue+0x6>
    30d0:	00 d0       	rcall	.+0      	; 0x30d2 <prvUnlockQueue+0x8>
    30d2:	cd b7       	in	r28, 0x3d	; 61
    30d4:	de b7       	in	r29, 0x3e	; 62
    30d6:	9c 83       	std	Y+4, r25	; 0x04
    30d8:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    30da:	0f b6       	in	r0, 0x3f	; 63
    30dc:	f8 94       	cli
    30de:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    30e0:	eb 81       	ldd	r30, Y+3	; 0x03
    30e2:	fc 81       	ldd	r31, Y+4	; 0x04
    30e4:	86 8d       	ldd	r24, Z+30	; 0x1e
    30e6:	8a 83       	std	Y+2, r24	; 0x02
    30e8:	11 c0       	rjmp	.+34     	; 0x310c <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    30ea:	eb 81       	ldd	r30, Y+3	; 0x03
    30ec:	fc 81       	ldd	r31, Y+4	; 0x04
    30ee:	81 89       	ldd	r24, Z+17	; 0x11
    30f0:	88 23       	and	r24, r24
    30f2:	79 f0       	breq	.+30     	; 0x3112 <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    30f4:	8b 81       	ldd	r24, Y+3	; 0x03
    30f6:	9c 81       	ldd	r25, Y+4	; 0x04
    30f8:	41 96       	adiw	r24, 0x11	; 17
    30fa:	0e 94 dd 20 	call	0x41ba	; 0x41ba <xTaskRemoveFromEventList>
    30fe:	88 23       	and	r24, r24
    3100:	11 f0       	breq	.+4      	; 0x3106 <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    3102:	0e 94 4d 22 	call	0x449a	; 0x449a <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    3106:	8a 81       	ldd	r24, Y+2	; 0x02
    3108:	81 50       	subi	r24, 0x01	; 1
    310a:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    310c:	8a 81       	ldd	r24, Y+2	; 0x02
    310e:	18 16       	cp	r1, r24
    3110:	64 f3       	brlt	.-40     	; 0x30ea <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    3112:	eb 81       	ldd	r30, Y+3	; 0x03
    3114:	fc 81       	ldd	r31, Y+4	; 0x04
    3116:	8f ef       	ldi	r24, 0xFF	; 255
    3118:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    311a:	0f 90       	pop	r0
    311c:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    311e:	0f b6       	in	r0, 0x3f	; 63
    3120:	f8 94       	cli
    3122:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    3124:	eb 81       	ldd	r30, Y+3	; 0x03
    3126:	fc 81       	ldd	r31, Y+4	; 0x04
    3128:	85 8d       	ldd	r24, Z+29	; 0x1d
    312a:	89 83       	std	Y+1, r24	; 0x01
    312c:	11 c0       	rjmp	.+34     	; 0x3150 <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    312e:	eb 81       	ldd	r30, Y+3	; 0x03
    3130:	fc 81       	ldd	r31, Y+4	; 0x04
    3132:	80 85       	ldd	r24, Z+8	; 0x08
    3134:	88 23       	and	r24, r24
    3136:	79 f0       	breq	.+30     	; 0x3156 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3138:	8b 81       	ldd	r24, Y+3	; 0x03
    313a:	9c 81       	ldd	r25, Y+4	; 0x04
    313c:	08 96       	adiw	r24, 0x08	; 8
    313e:	0e 94 dd 20 	call	0x41ba	; 0x41ba <xTaskRemoveFromEventList>
    3142:	88 23       	and	r24, r24
    3144:	11 f0       	breq	.+4      	; 0x314a <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    3146:	0e 94 4d 22 	call	0x449a	; 0x449a <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    314a:	89 81       	ldd	r24, Y+1	; 0x01
    314c:	81 50       	subi	r24, 0x01	; 1
    314e:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    3150:	89 81       	ldd	r24, Y+1	; 0x01
    3152:	18 16       	cp	r1, r24
    3154:	64 f3       	brlt	.-40     	; 0x312e <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    3156:	eb 81       	ldd	r30, Y+3	; 0x03
    3158:	fc 81       	ldd	r31, Y+4	; 0x04
    315a:	8f ef       	ldi	r24, 0xFF	; 255
    315c:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    315e:	0f 90       	pop	r0
    3160:	0f be       	out	0x3f, r0	; 63
}
    3162:	0f 90       	pop	r0
    3164:	0f 90       	pop	r0
    3166:	0f 90       	pop	r0
    3168:	0f 90       	pop	r0
    316a:	cf 91       	pop	r28
    316c:	df 91       	pop	r29
    316e:	08 95       	ret

00003170 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    3170:	df 93       	push	r29
    3172:	cf 93       	push	r28
    3174:	00 d0       	rcall	.+0      	; 0x3176 <prvIsQueueEmpty+0x6>
    3176:	0f 92       	push	r0
    3178:	cd b7       	in	r28, 0x3d	; 61
    317a:	de b7       	in	r29, 0x3e	; 62
    317c:	9b 83       	std	Y+3, r25	; 0x03
    317e:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    3180:	0f b6       	in	r0, 0x3f	; 63
    3182:	f8 94       	cli
    3184:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3186:	ea 81       	ldd	r30, Y+2	; 0x02
    3188:	fb 81       	ldd	r31, Y+3	; 0x03
    318a:	82 8d       	ldd	r24, Z+26	; 0x1a
    318c:	88 23       	and	r24, r24
    318e:	19 f4       	brne	.+6      	; 0x3196 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    3190:	81 e0       	ldi	r24, 0x01	; 1
    3192:	89 83       	std	Y+1, r24	; 0x01
    3194:	01 c0       	rjmp	.+2      	; 0x3198 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    3196:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    3198:	0f 90       	pop	r0
    319a:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    319c:	89 81       	ldd	r24, Y+1	; 0x01
}
    319e:	0f 90       	pop	r0
    31a0:	0f 90       	pop	r0
    31a2:	0f 90       	pop	r0
    31a4:	cf 91       	pop	r28
    31a6:	df 91       	pop	r29
    31a8:	08 95       	ret

000031aa <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    31aa:	df 93       	push	r29
    31ac:	cf 93       	push	r28
    31ae:	00 d0       	rcall	.+0      	; 0x31b0 <xQueueIsQueueEmptyFromISR+0x6>
    31b0:	00 d0       	rcall	.+0      	; 0x31b2 <xQueueIsQueueEmptyFromISR+0x8>
    31b2:	0f 92       	push	r0
    31b4:	cd b7       	in	r28, 0x3d	; 61
    31b6:	de b7       	in	r29, 0x3e	; 62
    31b8:	9d 83       	std	Y+5, r25	; 0x05
    31ba:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    31bc:	8c 81       	ldd	r24, Y+4	; 0x04
    31be:	9d 81       	ldd	r25, Y+5	; 0x05
    31c0:	9a 83       	std	Y+2, r25	; 0x02
    31c2:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    31c4:	e9 81       	ldd	r30, Y+1	; 0x01
    31c6:	fa 81       	ldd	r31, Y+2	; 0x02
    31c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    31ca:	88 23       	and	r24, r24
    31cc:	19 f4       	brne	.+6      	; 0x31d4 <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    31ce:	81 e0       	ldi	r24, 0x01	; 1
    31d0:	8b 83       	std	Y+3, r24	; 0x03
    31d2:	01 c0       	rjmp	.+2      	; 0x31d6 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    31d4:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    31d6:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    31d8:	0f 90       	pop	r0
    31da:	0f 90       	pop	r0
    31dc:	0f 90       	pop	r0
    31de:	0f 90       	pop	r0
    31e0:	0f 90       	pop	r0
    31e2:	cf 91       	pop	r28
    31e4:	df 91       	pop	r29
    31e6:	08 95       	ret

000031e8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    31e8:	df 93       	push	r29
    31ea:	cf 93       	push	r28
    31ec:	00 d0       	rcall	.+0      	; 0x31ee <prvIsQueueFull+0x6>
    31ee:	0f 92       	push	r0
    31f0:	cd b7       	in	r28, 0x3d	; 61
    31f2:	de b7       	in	r29, 0x3e	; 62
    31f4:	9b 83       	std	Y+3, r25	; 0x03
    31f6:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    31f8:	0f b6       	in	r0, 0x3f	; 63
    31fa:	f8 94       	cli
    31fc:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    31fe:	ea 81       	ldd	r30, Y+2	; 0x02
    3200:	fb 81       	ldd	r31, Y+3	; 0x03
    3202:	92 8d       	ldd	r25, Z+26	; 0x1a
    3204:	ea 81       	ldd	r30, Y+2	; 0x02
    3206:	fb 81       	ldd	r31, Y+3	; 0x03
    3208:	83 8d       	ldd	r24, Z+27	; 0x1b
    320a:	98 17       	cp	r25, r24
    320c:	19 f4       	brne	.+6      	; 0x3214 <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    320e:	81 e0       	ldi	r24, 0x01	; 1
    3210:	89 83       	std	Y+1, r24	; 0x01
    3212:	01 c0       	rjmp	.+2      	; 0x3216 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    3214:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    3216:	0f 90       	pop	r0
    3218:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    321a:	89 81       	ldd	r24, Y+1	; 0x01
}
    321c:	0f 90       	pop	r0
    321e:	0f 90       	pop	r0
    3220:	0f 90       	pop	r0
    3222:	cf 91       	pop	r28
    3224:	df 91       	pop	r29
    3226:	08 95       	ret

00003228 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    3228:	df 93       	push	r29
    322a:	cf 93       	push	r28
    322c:	00 d0       	rcall	.+0      	; 0x322e <xQueueIsQueueFullFromISR+0x6>
    322e:	00 d0       	rcall	.+0      	; 0x3230 <xQueueIsQueueFullFromISR+0x8>
    3230:	0f 92       	push	r0
    3232:	cd b7       	in	r28, 0x3d	; 61
    3234:	de b7       	in	r29, 0x3e	; 62
    3236:	9d 83       	std	Y+5, r25	; 0x05
    3238:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    323a:	8c 81       	ldd	r24, Y+4	; 0x04
    323c:	9d 81       	ldd	r25, Y+5	; 0x05
    323e:	9a 83       	std	Y+2, r25	; 0x02
    3240:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3242:	e9 81       	ldd	r30, Y+1	; 0x01
    3244:	fa 81       	ldd	r31, Y+2	; 0x02
    3246:	92 8d       	ldd	r25, Z+26	; 0x1a
    3248:	e9 81       	ldd	r30, Y+1	; 0x01
    324a:	fa 81       	ldd	r31, Y+2	; 0x02
    324c:	83 8d       	ldd	r24, Z+27	; 0x1b
    324e:	98 17       	cp	r25, r24
    3250:	19 f4       	brne	.+6      	; 0x3258 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    3252:	81 e0       	ldi	r24, 0x01	; 1
    3254:	8b 83       	std	Y+3, r24	; 0x03
    3256:	01 c0       	rjmp	.+2      	; 0x325a <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    3258:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    325a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    325c:	0f 90       	pop	r0
    325e:	0f 90       	pop	r0
    3260:	0f 90       	pop	r0
    3262:	0f 90       	pop	r0
    3264:	0f 90       	pop	r0
    3266:	cf 91       	pop	r28
    3268:	df 91       	pop	r29
    326a:	08 95       	ret

0000326c <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    326c:	8f 92       	push	r8
    326e:	9f 92       	push	r9
    3270:	af 92       	push	r10
    3272:	bf 92       	push	r11
    3274:	cf 92       	push	r12
    3276:	df 92       	push	r13
    3278:	ef 92       	push	r14
    327a:	ff 92       	push	r15
    327c:	0f 93       	push	r16
    327e:	1f 93       	push	r17
    3280:	df 93       	push	r29
    3282:	cf 93       	push	r28
    3284:	cd b7       	in	r28, 0x3d	; 61
    3286:	de b7       	in	r29, 0x3e	; 62
    3288:	60 97       	sbiw	r28, 0x10	; 16
    328a:	0f b6       	in	r0, 0x3f	; 63
    328c:	f8 94       	cli
    328e:	de bf       	out	0x3e, r29	; 62
    3290:	0f be       	out	0x3f, r0	; 63
    3292:	cd bf       	out	0x3d, r28	; 61
    3294:	9f 83       	std	Y+7, r25	; 0x07
    3296:	8e 83       	std	Y+6, r24	; 0x06
    3298:	79 87       	std	Y+9, r23	; 0x09
    329a:	68 87       	std	Y+8, r22	; 0x08
    329c:	5b 87       	std	Y+11, r21	; 0x0b
    329e:	4a 87       	std	Y+10, r20	; 0x0a
    32a0:	3d 87       	std	Y+13, r19	; 0x0d
    32a2:	2c 87       	std	Y+12, r18	; 0x0c
    32a4:	0e 87       	std	Y+14, r16	; 0x0e
    32a6:	f8 8a       	std	Y+16, r15	; 0x10
    32a8:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    32aa:	8a 85       	ldd	r24, Y+10	; 0x0a
    32ac:	9b 85       	ldd	r25, Y+11	; 0x0b
    32ae:	0e 94 17 07 	call	0xe2e	; 0xe2e <pvPortMalloc>
    32b2:	9a 83       	std	Y+2, r25	; 0x02
    32b4:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    32b6:	89 81       	ldd	r24, Y+1	; 0x01
    32b8:	9a 81       	ldd	r25, Y+2	; 0x02
    32ba:	00 97       	sbiw	r24, 0x00	; 0
    32bc:	b1 f0       	breq	.+44     	; 0x32ea <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    32be:	8c e2       	ldi	r24, 0x2C	; 44
    32c0:	90 e0       	ldi	r25, 0x00	; 0
    32c2:	0e 94 17 07 	call	0xe2e	; 0xe2e <pvPortMalloc>
    32c6:	9d 83       	std	Y+5, r25	; 0x05
    32c8:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    32ca:	8c 81       	ldd	r24, Y+4	; 0x04
    32cc:	9d 81       	ldd	r25, Y+5	; 0x05
    32ce:	00 97       	sbiw	r24, 0x00	; 0
    32d0:	39 f0       	breq	.+14     	; 0x32e0 <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    32d2:	ec 81       	ldd	r30, Y+4	; 0x04
    32d4:	fd 81       	ldd	r31, Y+5	; 0x05
    32d6:	89 81       	ldd	r24, Y+1	; 0x01
    32d8:	9a 81       	ldd	r25, Y+2	; 0x02
    32da:	90 8f       	std	Z+24, r25	; 0x18
    32dc:	87 8b       	std	Z+23, r24	; 0x17
    32de:	07 c0       	rjmp	.+14     	; 0x32ee <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
    32e0:	89 81       	ldd	r24, Y+1	; 0x01
    32e2:	9a 81       	ldd	r25, Y+2	; 0x02
    32e4:	0e 94 25 08 	call	0x104a	; 0x104a <vPortFree>
    32e8:	02 c0       	rjmp	.+4      	; 0x32ee <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    32ea:	1d 82       	std	Y+5, r1	; 0x05
    32ec:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    32ee:	8c 81       	ldd	r24, Y+4	; 0x04
    32f0:	9d 81       	ldd	r25, Y+5	; 0x05
    32f2:	00 97       	sbiw	r24, 0x00	; 0
    32f4:	e9 f0       	breq	.+58     	; 0x3330 <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    32f6:	8a 85       	ldd	r24, Y+10	; 0x0a
    32f8:	9b 85       	ldd	r25, Y+11	; 0x0b
    32fa:	9c 01       	movw	r18, r24
    32fc:	40 e0       	ldi	r20, 0x00	; 0
    32fe:	50 e0       	ldi	r21, 0x00	; 0
    3300:	8e 81       	ldd	r24, Y+6	; 0x06
    3302:	9f 81       	ldd	r25, Y+7	; 0x07
    3304:	68 85       	ldd	r22, Y+8	; 0x08
    3306:	79 85       	ldd	r23, Y+9	; 0x09
    3308:	ec 85       	ldd	r30, Y+12	; 0x0c
    330a:	fd 85       	ldd	r31, Y+13	; 0x0d
    330c:	af 85       	ldd	r26, Y+15	; 0x0f
    330e:	b8 89       	ldd	r27, Y+16	; 0x10
    3310:	ac 80       	ldd	r10, Y+4	; 0x04
    3312:	bd 80       	ldd	r11, Y+5	; 0x05
    3314:	8f 01       	movw	r16, r30
    3316:	ee 84       	ldd	r14, Y+14	; 0x0e
    3318:	6d 01       	movw	r12, r26
    331a:	88 24       	eor	r8, r8
    331c:	99 24       	eor	r9, r9
    331e:	0e 94 ae 19 	call	0x335c	; 0x335c <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    3322:	8c 81       	ldd	r24, Y+4	; 0x04
    3324:	9d 81       	ldd	r25, Y+5	; 0x05
    3326:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    332a:	81 e0       	ldi	r24, 0x01	; 1
    332c:	8b 83       	std	Y+3, r24	; 0x03
    332e:	02 c0       	rjmp	.+4      	; 0x3334 <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3330:	8f ef       	ldi	r24, 0xFF	; 255
    3332:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    3334:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3336:	60 96       	adiw	r28, 0x10	; 16
    3338:	0f b6       	in	r0, 0x3f	; 63
    333a:	f8 94       	cli
    333c:	de bf       	out	0x3e, r29	; 62
    333e:	0f be       	out	0x3f, r0	; 63
    3340:	cd bf       	out	0x3d, r28	; 61
    3342:	cf 91       	pop	r28
    3344:	df 91       	pop	r29
    3346:	1f 91       	pop	r17
    3348:	0f 91       	pop	r16
    334a:	ff 90       	pop	r15
    334c:	ef 90       	pop	r14
    334e:	df 90       	pop	r13
    3350:	cf 90       	pop	r12
    3352:	bf 90       	pop	r11
    3354:	af 90       	pop	r10
    3356:	9f 90       	pop	r9
    3358:	8f 90       	pop	r8
    335a:	08 95       	ret

0000335c <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    335c:	8f 92       	push	r8
    335e:	9f 92       	push	r9
    3360:	af 92       	push	r10
    3362:	bf 92       	push	r11
    3364:	cf 92       	push	r12
    3366:	df 92       	push	r13
    3368:	ef 92       	push	r14
    336a:	0f 93       	push	r16
    336c:	1f 93       	push	r17
    336e:	df 93       	push	r29
    3370:	cf 93       	push	r28
    3372:	cd b7       	in	r28, 0x3d	; 61
    3374:	de b7       	in	r29, 0x3e	; 62
    3376:	64 97       	sbiw	r28, 0x14	; 20
    3378:	0f b6       	in	r0, 0x3f	; 63
    337a:	f8 94       	cli
    337c:	de bf       	out	0x3e, r29	; 62
    337e:	0f be       	out	0x3f, r0	; 63
    3380:	cd bf       	out	0x3d, r28	; 61
    3382:	9d 83       	std	Y+5, r25	; 0x05
    3384:	8c 83       	std	Y+4, r24	; 0x04
    3386:	7f 83       	std	Y+7, r23	; 0x07
    3388:	6e 83       	std	Y+6, r22	; 0x06
    338a:	28 87       	std	Y+8, r18	; 0x08
    338c:	39 87       	std	Y+9, r19	; 0x09
    338e:	4a 87       	std	Y+10, r20	; 0x0a
    3390:	5b 87       	std	Y+11, r21	; 0x0b
    3392:	1d 87       	std	Y+13, r17	; 0x0d
    3394:	0c 87       	std	Y+12, r16	; 0x0c
    3396:	ee 86       	std	Y+14, r14	; 0x0e
    3398:	d8 8a       	std	Y+16, r13	; 0x10
    339a:	cf 86       	std	Y+15, r12	; 0x0f
    339c:	ba 8a       	std	Y+18, r11	; 0x12
    339e:	a9 8a       	std	Y+17, r10	; 0x11
    33a0:	9c 8a       	std	Y+20, r9	; 0x14
    33a2:	8b 8a       	std	Y+19, r8	; 0x13

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
        {
            /* Fill the stack with a known value to assist debugging. */
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    33a4:	e9 89       	ldd	r30, Y+17	; 0x11
    33a6:	fa 89       	ldd	r31, Y+18	; 0x12
    33a8:	87 89       	ldd	r24, Z+23	; 0x17
    33aa:	90 8d       	ldd	r25, Z+24	; 0x18
    33ac:	28 85       	ldd	r18, Y+8	; 0x08
    33ae:	39 85       	ldd	r19, Y+9	; 0x09
    33b0:	65 ea       	ldi	r22, 0xA5	; 165
    33b2:	70 e0       	ldi	r23, 0x00	; 0
    33b4:	a9 01       	movw	r20, r18
    33b6:	0e 94 bd 35 	call	0x6b7a	; 0x6b7a <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    33ba:	e9 89       	ldd	r30, Y+17	; 0x11
    33bc:	fa 89       	ldd	r31, Y+18	; 0x12
    33be:	27 89       	ldd	r18, Z+23	; 0x17
    33c0:	30 8d       	ldd	r19, Z+24	; 0x18
    33c2:	88 85       	ldd	r24, Y+8	; 0x08
    33c4:	99 85       	ldd	r25, Y+9	; 0x09
    33c6:	01 97       	sbiw	r24, 0x01	; 1
    33c8:	82 0f       	add	r24, r18
    33ca:	93 1f       	adc	r25, r19
    33cc:	9b 83       	std	Y+3, r25	; 0x03
    33ce:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    33d0:	8e 81       	ldd	r24, Y+6	; 0x06
    33d2:	9f 81       	ldd	r25, Y+7	; 0x07
    33d4:	00 97       	sbiw	r24, 0x00	; 0
    33d6:	51 f1       	breq	.+84     	; 0x342c <prvInitialiseNewTask+0xd0>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    33d8:	19 82       	std	Y+1, r1	; 0x01
    33da:	21 c0       	rjmp	.+66     	; 0x341e <prvInitialiseNewTask+0xc2>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    33dc:	89 81       	ldd	r24, Y+1	; 0x01
    33de:	48 2f       	mov	r20, r24
    33e0:	50 e0       	ldi	r21, 0x00	; 0
    33e2:	89 81       	ldd	r24, Y+1	; 0x01
    33e4:	28 2f       	mov	r18, r24
    33e6:	30 e0       	ldi	r19, 0x00	; 0
    33e8:	8e 81       	ldd	r24, Y+6	; 0x06
    33ea:	9f 81       	ldd	r25, Y+7	; 0x07
    33ec:	fc 01       	movw	r30, r24
    33ee:	e2 0f       	add	r30, r18
    33f0:	f3 1f       	adc	r31, r19
    33f2:	20 81       	ld	r18, Z
    33f4:	89 89       	ldd	r24, Y+17	; 0x11
    33f6:	9a 89       	ldd	r25, Y+18	; 0x12
    33f8:	84 0f       	add	r24, r20
    33fa:	95 1f       	adc	r25, r21
    33fc:	fc 01       	movw	r30, r24
    33fe:	79 96       	adiw	r30, 0x19	; 25
    3400:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    3402:	89 81       	ldd	r24, Y+1	; 0x01
    3404:	28 2f       	mov	r18, r24
    3406:	30 e0       	ldi	r19, 0x00	; 0
    3408:	8e 81       	ldd	r24, Y+6	; 0x06
    340a:	9f 81       	ldd	r25, Y+7	; 0x07
    340c:	fc 01       	movw	r30, r24
    340e:	e2 0f       	add	r30, r18
    3410:	f3 1f       	adc	r31, r19
    3412:	80 81       	ld	r24, Z
    3414:	88 23       	and	r24, r24
    3416:	31 f0       	breq	.+12     	; 0x3424 <prvInitialiseNewTask+0xc8>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3418:	89 81       	ldd	r24, Y+1	; 0x01
    341a:	8f 5f       	subi	r24, 0xFF	; 255
    341c:	89 83       	std	Y+1, r24	; 0x01
    341e:	89 81       	ldd	r24, Y+1	; 0x01
    3420:	8c 30       	cpi	r24, 0x0C	; 12
    3422:	e0 f2       	brcs	.-72     	; 0x33dc <prvInitialiseNewTask+0x80>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3424:	e9 89       	ldd	r30, Y+17	; 0x11
    3426:	fa 89       	ldd	r31, Y+18	; 0x12
    3428:	14 a2       	std	Z+36, r1	; 0x24
    342a:	03 c0       	rjmp	.+6      	; 0x3432 <prvInitialiseNewTask+0xd6>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    342c:	e9 89       	ldd	r30, Y+17	; 0x11
    342e:	fa 89       	ldd	r31, Y+18	; 0x12
    3430:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large.  First
     * remove the privilege bit if one is present. */
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3432:	8e 85       	ldd	r24, Y+14	; 0x0e
    3434:	84 30       	cpi	r24, 0x04	; 4
    3436:	10 f0       	brcs	.+4      	; 0x343c <prvInitialiseNewTask+0xe0>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3438:	83 e0       	ldi	r24, 0x03	; 3
    343a:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    343c:	e9 89       	ldd	r30, Y+17	; 0x11
    343e:	fa 89       	ldd	r31, Y+18	; 0x12
    3440:	8e 85       	ldd	r24, Y+14	; 0x0e
    3442:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3444:	89 89       	ldd	r24, Y+17	; 0x11
    3446:	9a 89       	ldd	r25, Y+18	; 0x12
    3448:	02 96       	adiw	r24, 0x02	; 2
    344a:	0e 94 d5 10 	call	0x21aa	; 0x21aa <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    344e:	89 89       	ldd	r24, Y+17	; 0x11
    3450:	9a 89       	ldd	r25, Y+18	; 0x12
    3452:	0c 96       	adiw	r24, 0x0c	; 12
    3454:	0e 94 d5 10 	call	0x21aa	; 0x21aa <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3458:	e9 89       	ldd	r30, Y+17	; 0x11
    345a:	fa 89       	ldd	r31, Y+18	; 0x12
    345c:	89 89       	ldd	r24, Y+17	; 0x11
    345e:	9a 89       	ldd	r25, Y+18	; 0x12
    3460:	91 87       	std	Z+9, r25	; 0x09
    3462:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3464:	8e 85       	ldd	r24, Y+14	; 0x0e
    3466:	28 2f       	mov	r18, r24
    3468:	30 e0       	ldi	r19, 0x00	; 0
    346a:	84 e0       	ldi	r24, 0x04	; 4
    346c:	90 e0       	ldi	r25, 0x00	; 0
    346e:	82 1b       	sub	r24, r18
    3470:	93 0b       	sbc	r25, r19
    3472:	e9 89       	ldd	r30, Y+17	; 0x11
    3474:	fa 89       	ldd	r31, Y+18	; 0x12
    3476:	95 87       	std	Z+13, r25	; 0x0d
    3478:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    347a:	e9 89       	ldd	r30, Y+17	; 0x11
    347c:	fa 89       	ldd	r31, Y+18	; 0x12
    347e:	89 89       	ldd	r24, Y+17	; 0x11
    3480:	9a 89       	ldd	r25, Y+18	; 0x12
    3482:	93 8b       	std	Z+19, r25	; 0x13
    3484:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    3486:	89 89       	ldd	r24, Y+17	; 0x11
    3488:	9a 89       	ldd	r25, Y+18	; 0x12
    348a:	87 96       	adiw	r24, 0x27	; 39
    348c:	60 e0       	ldi	r22, 0x00	; 0
    348e:	70 e0       	ldi	r23, 0x00	; 0
    3490:	44 e0       	ldi	r20, 0x04	; 4
    3492:	50 e0       	ldi	r21, 0x00	; 0
    3494:	0e 94 bd 35 	call	0x6b7a	; 0x6b7a <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    3498:	89 89       	ldd	r24, Y+17	; 0x11
    349a:	9a 89       	ldd	r25, Y+18	; 0x12
    349c:	8b 96       	adiw	r24, 0x2b	; 43
    349e:	60 e0       	ldi	r22, 0x00	; 0
    34a0:	70 e0       	ldi	r23, 0x00	; 0
    34a2:	41 e0       	ldi	r20, 0x01	; 1
    34a4:	50 e0       	ldi	r21, 0x00	; 0
    34a6:	0e 94 bd 35 	call	0x6b7a	; 0x6b7a <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    34aa:	8a 81       	ldd	r24, Y+2	; 0x02
    34ac:	9b 81       	ldd	r25, Y+3	; 0x03
    34ae:	2c 81       	ldd	r18, Y+4	; 0x04
    34b0:	3d 81       	ldd	r19, Y+5	; 0x05
    34b2:	4c 85       	ldd	r20, Y+12	; 0x0c
    34b4:	5d 85       	ldd	r21, Y+13	; 0x0d
    34b6:	b9 01       	movw	r22, r18
    34b8:	0e 94 5f 0a 	call	0x14be	; 0x14be <pxPortInitialiseStack>
    34bc:	e9 89       	ldd	r30, Y+17	; 0x11
    34be:	fa 89       	ldd	r31, Y+18	; 0x12
    34c0:	91 83       	std	Z+1, r25	; 0x01
    34c2:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    34c4:	8f 85       	ldd	r24, Y+15	; 0x0f
    34c6:	98 89       	ldd	r25, Y+16	; 0x10
    34c8:	00 97       	sbiw	r24, 0x00	; 0
    34ca:	31 f0       	breq	.+12     	; 0x34d8 <prvInitialiseNewTask+0x17c>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    34cc:	ef 85       	ldd	r30, Y+15	; 0x0f
    34ce:	f8 89       	ldd	r31, Y+16	; 0x10
    34d0:	89 89       	ldd	r24, Y+17	; 0x11
    34d2:	9a 89       	ldd	r25, Y+18	; 0x12
    34d4:	91 83       	std	Z+1, r25	; 0x01
    34d6:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    34d8:	64 96       	adiw	r28, 0x14	; 20
    34da:	0f b6       	in	r0, 0x3f	; 63
    34dc:	f8 94       	cli
    34de:	de bf       	out	0x3e, r29	; 62
    34e0:	0f be       	out	0x3f, r0	; 63
    34e2:	cd bf       	out	0x3d, r28	; 61
    34e4:	cf 91       	pop	r28
    34e6:	df 91       	pop	r29
    34e8:	1f 91       	pop	r17
    34ea:	0f 91       	pop	r16
    34ec:	ef 90       	pop	r14
    34ee:	df 90       	pop	r13
    34f0:	cf 90       	pop	r12
    34f2:	bf 90       	pop	r11
    34f4:	af 90       	pop	r10
    34f6:	9f 90       	pop	r9
    34f8:	8f 90       	pop	r8
    34fa:	08 95       	ret

000034fc <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    34fc:	df 93       	push	r29
    34fe:	cf 93       	push	r28
    3500:	00 d0       	rcall	.+0      	; 0x3502 <prvAddNewTaskToReadyList+0x6>
    3502:	cd b7       	in	r28, 0x3d	; 61
    3504:	de b7       	in	r29, 0x3e	; 62
    3506:	9a 83       	std	Y+2, r25	; 0x02
    3508:	89 83       	std	Y+1, r24	; 0x01
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    350a:	0f b6       	in	r0, 0x3f	; 63
    350c:	f8 94       	cli
    350e:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    3510:	80 91 a2 07 	lds	r24, 0x07A2
    3514:	8f 5f       	subi	r24, 0xFF	; 255
    3516:	80 93 a2 07 	sts	0x07A2, r24

        if( pxCurrentTCB == NULL )
    351a:	80 91 a0 07 	lds	r24, 0x07A0
    351e:	90 91 a1 07 	lds	r25, 0x07A1
    3522:	00 97       	sbiw	r24, 0x00	; 0
    3524:	69 f4       	brne	.+26     	; 0x3540 <prvAddNewTaskToReadyList+0x44>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    3526:	89 81       	ldd	r24, Y+1	; 0x01
    3528:	9a 81       	ldd	r25, Y+2	; 0x02
    352a:	90 93 a1 07 	sts	0x07A1, r25
    352e:	80 93 a0 07 	sts	0x07A0, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3532:	80 91 a2 07 	lds	r24, 0x07A2
    3536:	81 30       	cpi	r24, 0x01	; 1
    3538:	b9 f4       	brne	.+46     	; 0x3568 <prvAddNewTaskToReadyList+0x6c>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    353a:	0e 94 a5 22 	call	0x454a	; 0x454a <prvInitialiseTaskLists>
    353e:	14 c0       	rjmp	.+40     	; 0x3568 <prvAddNewTaskToReadyList+0x6c>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    3540:	80 91 a6 07 	lds	r24, 0x07A6
    3544:	88 23       	and	r24, r24
    3546:	81 f4       	brne	.+32     	; 0x3568 <prvAddNewTaskToReadyList+0x6c>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3548:	e0 91 a0 07 	lds	r30, 0x07A0
    354c:	f0 91 a1 07 	lds	r31, 0x07A1
    3550:	96 89       	ldd	r25, Z+22	; 0x16
    3552:	e9 81       	ldd	r30, Y+1	; 0x01
    3554:	fa 81       	ldd	r31, Y+2	; 0x02
    3556:	86 89       	ldd	r24, Z+22	; 0x16
    3558:	89 17       	cp	r24, r25
    355a:	30 f0       	brcs	.+12     	; 0x3568 <prvAddNewTaskToReadyList+0x6c>
                {
                    pxCurrentTCB = pxNewTCB;
    355c:	89 81       	ldd	r24, Y+1	; 0x01
    355e:	9a 81       	ldd	r25, Y+2	; 0x02
    3560:	90 93 a1 07 	sts	0x07A1, r25
    3564:	80 93 a0 07 	sts	0x07A0, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    3568:	80 91 ab 07 	lds	r24, 0x07AB
    356c:	8f 5f       	subi	r24, 0xFF	; 255
    356e:	80 93 ab 07 	sts	0x07AB, r24

        #if ( configUSE_TRACE_FACILITY == 1 )
            {
                /* Add a counter into the TCB for tracing only. */
                pxNewTCB->uxTCBNumber = uxTaskNumber;
    3572:	80 91 ab 07 	lds	r24, 0x07AB
    3576:	e9 81       	ldd	r30, Y+1	; 0x01
    3578:	fa 81       	ldd	r31, Y+2	; 0x02
    357a:	85 a3       	std	Z+37, r24	; 0x25
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    357c:	e9 81       	ldd	r30, Y+1	; 0x01
    357e:	fa 81       	ldd	r31, Y+2	; 0x02
    3580:	96 89       	ldd	r25, Z+22	; 0x16
    3582:	80 91 a5 07 	lds	r24, 0x07A5
    3586:	89 17       	cp	r24, r25
    3588:	28 f4       	brcc	.+10     	; 0x3594 <prvAddNewTaskToReadyList+0x98>
    358a:	e9 81       	ldd	r30, Y+1	; 0x01
    358c:	fa 81       	ldd	r31, Y+2	; 0x02
    358e:	86 89       	ldd	r24, Z+22	; 0x16
    3590:	80 93 a5 07 	sts	0x07A5, r24
    3594:	e9 81       	ldd	r30, Y+1	; 0x01
    3596:	fa 81       	ldd	r31, Y+2	; 0x02
    3598:	86 89       	ldd	r24, Z+22	; 0x16
    359a:	28 2f       	mov	r18, r24
    359c:	30 e0       	ldi	r19, 0x00	; 0
    359e:	c9 01       	movw	r24, r18
    35a0:	88 0f       	add	r24, r24
    35a2:	99 1f       	adc	r25, r25
    35a4:	88 0f       	add	r24, r24
    35a6:	99 1f       	adc	r25, r25
    35a8:	88 0f       	add	r24, r24
    35aa:	99 1f       	adc	r25, r25
    35ac:	82 0f       	add	r24, r18
    35ae:	93 1f       	adc	r25, r19
    35b0:	ac 01       	movw	r20, r24
    35b2:	4f 54       	subi	r20, 0x4F	; 79
    35b4:	58 4f       	sbci	r21, 0xF8	; 248
    35b6:	89 81       	ldd	r24, Y+1	; 0x01
    35b8:	9a 81       	ldd	r25, Y+2	; 0x02
    35ba:	9c 01       	movw	r18, r24
    35bc:	2e 5f       	subi	r18, 0xFE	; 254
    35be:	3f 4f       	sbci	r19, 0xFF	; 255
    35c0:	ca 01       	movw	r24, r20
    35c2:	b9 01       	movw	r22, r18
    35c4:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    35c8:	0f 90       	pop	r0
    35ca:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    35cc:	80 91 a6 07 	lds	r24, 0x07A6
    35d0:	88 23       	and	r24, r24
    35d2:	61 f0       	breq	.+24     	; 0x35ec <prvAddNewTaskToReadyList+0xf0>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    35d4:	e0 91 a0 07 	lds	r30, 0x07A0
    35d8:	f0 91 a1 07 	lds	r31, 0x07A1
    35dc:	96 89       	ldd	r25, Z+22	; 0x16
    35de:	e9 81       	ldd	r30, Y+1	; 0x01
    35e0:	fa 81       	ldd	r31, Y+2	; 0x02
    35e2:	86 89       	ldd	r24, Z+22	; 0x16
    35e4:	98 17       	cp	r25, r24
    35e6:	10 f4       	brcc	.+4      	; 0x35ec <prvAddNewTaskToReadyList+0xf0>
        {
            taskYIELD_IF_USING_PREEMPTION();
    35e8:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    35ec:	0f 90       	pop	r0
    35ee:	0f 90       	pop	r0
    35f0:	cf 91       	pop	r28
    35f2:	df 91       	pop	r29
    35f4:	08 95       	ret

000035f6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    35f6:	df 93       	push	r29
    35f8:	cf 93       	push	r28
    35fa:	00 d0       	rcall	.+0      	; 0x35fc <vTaskDelay+0x6>
    35fc:	0f 92       	push	r0
    35fe:	cd b7       	in	r28, 0x3d	; 61
    3600:	de b7       	in	r29, 0x3e	; 62
    3602:	9b 83       	std	Y+3, r25	; 0x03
    3604:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    3606:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    3608:	8a 81       	ldd	r24, Y+2	; 0x02
    360a:	9b 81       	ldd	r25, Y+3	; 0x03
    360c:	00 97       	sbiw	r24, 0x00	; 0
    360e:	51 f0       	breq	.+20     	; 0x3624 <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    3610:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3614:	8a 81       	ldd	r24, Y+2	; 0x02
    3616:	9b 81       	ldd	r25, Y+3	; 0x03
    3618:	60 e0       	ldi	r22, 0x00	; 0
    361a:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    361e:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
    3622:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3624:	89 81       	ldd	r24, Y+1	; 0x01
    3626:	88 23       	and	r24, r24
    3628:	11 f4       	brne	.+4      	; 0x362e <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    362a:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    362e:	0f 90       	pop	r0
    3630:	0f 90       	pop	r0
    3632:	0f 90       	pop	r0
    3634:	cf 91       	pop	r28
    3636:	df 91       	pop	r29
    3638:	08 95       	ret

0000363a <eTaskGetState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )

    eTaskState eTaskGetState( TaskHandle_t xTask )
    {
    363a:	df 93       	push	r29
    363c:	cf 93       	push	r28
    363e:	cd b7       	in	r28, 0x3d	; 61
    3640:	de b7       	in	r29, 0x3e	; 62
    3642:	2c 97       	sbiw	r28, 0x0c	; 12
    3644:	0f b6       	in	r0, 0x3f	; 63
    3646:	f8 94       	cli
    3648:	de bf       	out	0x3e, r29	; 62
    364a:	0f be       	out	0x3f, r0	; 63
    364c:	cd bf       	out	0x3d, r28	; 61
    364e:	9c 87       	std	Y+12, r25	; 0x0c
    3650:	8b 87       	std	Y+11, r24	; 0x0b
        eTaskState eReturn;
        List_t const * pxStateList, * pxDelayedList, * pxOverflowedDelayedList;
        const TCB_t * const pxTCB = xTask;
    3652:	8b 85       	ldd	r24, Y+11	; 0x0b
    3654:	9c 85       	ldd	r25, Y+12	; 0x0c
    3656:	9b 83       	std	Y+3, r25	; 0x03
    3658:	8a 83       	std	Y+2, r24	; 0x02

        configASSERT( pxTCB );

        if( pxTCB == pxCurrentTCB )
    365a:	20 91 a0 07 	lds	r18, 0x07A0
    365e:	30 91 a1 07 	lds	r19, 0x07A1
    3662:	8a 81       	ldd	r24, Y+2	; 0x02
    3664:	9b 81       	ldd	r25, Y+3	; 0x03
    3666:	82 17       	cp	r24, r18
    3668:	93 07       	cpc	r25, r19
    366a:	11 f4       	brne	.+4      	; 0x3670 <eTaskGetState+0x36>
        {
            /* The task calling this function is querying its own state. */
            eReturn = eRunning;
    366c:	1a 86       	std	Y+10, r1	; 0x0a
    366e:	55 c0       	rjmp	.+170    	; 0x371a <eTaskGetState+0xe0>
        }
        else
        {
            taskENTER_CRITICAL();
    3670:	0f b6       	in	r0, 0x3f	; 63
    3672:	f8 94       	cli
    3674:	0f 92       	push	r0
            {
                pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
    3676:	ea 81       	ldd	r30, Y+2	; 0x02
    3678:	fb 81       	ldd	r31, Y+3	; 0x03
    367a:	82 85       	ldd	r24, Z+10	; 0x0a
    367c:	93 85       	ldd	r25, Z+11	; 0x0b
    367e:	99 87       	std	Y+9, r25	; 0x09
    3680:	88 87       	std	Y+8, r24	; 0x08
                pxDelayedList = pxDelayedTaskList;
    3682:	80 91 e7 07 	lds	r24, 0x07E7
    3686:	90 91 e8 07 	lds	r25, 0x07E8
    368a:	9f 83       	std	Y+7, r25	; 0x07
    368c:	8e 83       	std	Y+6, r24	; 0x06
                pxOverflowedDelayedList = pxOverflowDelayedTaskList;
    368e:	80 91 e9 07 	lds	r24, 0x07E9
    3692:	90 91 ea 07 	lds	r25, 0x07EA
    3696:	9d 83       	std	Y+5, r25	; 0x05
    3698:	8c 83       	std	Y+4, r24	; 0x04
            }
            taskEXIT_CRITICAL();
    369a:	0f 90       	pop	r0
    369c:	0f be       	out	0x3f, r0	; 63

            if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
    369e:	28 85       	ldd	r18, Y+8	; 0x08
    36a0:	39 85       	ldd	r19, Y+9	; 0x09
    36a2:	8e 81       	ldd	r24, Y+6	; 0x06
    36a4:	9f 81       	ldd	r25, Y+7	; 0x07
    36a6:	28 17       	cp	r18, r24
    36a8:	39 07       	cpc	r19, r25
    36aa:	39 f0       	breq	.+14     	; 0x36ba <eTaskGetState+0x80>
    36ac:	28 85       	ldd	r18, Y+8	; 0x08
    36ae:	39 85       	ldd	r19, Y+9	; 0x09
    36b0:	8c 81       	ldd	r24, Y+4	; 0x04
    36b2:	9d 81       	ldd	r25, Y+5	; 0x05
    36b4:	28 17       	cp	r18, r24
    36b6:	39 07       	cpc	r19, r25
    36b8:	19 f4       	brne	.+6      	; 0x36c0 <eTaskGetState+0x86>
            {
                /* The task being queried is referenced from one of the Blocked
                 * lists. */
                eReturn = eBlocked;
    36ba:	82 e0       	ldi	r24, 0x02	; 2
    36bc:	8a 87       	std	Y+10, r24	; 0x0a
    36be:	2d c0       	rjmp	.+90     	; 0x371a <eTaskGetState+0xe0>
            }

            #if ( INCLUDE_vTaskSuspend == 1 )
                else if( pxStateList == &xSuspendedTaskList )
    36c0:	88 85       	ldd	r24, Y+8	; 0x08
    36c2:	99 85       	ldd	r25, Y+9	; 0x09
    36c4:	27 e0       	ldi	r18, 0x07	; 7
    36c6:	84 3f       	cpi	r24, 0xF4	; 244
    36c8:	92 07       	cpc	r25, r18
    36ca:	29 f5       	brne	.+74     	; 0x3716 <eTaskGetState+0xdc>
                {
                    /* The task being queried is referenced from the suspended
                     * list.  Is it genuinely suspended or is it blocked
                     * indefinitely? */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
    36cc:	ea 81       	ldd	r30, Y+2	; 0x02
    36ce:	fb 81       	ldd	r31, Y+3	; 0x03
    36d0:	84 89       	ldd	r24, Z+20	; 0x14
    36d2:	95 89       	ldd	r25, Z+21	; 0x15
    36d4:	00 97       	sbiw	r24, 0x00	; 0
    36d6:	e1 f4       	brne	.+56     	; 0x3710 <eTaskGetState+0xd6>
                                /* The task does not appear on the event list item of
                                 * and of the RTOS objects, but could still be in the
                                 * blocked state if it is waiting on its notification
                                 * rather than waiting on an object.  If not, is
                                 * suspended. */
                                eReturn = eSuspended;
    36d8:	83 e0       	ldi	r24, 0x03	; 3
    36da:	8a 87       	std	Y+10, r24	; 0x0a

                                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
    36dc:	19 82       	std	Y+1, r1	; 0x01
    36de:	14 c0       	rjmp	.+40     	; 0x3708 <eTaskGetState+0xce>
                                {
                                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
    36e0:	89 81       	ldd	r24, Y+1	; 0x01
    36e2:	28 2f       	mov	r18, r24
    36e4:	33 27       	eor	r19, r19
    36e6:	27 fd       	sbrc	r18, 7
    36e8:	30 95       	com	r19
    36ea:	8a 81       	ldd	r24, Y+2	; 0x02
    36ec:	9b 81       	ldd	r25, Y+3	; 0x03
    36ee:	82 0f       	add	r24, r18
    36f0:	93 1f       	adc	r25, r19
    36f2:	fc 01       	movw	r30, r24
    36f4:	bb 96       	adiw	r30, 0x2b	; 43
    36f6:	80 81       	ld	r24, Z
    36f8:	81 30       	cpi	r24, 0x01	; 1
    36fa:	19 f4       	brne	.+6      	; 0x3702 <eTaskGetState+0xc8>
                                    {
                                        eReturn = eBlocked;
    36fc:	82 e0       	ldi	r24, 0x02	; 2
    36fe:	8a 87       	std	Y+10, r24	; 0x0a
    3700:	0c c0       	rjmp	.+24     	; 0x371a <eTaskGetState+0xe0>
                                 * blocked state if it is waiting on its notification
                                 * rather than waiting on an object.  If not, is
                                 * suspended. */
                                eReturn = eSuspended;

                                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
    3702:	89 81       	ldd	r24, Y+1	; 0x01
    3704:	8f 5f       	subi	r24, 0xFF	; 255
    3706:	89 83       	std	Y+1, r24	; 0x01
    3708:	89 81       	ldd	r24, Y+1	; 0x01
    370a:	18 16       	cp	r1, r24
    370c:	4c f7       	brge	.-46     	; 0x36e0 <eTaskGetState+0xa6>
    370e:	05 c0       	rjmp	.+10     	; 0x371a <eTaskGetState+0xe0>
                            }
                        #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
                    }
                    else
                    {
                        eReturn = eBlocked;
    3710:	82 e0       	ldi	r24, 0x02	; 2
    3712:	8a 87       	std	Y+10, r24	; 0x0a
    3714:	02 c0       	rjmp	.+4      	; 0x371a <eTaskGetState+0xe0>

            else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
            {
                /* If the task is not in any other state, it must be in the
                 * Ready (including pending ready) state. */
                eReturn = eReady;
    3716:	81 e0       	ldi	r24, 0x01	; 1
    3718:	8a 87       	std	Y+10, r24	; 0x0a
            }
        }

        return eReturn;
    371a:	8a 85       	ldd	r24, Y+10	; 0x0a
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    371c:	2c 96       	adiw	r28, 0x0c	; 12
    371e:	0f b6       	in	r0, 0x3f	; 63
    3720:	f8 94       	cli
    3722:	de bf       	out	0x3e, r29	; 62
    3724:	0f be       	out	0x3f, r0	; 63
    3726:	cd bf       	out	0x3d, r28	; 61
    3728:	cf 91       	pop	r28
    372a:	df 91       	pop	r29
    372c:	08 95       	ret

0000372e <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
    372e:	df 93       	push	r29
    3730:	cf 93       	push	r28
    3732:	cd b7       	in	r28, 0x3d	; 61
    3734:	de b7       	in	r29, 0x3e	; 62
    3736:	27 97       	sbiw	r28, 0x07	; 7
    3738:	0f b6       	in	r0, 0x3f	; 63
    373a:	f8 94       	cli
    373c:	de bf       	out	0x3e, r29	; 62
    373e:	0f be       	out	0x3f, r0	; 63
    3740:	cd bf       	out	0x3d, r28	; 61
    3742:	9d 83       	std	Y+5, r25	; 0x05
    3744:	8c 83       	std	Y+4, r24	; 0x04
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    3746:	0f b6       	in	r0, 0x3f	; 63
    3748:	f8 94       	cli
    374a:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    374c:	8c 81       	ldd	r24, Y+4	; 0x04
    374e:	9d 81       	ldd	r25, Y+5	; 0x05
    3750:	00 97       	sbiw	r24, 0x00	; 0
    3752:	39 f4       	brne	.+14     	; 0x3762 <vTaskSuspend+0x34>
    3754:	80 91 a0 07 	lds	r24, 0x07A0
    3758:	90 91 a1 07 	lds	r25, 0x07A1
    375c:	9f 83       	std	Y+7, r25	; 0x07
    375e:	8e 83       	std	Y+6, r24	; 0x06
    3760:	04 c0       	rjmp	.+8      	; 0x376a <vTaskSuspend+0x3c>
    3762:	8c 81       	ldd	r24, Y+4	; 0x04
    3764:	9d 81       	ldd	r25, Y+5	; 0x05
    3766:	9f 83       	std	Y+7, r25	; 0x07
    3768:	8e 83       	std	Y+6, r24	; 0x06
    376a:	8e 81       	ldd	r24, Y+6	; 0x06
    376c:	9f 81       	ldd	r25, Y+7	; 0x07
    376e:	9b 83       	std	Y+3, r25	; 0x03
    3770:	8a 83       	std	Y+2, r24	; 0x02

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3772:	8a 81       	ldd	r24, Y+2	; 0x02
    3774:	9b 81       	ldd	r25, Y+3	; 0x03
    3776:	02 96       	adiw	r24, 0x02	; 2
    3778:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    377c:	ea 81       	ldd	r30, Y+2	; 0x02
    377e:	fb 81       	ldd	r31, Y+3	; 0x03
    3780:	84 89       	ldd	r24, Z+20	; 0x14
    3782:	95 89       	ldd	r25, Z+21	; 0x15
    3784:	00 97       	sbiw	r24, 0x00	; 0
    3786:	29 f0       	breq	.+10     	; 0x3792 <vTaskSuspend+0x64>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3788:	8a 81       	ldd	r24, Y+2	; 0x02
    378a:	9b 81       	ldd	r25, Y+3	; 0x03
    378c:	0c 96       	adiw	r24, 0x0c	; 12
    378e:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    3792:	8a 81       	ldd	r24, Y+2	; 0x02
    3794:	9b 81       	ldd	r25, Y+3	; 0x03
    3796:	9c 01       	movw	r18, r24
    3798:	2e 5f       	subi	r18, 0xFE	; 254
    379a:	3f 4f       	sbci	r19, 0xFF	; 255
    379c:	84 ef       	ldi	r24, 0xF4	; 244
    379e:	97 e0       	ldi	r25, 0x07	; 7
    37a0:	b9 01       	movw	r22, r18
    37a2:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>

            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
                {
                    BaseType_t x;

                    for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
    37a6:	19 82       	std	Y+1, r1	; 0x01
    37a8:	1d c0       	rjmp	.+58     	; 0x37e4 <vTaskSuspend+0xb6>
                    {
                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
    37aa:	89 81       	ldd	r24, Y+1	; 0x01
    37ac:	28 2f       	mov	r18, r24
    37ae:	33 27       	eor	r19, r19
    37b0:	27 fd       	sbrc	r18, 7
    37b2:	30 95       	com	r19
    37b4:	8a 81       	ldd	r24, Y+2	; 0x02
    37b6:	9b 81       	ldd	r25, Y+3	; 0x03
    37b8:	82 0f       	add	r24, r18
    37ba:	93 1f       	adc	r25, r19
    37bc:	fc 01       	movw	r30, r24
    37be:	bb 96       	adiw	r30, 0x2b	; 43
    37c0:	80 81       	ld	r24, Z
    37c2:	81 30       	cpi	r24, 0x01	; 1
    37c4:	61 f4       	brne	.+24     	; 0x37de <vTaskSuspend+0xb0>
                        {
                            /* The task was blocked to wait for a notification, but is
                             * now suspended, so no notification was received. */
                            pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
    37c6:	89 81       	ldd	r24, Y+1	; 0x01
    37c8:	28 2f       	mov	r18, r24
    37ca:	33 27       	eor	r19, r19
    37cc:	27 fd       	sbrc	r18, 7
    37ce:	30 95       	com	r19
    37d0:	8a 81       	ldd	r24, Y+2	; 0x02
    37d2:	9b 81       	ldd	r25, Y+3	; 0x03
    37d4:	82 0f       	add	r24, r18
    37d6:	93 1f       	adc	r25, r19
    37d8:	fc 01       	movw	r30, r24
    37da:	bb 96       	adiw	r30, 0x2b	; 43
    37dc:	10 82       	st	Z, r1

            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
                {
                    BaseType_t x;

                    for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
    37de:	89 81       	ldd	r24, Y+1	; 0x01
    37e0:	8f 5f       	subi	r24, 0xFF	; 255
    37e2:	89 83       	std	Y+1, r24	; 0x01
    37e4:	89 81       	ldd	r24, Y+1	; 0x01
    37e6:	18 16       	cp	r1, r24
    37e8:	04 f7       	brge	.-64     	; 0x37aa <vTaskSuspend+0x7c>
                        }
                    }
                }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
    37ea:	0f 90       	pop	r0
    37ec:	0f be       	out	0x3f, r0	; 63

        if( xSchedulerRunning != pdFALSE )
    37ee:	80 91 a6 07 	lds	r24, 0x07A6
    37f2:	88 23       	and	r24, r24
    37f4:	39 f0       	breq	.+14     	; 0x3804 <vTaskSuspend+0xd6>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
    37f6:	0f b6       	in	r0, 0x3f	; 63
    37f8:	f8 94       	cli
    37fa:	0f 92       	push	r0
            {
                prvResetNextTaskUnblockTime();
    37fc:	0e 94 46 24 	call	0x488c	; 0x488c <prvResetNextTaskUnblockTime>
            }
            taskEXIT_CRITICAL();
    3800:	0f 90       	pop	r0
    3802:	0f be       	out	0x3f, r0	; 63
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
    3804:	20 91 a0 07 	lds	r18, 0x07A0
    3808:	30 91 a1 07 	lds	r19, 0x07A1
    380c:	8a 81       	ldd	r24, Y+2	; 0x02
    380e:	9b 81       	ldd	r25, Y+3	; 0x03
    3810:	82 17       	cp	r24, r18
    3812:	93 07       	cpc	r25, r19
    3814:	a1 f4       	brne	.+40     	; 0x383e <vTaskSuspend+0x110>
        {
            if( xSchedulerRunning != pdFALSE )
    3816:	80 91 a6 07 	lds	r24, 0x07A6
    381a:	88 23       	and	r24, r24
    381c:	19 f0       	breq	.+6      	; 0x3824 <vTaskSuspend+0xf6>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    381e:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
    3822:	0d c0       	rjmp	.+26     	; 0x383e <vTaskSuspend+0x110>
            else
            {
                /* The scheduler is not running, but the task that was pointed
                 * to by pxCurrentTCB has just been suspended and pxCurrentTCB
                 * must be adjusted to point to a different task. */
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    3824:	90 91 f4 07 	lds	r25, 0x07F4
    3828:	80 91 a2 07 	lds	r24, 0x07A2
    382c:	98 17       	cp	r25, r24
    382e:	29 f4       	brne	.+10     	; 0x383a <vTaskSuspend+0x10c>
                {
                    /* No other tasks are ready, so set pxCurrentTCB back to
                     * NULL so when the next task is created pxCurrentTCB will
                     * be set to point to it no matter what its relative priority
                     * is. */
                    pxCurrentTCB = NULL;
    3830:	10 92 a1 07 	sts	0x07A1, r1
    3834:	10 92 a0 07 	sts	0x07A0, r1
    3838:	02 c0       	rjmp	.+4      	; 0x383e <vTaskSuspend+0x110>
                }
                else
                {
                    vTaskSwitchContext();
    383a:	0e 94 1e 20 	call	0x403c	; 0x403c <vTaskSwitchContext>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    383e:	27 96       	adiw	r28, 0x07	; 7
    3840:	0f b6       	in	r0, 0x3f	; 63
    3842:	f8 94       	cli
    3844:	de bf       	out	0x3e, r29	; 62
    3846:	0f be       	out	0x3f, r0	; 63
    3848:	cd bf       	out	0x3d, r28	; 61
    384a:	cf 91       	pop	r28
    384c:	df 91       	pop	r29
    384e:	08 95       	ret

00003850 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
    {
    3850:	df 93       	push	r29
    3852:	cf 93       	push	r28
    3854:	00 d0       	rcall	.+0      	; 0x3856 <prvTaskIsTaskSuspended+0x6>
    3856:	00 d0       	rcall	.+0      	; 0x3858 <prvTaskIsTaskSuspended+0x8>
    3858:	0f 92       	push	r0
    385a:	cd b7       	in	r28, 0x3d	; 61
    385c:	de b7       	in	r29, 0x3e	; 62
    385e:	9d 83       	std	Y+5, r25	; 0x05
    3860:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn = pdFALSE;
    3862:	1b 82       	std	Y+3, r1	; 0x03
        const TCB_t * const pxTCB = xTask;
    3864:	8c 81       	ldd	r24, Y+4	; 0x04
    3866:	9d 81       	ldd	r25, Y+5	; 0x05
    3868:	9a 83       	std	Y+2, r25	; 0x02
    386a:	89 83       	std	Y+1, r24	; 0x01

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    386c:	e9 81       	ldd	r30, Y+1	; 0x01
    386e:	fa 81       	ldd	r31, Y+2	; 0x02
    3870:	82 85       	ldd	r24, Z+10	; 0x0a
    3872:	93 85       	ldd	r25, Z+11	; 0x0b
    3874:	27 e0       	ldi	r18, 0x07	; 7
    3876:	84 3f       	cpi	r24, 0xF4	; 244
    3878:	92 07       	cpc	r25, r18
    387a:	81 f4       	brne	.+32     	; 0x389c <prvTaskIsTaskSuspended+0x4c>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    387c:	e9 81       	ldd	r30, Y+1	; 0x01
    387e:	fa 81       	ldd	r31, Y+2	; 0x02
    3880:	84 89       	ldd	r24, Z+20	; 0x14
    3882:	95 89       	ldd	r25, Z+21	; 0x15
    3884:	27 e0       	ldi	r18, 0x07	; 7
    3886:	8b 3e       	cpi	r24, 0xEB	; 235
    3888:	92 07       	cpc	r25, r18
    388a:	41 f0       	breq	.+16     	; 0x389c <prvTaskIsTaskSuspended+0x4c>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    388c:	e9 81       	ldd	r30, Y+1	; 0x01
    388e:	fa 81       	ldd	r31, Y+2	; 0x02
    3890:	84 89       	ldd	r24, Z+20	; 0x14
    3892:	95 89       	ldd	r25, Z+21	; 0x15
    3894:	00 97       	sbiw	r24, 0x00	; 0
    3896:	11 f4       	brne	.+4      	; 0x389c <prvTaskIsTaskSuspended+0x4c>
                {
                    xReturn = pdTRUE;
    3898:	81 e0       	ldi	r24, 0x01	; 1
    389a:	8b 83       	std	Y+3, r24	; 0x03
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    389c:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    389e:	0f 90       	pop	r0
    38a0:	0f 90       	pop	r0
    38a2:	0f 90       	pop	r0
    38a4:	0f 90       	pop	r0
    38a6:	0f 90       	pop	r0
    38a8:	cf 91       	pop	r28
    38aa:	df 91       	pop	r29
    38ac:	08 95       	ret

000038ae <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
    38ae:	df 93       	push	r29
    38b0:	cf 93       	push	r28
    38b2:	00 d0       	rcall	.+0      	; 0x38b4 <vTaskResume+0x6>
    38b4:	00 d0       	rcall	.+0      	; 0x38b6 <vTaskResume+0x8>
    38b6:	cd b7       	in	r28, 0x3d	; 61
    38b8:	de b7       	in	r29, 0x3e	; 62
    38ba:	9c 83       	std	Y+4, r25	; 0x04
    38bc:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * const pxTCB = xTaskToResume;
    38be:	8b 81       	ldd	r24, Y+3	; 0x03
    38c0:	9c 81       	ldd	r25, Y+4	; 0x04
    38c2:	9a 83       	std	Y+2, r25	; 0x02
    38c4:	89 83       	std	Y+1, r24	; 0x01
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    38c6:	20 91 a0 07 	lds	r18, 0x07A0
    38ca:	30 91 a1 07 	lds	r19, 0x07A1
    38ce:	89 81       	ldd	r24, Y+1	; 0x01
    38d0:	9a 81       	ldd	r25, Y+2	; 0x02
    38d2:	82 17       	cp	r24, r18
    38d4:	93 07       	cpc	r25, r19
    38d6:	09 f4       	brne	.+2      	; 0x38da <vTaskResume+0x2c>
    38d8:	47 c0       	rjmp	.+142    	; 0x3968 <vTaskResume+0xba>
    38da:	89 81       	ldd	r24, Y+1	; 0x01
    38dc:	9a 81       	ldd	r25, Y+2	; 0x02
    38de:	00 97       	sbiw	r24, 0x00	; 0
    38e0:	09 f4       	brne	.+2      	; 0x38e4 <vTaskResume+0x36>
    38e2:	42 c0       	rjmp	.+132    	; 0x3968 <vTaskResume+0xba>
        {
            taskENTER_CRITICAL();
    38e4:	0f b6       	in	r0, 0x3f	; 63
    38e6:	f8 94       	cli
    38e8:	0f 92       	push	r0
            {
                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    38ea:	89 81       	ldd	r24, Y+1	; 0x01
    38ec:	9a 81       	ldd	r25, Y+2	; 0x02
    38ee:	0e 94 28 1c 	call	0x3850	; 0x3850 <prvTaskIsTaskSuspended>
    38f2:	88 23       	and	r24, r24
    38f4:	b9 f1       	breq	.+110    	; 0x3964 <vTaskResume+0xb6>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    38f6:	89 81       	ldd	r24, Y+1	; 0x01
    38f8:	9a 81       	ldd	r25, Y+2	; 0x02
    38fa:	02 96       	adiw	r24, 0x02	; 2
    38fc:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    3900:	e9 81       	ldd	r30, Y+1	; 0x01
    3902:	fa 81       	ldd	r31, Y+2	; 0x02
    3904:	96 89       	ldd	r25, Z+22	; 0x16
    3906:	80 91 a5 07 	lds	r24, 0x07A5
    390a:	89 17       	cp	r24, r25
    390c:	28 f4       	brcc	.+10     	; 0x3918 <vTaskResume+0x6a>
    390e:	e9 81       	ldd	r30, Y+1	; 0x01
    3910:	fa 81       	ldd	r31, Y+2	; 0x02
    3912:	86 89       	ldd	r24, Z+22	; 0x16
    3914:	80 93 a5 07 	sts	0x07A5, r24
    3918:	e9 81       	ldd	r30, Y+1	; 0x01
    391a:	fa 81       	ldd	r31, Y+2	; 0x02
    391c:	86 89       	ldd	r24, Z+22	; 0x16
    391e:	28 2f       	mov	r18, r24
    3920:	30 e0       	ldi	r19, 0x00	; 0
    3922:	c9 01       	movw	r24, r18
    3924:	88 0f       	add	r24, r24
    3926:	99 1f       	adc	r25, r25
    3928:	88 0f       	add	r24, r24
    392a:	99 1f       	adc	r25, r25
    392c:	88 0f       	add	r24, r24
    392e:	99 1f       	adc	r25, r25
    3930:	82 0f       	add	r24, r18
    3932:	93 1f       	adc	r25, r19
    3934:	ac 01       	movw	r20, r24
    3936:	4f 54       	subi	r20, 0x4F	; 79
    3938:	58 4f       	sbci	r21, 0xF8	; 248
    393a:	89 81       	ldd	r24, Y+1	; 0x01
    393c:	9a 81       	ldd	r25, Y+2	; 0x02
    393e:	9c 01       	movw	r18, r24
    3940:	2e 5f       	subi	r18, 0xFE	; 254
    3942:	3f 4f       	sbci	r19, 0xFF	; 255
    3944:	ca 01       	movw	r24, r20
    3946:	b9 01       	movw	r22, r18
    3948:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    394c:	e9 81       	ldd	r30, Y+1	; 0x01
    394e:	fa 81       	ldd	r31, Y+2	; 0x02
    3950:	96 89       	ldd	r25, Z+22	; 0x16
    3952:	e0 91 a0 07 	lds	r30, 0x07A0
    3956:	f0 91 a1 07 	lds	r31, 0x07A1
    395a:	86 89       	ldd	r24, Z+22	; 0x16
    395c:	98 17       	cp	r25, r24
    395e:	10 f0       	brcs	.+4      	; 0x3964 <vTaskResume+0xb6>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
    3960:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    3964:	0f 90       	pop	r0
    3966:	0f be       	out	0x3f, r0	; 63
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    3968:	0f 90       	pop	r0
    396a:	0f 90       	pop	r0
    396c:	0f 90       	pop	r0
    396e:	0f 90       	pop	r0
    3970:	cf 91       	pop	r28
    3972:	df 91       	pop	r29
    3974:	08 95       	ret

00003976 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
    3976:	df 93       	push	r29
    3978:	cf 93       	push	r28
    397a:	00 d0       	rcall	.+0      	; 0x397c <xTaskResumeFromISR+0x6>
    397c:	00 d0       	rcall	.+0      	; 0x397e <xTaskResumeFromISR+0x8>
    397e:	00 d0       	rcall	.+0      	; 0x3980 <xTaskResumeFromISR+0xa>
    3980:	cd b7       	in	r28, 0x3d	; 61
    3982:	de b7       	in	r29, 0x3e	; 62
    3984:	9e 83       	std	Y+6, r25	; 0x06
    3986:	8d 83       	std	Y+5, r24	; 0x05
        BaseType_t xYieldRequired = pdFALSE;
    3988:	1c 82       	std	Y+4, r1	; 0x04
        TCB_t * const pxTCB = xTaskToResume;
    398a:	8d 81       	ldd	r24, Y+5	; 0x05
    398c:	9e 81       	ldd	r25, Y+6	; 0x06
    398e:	9b 83       	std	Y+3, r25	; 0x03
    3990:	8a 83       	std	Y+2, r24	; 0x02
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3992:	19 82       	std	Y+1, r1	; 0x01
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3994:	8a 81       	ldd	r24, Y+2	; 0x02
    3996:	9b 81       	ldd	r25, Y+3	; 0x03
    3998:	0e 94 28 1c 	call	0x3850	; 0x3850 <prvTaskIsTaskSuspended>
    399c:	88 23       	and	r24, r24
    399e:	09 f4       	brne	.+2      	; 0x39a2 <xTaskResumeFromISR+0x2c>
    39a0:	49 c0       	rjmp	.+146    	; 0x3a34 <xTaskResumeFromISR+0xbe>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    39a2:	80 91 b0 07 	lds	r24, 0x07B0
    39a6:	88 23       	and	r24, r24
    39a8:	d9 f5       	brne	.+118    	; 0x3a20 <xTaskResumeFromISR+0xaa>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    39aa:	ea 81       	ldd	r30, Y+2	; 0x02
    39ac:	fb 81       	ldd	r31, Y+3	; 0x03
    39ae:	96 89       	ldd	r25, Z+22	; 0x16
    39b0:	e0 91 a0 07 	lds	r30, 0x07A0
    39b4:	f0 91 a1 07 	lds	r31, 0x07A1
    39b8:	86 89       	ldd	r24, Z+22	; 0x16
    39ba:	98 17       	cp	r25, r24
    39bc:	28 f0       	brcs	.+10     	; 0x39c8 <xTaskResumeFromISR+0x52>
                    {
                        xYieldRequired = pdTRUE;
    39be:	81 e0       	ldi	r24, 0x01	; 1
    39c0:	8c 83       	std	Y+4, r24	; 0x04

                        /* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR. */
                        xYieldPending = pdTRUE;
    39c2:	81 e0       	ldi	r24, 0x01	; 1
    39c4:	80 93 a9 07 	sts	0x07A9, r24
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    39c8:	8a 81       	ldd	r24, Y+2	; 0x02
    39ca:	9b 81       	ldd	r25, Y+3	; 0x03
    39cc:	02 96       	adiw	r24, 0x02	; 2
    39ce:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    39d2:	ea 81       	ldd	r30, Y+2	; 0x02
    39d4:	fb 81       	ldd	r31, Y+3	; 0x03
    39d6:	96 89       	ldd	r25, Z+22	; 0x16
    39d8:	80 91 a5 07 	lds	r24, 0x07A5
    39dc:	89 17       	cp	r24, r25
    39de:	28 f4       	brcc	.+10     	; 0x39ea <xTaskResumeFromISR+0x74>
    39e0:	ea 81       	ldd	r30, Y+2	; 0x02
    39e2:	fb 81       	ldd	r31, Y+3	; 0x03
    39e4:	86 89       	ldd	r24, Z+22	; 0x16
    39e6:	80 93 a5 07 	sts	0x07A5, r24
    39ea:	ea 81       	ldd	r30, Y+2	; 0x02
    39ec:	fb 81       	ldd	r31, Y+3	; 0x03
    39ee:	86 89       	ldd	r24, Z+22	; 0x16
    39f0:	28 2f       	mov	r18, r24
    39f2:	30 e0       	ldi	r19, 0x00	; 0
    39f4:	c9 01       	movw	r24, r18
    39f6:	88 0f       	add	r24, r24
    39f8:	99 1f       	adc	r25, r25
    39fa:	88 0f       	add	r24, r24
    39fc:	99 1f       	adc	r25, r25
    39fe:	88 0f       	add	r24, r24
    3a00:	99 1f       	adc	r25, r25
    3a02:	82 0f       	add	r24, r18
    3a04:	93 1f       	adc	r25, r19
    3a06:	ac 01       	movw	r20, r24
    3a08:	4f 54       	subi	r20, 0x4F	; 79
    3a0a:	58 4f       	sbci	r21, 0xF8	; 248
    3a0c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a0e:	9b 81       	ldd	r25, Y+3	; 0x03
    3a10:	9c 01       	movw	r18, r24
    3a12:	2e 5f       	subi	r18, 0xFE	; 254
    3a14:	3f 4f       	sbci	r19, 0xFF	; 255
    3a16:	ca 01       	movw	r24, r20
    3a18:	b9 01       	movw	r22, r18
    3a1a:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
    3a1e:	0a c0       	rjmp	.+20     	; 0x3a34 <xTaskResumeFromISR+0xbe>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3a20:	8a 81       	ldd	r24, Y+2	; 0x02
    3a22:	9b 81       	ldd	r25, Y+3	; 0x03
    3a24:	9c 01       	movw	r18, r24
    3a26:	24 5f       	subi	r18, 0xF4	; 244
    3a28:	3f 4f       	sbci	r19, 0xFF	; 255
    3a2a:	8b ee       	ldi	r24, 0xEB	; 235
    3a2c:	97 e0       	ldi	r25, 0x07	; 7
    3a2e:	b9 01       	movw	r22, r18
    3a30:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
    3a34:	8c 81       	ldd	r24, Y+4	; 0x04
    }
    3a36:	26 96       	adiw	r28, 0x06	; 6
    3a38:	0f b6       	in	r0, 0x3f	; 63
    3a3a:	f8 94       	cli
    3a3c:	de bf       	out	0x3e, r29	; 62
    3a3e:	0f be       	out	0x3f, r0	; 63
    3a40:	cd bf       	out	0x3d, r28	; 61
    3a42:	cf 91       	pop	r28
    3a44:	df 91       	pop	r29
    3a46:	08 95       	ret

00003a48 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3a48:	ef 92       	push	r14
    3a4a:	ff 92       	push	r15
    3a4c:	0f 93       	push	r16
    3a4e:	df 93       	push	r29
    3a50:	cf 93       	push	r28
    3a52:	00 d0       	rcall	.+0      	; 0x3a54 <vTaskStartScheduler+0xc>
    3a54:	cd b7       	in	r28, 0x3d	; 61
    3a56:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    3a58:	85 e9       	ldi	r24, 0x95	; 149
    3a5a:	92 e2       	ldi	r25, 0x22	; 34
    3a5c:	20 e6       	ldi	r18, 0x60	; 96
    3a5e:	30 e0       	ldi	r19, 0x00	; 0
    3a60:	ee ea       	ldi	r30, 0xAE	; 174
    3a62:	f7 e0       	ldi	r31, 0x07	; 7
    3a64:	b9 01       	movw	r22, r18
    3a66:	45 e5       	ldi	r20, 0x55	; 85
    3a68:	50 e0       	ldi	r21, 0x00	; 0
    3a6a:	20 e0       	ldi	r18, 0x00	; 0
    3a6c:	30 e0       	ldi	r19, 0x00	; 0
    3a6e:	00 e0       	ldi	r16, 0x00	; 0
    3a70:	7f 01       	movw	r14, r30
    3a72:	0e 94 36 19 	call	0x326c	; 0x326c <xTaskCreate>
    3a76:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    3a78:	89 81       	ldd	r24, Y+1	; 0x01
    3a7a:	81 30       	cpi	r24, 0x01	; 1
    3a7c:	81 f4       	brne	.+32     	; 0x3a9e <vTaskStartScheduler+0x56>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    3a7e:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    3a80:	8f ef       	ldi	r24, 0xFF	; 255
    3a82:	9f ef       	ldi	r25, 0xFF	; 255
    3a84:	90 93 ad 07 	sts	0x07AD, r25
    3a88:	80 93 ac 07 	sts	0x07AC, r24
        xSchedulerRunning = pdTRUE;
    3a8c:	81 e0       	ldi	r24, 0x01	; 1
    3a8e:	80 93 a6 07 	sts	0x07A6, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    3a92:	10 92 a4 07 	sts	0x07A4, r1
    3a96:	10 92 a3 07 	sts	0x07A3, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    3a9a:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    3a9e:	80 91 b1 01 	lds	r24, 0x01B1
}
    3aa2:	0f 90       	pop	r0
    3aa4:	0f 90       	pop	r0
    3aa6:	cf 91       	pop	r28
    3aa8:	df 91       	pop	r29
    3aaa:	0f 91       	pop	r16
    3aac:	ff 90       	pop	r15
    3aae:	ef 90       	pop	r14
    3ab0:	08 95       	ret

00003ab2 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3ab2:	df 93       	push	r29
    3ab4:	cf 93       	push	r28
    3ab6:	cd b7       	in	r28, 0x3d	; 61
    3ab8:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    3aba:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    3abc:	10 92 a6 07 	sts	0x07A6, r1
    vPortEndScheduler();
    3ac0:	0e 94 17 0c 	call	0x182e	; 0x182e <vPortEndScheduler>
}
    3ac4:	cf 91       	pop	r28
    3ac6:	df 91       	pop	r29
    3ac8:	08 95       	ret

00003aca <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3aca:	df 93       	push	r29
    3acc:	cf 93       	push	r28
    3ace:	cd b7       	in	r28, 0x3d	; 61
    3ad0:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    3ad2:	80 91 b0 07 	lds	r24, 0x07B0
    3ad6:	8f 5f       	subi	r24, 0xFF	; 255
    3ad8:	80 93 b0 07 	sts	0x07B0, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    3adc:	cf 91       	pop	r28
    3ade:	df 91       	pop	r29
    3ae0:	08 95       	ret

00003ae2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3ae2:	df 93       	push	r29
    3ae4:	cf 93       	push	r28
    3ae6:	00 d0       	rcall	.+0      	; 0x3ae8 <xTaskResumeAll+0x6>
    3ae8:	00 d0       	rcall	.+0      	; 0x3aea <xTaskResumeAll+0x8>
    3aea:	0f 92       	push	r0
    3aec:	cd b7       	in	r28, 0x3d	; 61
    3aee:	de b7       	in	r29, 0x3e	; 62
    TCB_t * pxTCB = NULL;
    3af0:	1d 82       	std	Y+5, r1	; 0x05
    3af2:	1c 82       	std	Y+4, r1	; 0x04
    BaseType_t xAlreadyYielded = pdFALSE;
    3af4:	1b 82       	std	Y+3, r1	; 0x03
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    3af6:	0f b6       	in	r0, 0x3f	; 63
    3af8:	f8 94       	cli
    3afa:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    3afc:	80 91 b0 07 	lds	r24, 0x07B0
    3b00:	81 50       	subi	r24, 0x01	; 1
    3b02:	80 93 b0 07 	sts	0x07B0, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3b06:	80 91 b0 07 	lds	r24, 0x07B0
    3b0a:	88 23       	and	r24, r24
    3b0c:	09 f0       	breq	.+2      	; 0x3b10 <xTaskResumeAll+0x2e>
    3b0e:	7c c0       	rjmp	.+248    	; 0x3c08 <xTaskResumeAll+0x126>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3b10:	80 91 a2 07 	lds	r24, 0x07A2
    3b14:	88 23       	and	r24, r24
    3b16:	09 f4       	brne	.+2      	; 0x3b1a <xTaskResumeAll+0x38>
    3b18:	77 c0       	rjmp	.+238    	; 0x3c08 <xTaskResumeAll+0x126>
    3b1a:	45 c0       	rjmp	.+138    	; 0x3ba6 <xTaskResumeAll+0xc4>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3b1c:	e0 91 f0 07 	lds	r30, 0x07F0
    3b20:	f0 91 f1 07 	lds	r31, 0x07F1
    3b24:	86 81       	ldd	r24, Z+6	; 0x06
    3b26:	97 81       	ldd	r25, Z+7	; 0x07
    3b28:	9d 83       	std	Y+5, r25	; 0x05
    3b2a:	8c 83       	std	Y+4, r24	; 0x04
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3b2c:	8c 81       	ldd	r24, Y+4	; 0x04
    3b2e:	9d 81       	ldd	r25, Y+5	; 0x05
    3b30:	0c 96       	adiw	r24, 0x0c	; 12
    3b32:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3b36:	8c 81       	ldd	r24, Y+4	; 0x04
    3b38:	9d 81       	ldd	r25, Y+5	; 0x05
    3b3a:	02 96       	adiw	r24, 0x02	; 2
    3b3c:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    3b40:	ec 81       	ldd	r30, Y+4	; 0x04
    3b42:	fd 81       	ldd	r31, Y+5	; 0x05
    3b44:	96 89       	ldd	r25, Z+22	; 0x16
    3b46:	80 91 a5 07 	lds	r24, 0x07A5
    3b4a:	89 17       	cp	r24, r25
    3b4c:	28 f4       	brcc	.+10     	; 0x3b58 <xTaskResumeAll+0x76>
    3b4e:	ec 81       	ldd	r30, Y+4	; 0x04
    3b50:	fd 81       	ldd	r31, Y+5	; 0x05
    3b52:	86 89       	ldd	r24, Z+22	; 0x16
    3b54:	80 93 a5 07 	sts	0x07A5, r24
    3b58:	ec 81       	ldd	r30, Y+4	; 0x04
    3b5a:	fd 81       	ldd	r31, Y+5	; 0x05
    3b5c:	86 89       	ldd	r24, Z+22	; 0x16
    3b5e:	28 2f       	mov	r18, r24
    3b60:	30 e0       	ldi	r19, 0x00	; 0
    3b62:	c9 01       	movw	r24, r18
    3b64:	88 0f       	add	r24, r24
    3b66:	99 1f       	adc	r25, r25
    3b68:	88 0f       	add	r24, r24
    3b6a:	99 1f       	adc	r25, r25
    3b6c:	88 0f       	add	r24, r24
    3b6e:	99 1f       	adc	r25, r25
    3b70:	82 0f       	add	r24, r18
    3b72:	93 1f       	adc	r25, r19
    3b74:	ac 01       	movw	r20, r24
    3b76:	4f 54       	subi	r20, 0x4F	; 79
    3b78:	58 4f       	sbci	r21, 0xF8	; 248
    3b7a:	8c 81       	ldd	r24, Y+4	; 0x04
    3b7c:	9d 81       	ldd	r25, Y+5	; 0x05
    3b7e:	9c 01       	movw	r18, r24
    3b80:	2e 5f       	subi	r18, 0xFE	; 254
    3b82:	3f 4f       	sbci	r19, 0xFF	; 255
    3b84:	ca 01       	movw	r24, r20
    3b86:	b9 01       	movw	r22, r18
    3b88:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3b8c:	ec 81       	ldd	r30, Y+4	; 0x04
    3b8e:	fd 81       	ldd	r31, Y+5	; 0x05
    3b90:	96 89       	ldd	r25, Z+22	; 0x16
    3b92:	e0 91 a0 07 	lds	r30, 0x07A0
    3b96:	f0 91 a1 07 	lds	r31, 0x07A1
    3b9a:	86 89       	ldd	r24, Z+22	; 0x16
    3b9c:	98 17       	cp	r25, r24
    3b9e:	18 f0       	brcs	.+6      	; 0x3ba6 <xTaskResumeAll+0xc4>
                    {
                        xYieldPending = pdTRUE;
    3ba0:	81 e0       	ldi	r24, 0x01	; 1
    3ba2:	80 93 a9 07 	sts	0x07A9, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3ba6:	80 91 eb 07 	lds	r24, 0x07EB
    3baa:	88 23       	and	r24, r24
    3bac:	09 f0       	breq	.+2      	; 0x3bb0 <xTaskResumeAll+0xce>
    3bae:	b6 cf       	rjmp	.-148    	; 0x3b1c <xTaskResumeAll+0x3a>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    3bb0:	8c 81       	ldd	r24, Y+4	; 0x04
    3bb2:	9d 81       	ldd	r25, Y+5	; 0x05
    3bb4:	00 97       	sbiw	r24, 0x00	; 0
    3bb6:	11 f0       	breq	.+4      	; 0x3bbc <xTaskResumeAll+0xda>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    3bb8:	0e 94 46 24 	call	0x488c	; 0x488c <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3bbc:	80 91 a7 07 	lds	r24, 0x07A7
    3bc0:	90 91 a8 07 	lds	r25, 0x07A8
    3bc4:	9a 83       	std	Y+2, r25	; 0x02
    3bc6:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    3bc8:	89 81       	ldd	r24, Y+1	; 0x01
    3bca:	9a 81       	ldd	r25, Y+2	; 0x02
    3bcc:	00 97       	sbiw	r24, 0x00	; 0
    3bce:	a1 f0       	breq	.+40     	; 0x3bf8 <xTaskResumeAll+0x116>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    3bd0:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <xTaskIncrementTick>
    3bd4:	88 23       	and	r24, r24
    3bd6:	19 f0       	breq	.+6      	; 0x3bde <xTaskResumeAll+0xfc>
                            {
                                xYieldPending = pdTRUE;
    3bd8:	81 e0       	ldi	r24, 0x01	; 1
    3bda:	80 93 a9 07 	sts	0x07A9, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    3bde:	89 81       	ldd	r24, Y+1	; 0x01
    3be0:	9a 81       	ldd	r25, Y+2	; 0x02
    3be2:	01 97       	sbiw	r24, 0x01	; 1
    3be4:	9a 83       	std	Y+2, r25	; 0x02
    3be6:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    3be8:	89 81       	ldd	r24, Y+1	; 0x01
    3bea:	9a 81       	ldd	r25, Y+2	; 0x02
    3bec:	00 97       	sbiw	r24, 0x00	; 0
    3bee:	81 f7       	brne	.-32     	; 0x3bd0 <xTaskResumeAll+0xee>

                        xPendedTicks = 0;
    3bf0:	10 92 a8 07 	sts	0x07A8, r1
    3bf4:	10 92 a7 07 	sts	0x07A7, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    3bf8:	80 91 a9 07 	lds	r24, 0x07A9
    3bfc:	88 23       	and	r24, r24
    3bfe:	21 f0       	breq	.+8      	; 0x3c08 <xTaskResumeAll+0x126>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    3c00:	81 e0       	ldi	r24, 0x01	; 1
    3c02:	8b 83       	std	Y+3, r24	; 0x03
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    3c04:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    3c08:	0f 90       	pop	r0
    3c0a:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    3c0c:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3c0e:	0f 90       	pop	r0
    3c10:	0f 90       	pop	r0
    3c12:	0f 90       	pop	r0
    3c14:	0f 90       	pop	r0
    3c16:	0f 90       	pop	r0
    3c18:	cf 91       	pop	r28
    3c1a:	df 91       	pop	r29
    3c1c:	08 95       	ret

00003c1e <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3c1e:	df 93       	push	r29
    3c20:	cf 93       	push	r28
    3c22:	00 d0       	rcall	.+0      	; 0x3c24 <xTaskGetTickCount+0x6>
    3c24:	cd b7       	in	r28, 0x3d	; 61
    3c26:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    3c28:	0f b6       	in	r0, 0x3f	; 63
    3c2a:	f8 94       	cli
    3c2c:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    3c2e:	80 91 a3 07 	lds	r24, 0x07A3
    3c32:	90 91 a4 07 	lds	r25, 0x07A4
    3c36:	9a 83       	std	Y+2, r25	; 0x02
    3c38:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    3c3a:	0f 90       	pop	r0
    3c3c:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    3c3e:	89 81       	ldd	r24, Y+1	; 0x01
    3c40:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3c42:	0f 90       	pop	r0
    3c44:	0f 90       	pop	r0
    3c46:	cf 91       	pop	r28
    3c48:	df 91       	pop	r29
    3c4a:	08 95       	ret

00003c4c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3c4c:	df 93       	push	r29
    3c4e:	cf 93       	push	r28
    3c50:	00 d0       	rcall	.+0      	; 0x3c52 <xTaskGetTickCountFromISR+0x6>
    3c52:	0f 92       	push	r0
    3c54:	cd b7       	in	r28, 0x3d	; 61
    3c56:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3c58:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    3c5a:	80 91 a3 07 	lds	r24, 0x07A3
    3c5e:	90 91 a4 07 	lds	r25, 0x07A4
    3c62:	9b 83       	std	Y+3, r25	; 0x03
    3c64:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3c66:	8a 81       	ldd	r24, Y+2	; 0x02
    3c68:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3c6a:	0f 90       	pop	r0
    3c6c:	0f 90       	pop	r0
    3c6e:	0f 90       	pop	r0
    3c70:	cf 91       	pop	r28
    3c72:	df 91       	pop	r29
    3c74:	08 95       	ret

00003c76 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3c76:	df 93       	push	r29
    3c78:	cf 93       	push	r28
    3c7a:	cd b7       	in	r28, 0x3d	; 61
    3c7c:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    3c7e:	80 91 a2 07 	lds	r24, 0x07A2
}
    3c82:	cf 91       	pop	r28
    3c84:	df 91       	pop	r29
    3c86:	08 95       	ret

00003c88 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3c88:	df 93       	push	r29
    3c8a:	cf 93       	push	r28
    3c8c:	00 d0       	rcall	.+0      	; 0x3c8e <pcTaskGetName+0x6>
    3c8e:	00 d0       	rcall	.+0      	; 0x3c90 <pcTaskGetName+0x8>
    3c90:	00 d0       	rcall	.+0      	; 0x3c92 <pcTaskGetName+0xa>
    3c92:	cd b7       	in	r28, 0x3d	; 61
    3c94:	de b7       	in	r29, 0x3e	; 62
    3c96:	9c 83       	std	Y+4, r25	; 0x04
    3c98:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3c9a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c9c:	9c 81       	ldd	r25, Y+4	; 0x04
    3c9e:	00 97       	sbiw	r24, 0x00	; 0
    3ca0:	39 f4       	brne	.+14     	; 0x3cb0 <pcTaskGetName+0x28>
    3ca2:	80 91 a0 07 	lds	r24, 0x07A0
    3ca6:	90 91 a1 07 	lds	r25, 0x07A1
    3caa:	9e 83       	std	Y+6, r25	; 0x06
    3cac:	8d 83       	std	Y+5, r24	; 0x05
    3cae:	04 c0       	rjmp	.+8      	; 0x3cb8 <pcTaskGetName+0x30>
    3cb0:	8b 81       	ldd	r24, Y+3	; 0x03
    3cb2:	9c 81       	ldd	r25, Y+4	; 0x04
    3cb4:	9e 83       	std	Y+6, r25	; 0x06
    3cb6:	8d 83       	std	Y+5, r24	; 0x05
    3cb8:	8d 81       	ldd	r24, Y+5	; 0x05
    3cba:	9e 81       	ldd	r25, Y+6	; 0x06
    3cbc:	9a 83       	std	Y+2, r25	; 0x02
    3cbe:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    3cc0:	89 81       	ldd	r24, Y+1	; 0x01
    3cc2:	9a 81       	ldd	r25, Y+2	; 0x02
    3cc4:	49 96       	adiw	r24, 0x19	; 25
}
    3cc6:	26 96       	adiw	r28, 0x06	; 6
    3cc8:	0f b6       	in	r0, 0x3f	; 63
    3cca:	f8 94       	cli
    3ccc:	de bf       	out	0x3e, r29	; 62
    3cce:	0f be       	out	0x3f, r0	; 63
    3cd0:	cd bf       	out	0x3d, r28	; 61
    3cd2:	cf 91       	pop	r28
    3cd4:	df 91       	pop	r29
    3cd6:	08 95       	ret

00003cd8 <uxTaskGetSystemState>:
#if ( configUSE_TRACE_FACILITY == 1 )

    UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
                                      const UBaseType_t uxArraySize,
                                      uint32_t * const pulTotalRunTime )
    {
    3cd8:	df 93       	push	r29
    3cda:	cf 93       	push	r28
    3cdc:	cd b7       	in	r28, 0x3d	; 61
    3cde:	de b7       	in	r29, 0x3e	; 62
    3ce0:	27 97       	sbiw	r28, 0x07	; 7
    3ce2:	0f b6       	in	r0, 0x3f	; 63
    3ce4:	f8 94       	cli
    3ce6:	de bf       	out	0x3e, r29	; 62
    3ce8:	0f be       	out	0x3f, r0	; 63
    3cea:	cd bf       	out	0x3d, r28	; 61
    3cec:	9c 83       	std	Y+4, r25	; 0x04
    3cee:	8b 83       	std	Y+3, r24	; 0x03
    3cf0:	6d 83       	std	Y+5, r22	; 0x05
    3cf2:	5f 83       	std	Y+7, r21	; 0x07
    3cf4:	4e 83       	std	Y+6, r20	; 0x06
        UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
    3cf6:	1a 82       	std	Y+2, r1	; 0x02
    3cf8:	84 e0       	ldi	r24, 0x04	; 4
    3cfa:	89 83       	std	Y+1, r24	; 0x01

        vTaskSuspendAll();
    3cfc:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
        {
            /* Is there a space in the array for each task in the system? */
            if( uxArraySize >= uxCurrentNumberOfTasks )
    3d00:	90 91 a2 07 	lds	r25, 0x07A2
    3d04:	8d 81       	ldd	r24, Y+5	; 0x05
    3d06:	89 17       	cp	r24, r25
    3d08:	08 f4       	brcc	.+2      	; 0x3d0c <uxTaskGetSystemState+0x34>
    3d0a:	83 c0       	rjmp	.+262    	; 0x3e12 <uxTaskGetSystemState+0x13a>
            {
                /* Fill in an TaskStatus_t structure with information on each
                 * task in the Ready state. */
                do
                {
                    uxQueue--;
    3d0c:	89 81       	ldd	r24, Y+1	; 0x01
    3d0e:	81 50       	subi	r24, 0x01	; 1
    3d10:	89 83       	std	Y+1, r24	; 0x01
                    uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
    3d12:	8a 81       	ldd	r24, Y+2	; 0x02
    3d14:	88 2f       	mov	r24, r24
    3d16:	90 e0       	ldi	r25, 0x00	; 0
    3d18:	9c 01       	movw	r18, r24
    3d1a:	22 95       	swap	r18
    3d1c:	32 95       	swap	r19
    3d1e:	30 7f       	andi	r19, 0xF0	; 240
    3d20:	32 27       	eor	r19, r18
    3d22:	20 7f       	andi	r18, 0xF0	; 240
    3d24:	32 27       	eor	r19, r18
    3d26:	8b 81       	ldd	r24, Y+3	; 0x03
    3d28:	9c 81       	ldd	r25, Y+4	; 0x04
    3d2a:	ac 01       	movw	r20, r24
    3d2c:	42 0f       	add	r20, r18
    3d2e:	53 1f       	adc	r21, r19
    3d30:	89 81       	ldd	r24, Y+1	; 0x01
    3d32:	28 2f       	mov	r18, r24
    3d34:	30 e0       	ldi	r19, 0x00	; 0
    3d36:	c9 01       	movw	r24, r18
    3d38:	88 0f       	add	r24, r24
    3d3a:	99 1f       	adc	r25, r25
    3d3c:	88 0f       	add	r24, r24
    3d3e:	99 1f       	adc	r25, r25
    3d40:	88 0f       	add	r24, r24
    3d42:	99 1f       	adc	r25, r25
    3d44:	82 0f       	add	r24, r18
    3d46:	93 1f       	adc	r25, r19
    3d48:	9c 01       	movw	r18, r24
    3d4a:	2f 54       	subi	r18, 0x4F	; 79
    3d4c:	38 4f       	sbci	r19, 0xF8	; 248
    3d4e:	ca 01       	movw	r24, r20
    3d50:	b9 01       	movw	r22, r18
    3d52:	41 e0       	ldi	r20, 0x01	; 1
    3d54:	0e 94 7e 23 	call	0x46fc	; 0x46fc <prvListTasksWithinSingleList>
    3d58:	98 2f       	mov	r25, r24
    3d5a:	8a 81       	ldd	r24, Y+2	; 0x02
    3d5c:	89 0f       	add	r24, r25
    3d5e:	8a 83       	std	Y+2, r24	; 0x02
                } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3d60:	89 81       	ldd	r24, Y+1	; 0x01
    3d62:	88 23       	and	r24, r24
    3d64:	99 f6       	brne	.-90     	; 0x3d0c <uxTaskGetSystemState+0x34>

                /* Fill in an TaskStatus_t structure with information on each
                 * task in the Blocked state. */
                uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
    3d66:	8a 81       	ldd	r24, Y+2	; 0x02
    3d68:	88 2f       	mov	r24, r24
    3d6a:	90 e0       	ldi	r25, 0x00	; 0
    3d6c:	9c 01       	movw	r18, r24
    3d6e:	22 95       	swap	r18
    3d70:	32 95       	swap	r19
    3d72:	30 7f       	andi	r19, 0xF0	; 240
    3d74:	32 27       	eor	r19, r18
    3d76:	20 7f       	andi	r18, 0xF0	; 240
    3d78:	32 27       	eor	r19, r18
    3d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d7c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d7e:	82 0f       	add	r24, r18
    3d80:	93 1f       	adc	r25, r19
    3d82:	20 91 e7 07 	lds	r18, 0x07E7
    3d86:	30 91 e8 07 	lds	r19, 0x07E8
    3d8a:	b9 01       	movw	r22, r18
    3d8c:	42 e0       	ldi	r20, 0x02	; 2
    3d8e:	0e 94 7e 23 	call	0x46fc	; 0x46fc <prvListTasksWithinSingleList>
    3d92:	98 2f       	mov	r25, r24
    3d94:	8a 81       	ldd	r24, Y+2	; 0x02
    3d96:	89 0f       	add	r24, r25
    3d98:	8a 83       	std	Y+2, r24	; 0x02
                uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
    3d9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3d9c:	88 2f       	mov	r24, r24
    3d9e:	90 e0       	ldi	r25, 0x00	; 0
    3da0:	9c 01       	movw	r18, r24
    3da2:	22 95       	swap	r18
    3da4:	32 95       	swap	r19
    3da6:	30 7f       	andi	r19, 0xF0	; 240
    3da8:	32 27       	eor	r19, r18
    3daa:	20 7f       	andi	r18, 0xF0	; 240
    3dac:	32 27       	eor	r19, r18
    3dae:	8b 81       	ldd	r24, Y+3	; 0x03
    3db0:	9c 81       	ldd	r25, Y+4	; 0x04
    3db2:	82 0f       	add	r24, r18
    3db4:	93 1f       	adc	r25, r19
    3db6:	20 91 e9 07 	lds	r18, 0x07E9
    3dba:	30 91 ea 07 	lds	r19, 0x07EA
    3dbe:	b9 01       	movw	r22, r18
    3dc0:	42 e0       	ldi	r20, 0x02	; 2
    3dc2:	0e 94 7e 23 	call	0x46fc	; 0x46fc <prvListTasksWithinSingleList>
    3dc6:	98 2f       	mov	r25, r24
    3dc8:	8a 81       	ldd	r24, Y+2	; 0x02
    3dca:	89 0f       	add	r24, r25
    3dcc:	8a 83       	std	Y+2, r24	; 0x02

                #if ( INCLUDE_vTaskSuspend == 1 )
                    {
                        /* Fill in an TaskStatus_t structure with information on
                         * each task in the Suspended state. */
                        uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
    3dce:	8a 81       	ldd	r24, Y+2	; 0x02
    3dd0:	88 2f       	mov	r24, r24
    3dd2:	90 e0       	ldi	r25, 0x00	; 0
    3dd4:	9c 01       	movw	r18, r24
    3dd6:	22 95       	swap	r18
    3dd8:	32 95       	swap	r19
    3dda:	30 7f       	andi	r19, 0xF0	; 240
    3ddc:	32 27       	eor	r19, r18
    3dde:	20 7f       	andi	r18, 0xF0	; 240
    3de0:	32 27       	eor	r19, r18
    3de2:	8b 81       	ldd	r24, Y+3	; 0x03
    3de4:	9c 81       	ldd	r25, Y+4	; 0x04
    3de6:	82 0f       	add	r24, r18
    3de8:	93 1f       	adc	r25, r19
    3dea:	24 ef       	ldi	r18, 0xF4	; 244
    3dec:	37 e0       	ldi	r19, 0x07	; 7
    3dee:	b9 01       	movw	r22, r18
    3df0:	43 e0       	ldi	r20, 0x03	; 3
    3df2:	0e 94 7e 23 	call	0x46fc	; 0x46fc <prvListTasksWithinSingleList>
    3df6:	98 2f       	mov	r25, r24
    3df8:	8a 81       	ldd	r24, Y+2	; 0x02
    3dfa:	89 0f       	add	r24, r25
    3dfc:	8a 83       	std	Y+2, r24	; 0x02
                            #endif
                        }
                    }
                #else /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
                    {
                        if( pulTotalRunTime != NULL )
    3dfe:	8e 81       	ldd	r24, Y+6	; 0x06
    3e00:	9f 81       	ldd	r25, Y+7	; 0x07
    3e02:	00 97       	sbiw	r24, 0x00	; 0
    3e04:	31 f0       	breq	.+12     	; 0x3e12 <uxTaskGetSystemState+0x13a>
                        {
                            *pulTotalRunTime = 0;
    3e06:	ee 81       	ldd	r30, Y+6	; 0x06
    3e08:	ff 81       	ldd	r31, Y+7	; 0x07
    3e0a:	10 82       	st	Z, r1
    3e0c:	11 82       	std	Z+1, r1	; 0x01
    3e0e:	12 82       	std	Z+2, r1	; 0x02
    3e10:	13 82       	std	Z+3, r1	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        ( void ) xTaskResumeAll();
    3e12:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>

        return uxTask;
    3e16:	8a 81       	ldd	r24, Y+2	; 0x02
    }
    3e18:	27 96       	adiw	r28, 0x07	; 7
    3e1a:	0f b6       	in	r0, 0x3f	; 63
    3e1c:	f8 94       	cli
    3e1e:	de bf       	out	0x3e, r29	; 62
    3e20:	0f be       	out	0x3f, r0	; 63
    3e22:	cd bf       	out	0x3d, r28	; 61
    3e24:	cf 91       	pop	r28
    3e26:	df 91       	pop	r29
    3e28:	08 95       	ret

00003e2a <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    3e2a:	df 93       	push	r29
    3e2c:	cf 93       	push	r28
    3e2e:	00 d0       	rcall	.+0      	; 0x3e30 <xTaskCatchUpTicks+0x6>
    3e30:	0f 92       	push	r0
    3e32:	cd b7       	in	r28, 0x3d	; 61
    3e34:	de b7       	in	r29, 0x3e	; 62
    3e36:	9b 83       	std	Y+3, r25	; 0x03
    3e38:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    3e3a:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    3e3e:	20 91 a7 07 	lds	r18, 0x07A7
    3e42:	30 91 a8 07 	lds	r19, 0x07A8
    3e46:	8a 81       	ldd	r24, Y+2	; 0x02
    3e48:	9b 81       	ldd	r25, Y+3	; 0x03
    3e4a:	82 0f       	add	r24, r18
    3e4c:	93 1f       	adc	r25, r19
    3e4e:	90 93 a8 07 	sts	0x07A8, r25
    3e52:	80 93 a7 07 	sts	0x07A7, r24
    xYieldOccurred = xTaskResumeAll();
    3e56:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
    3e5a:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    3e5c:	89 81       	ldd	r24, Y+1	; 0x01
}
    3e5e:	0f 90       	pop	r0
    3e60:	0f 90       	pop	r0
    3e62:	0f 90       	pop	r0
    3e64:	cf 91       	pop	r28
    3e66:	df 91       	pop	r29
    3e68:	08 95       	ret

00003e6a <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3e6a:	df 93       	push	r29
    3e6c:	cf 93       	push	r28
    3e6e:	cd b7       	in	r28, 0x3d	; 61
    3e70:	de b7       	in	r29, 0x3e	; 62
    3e72:	29 97       	sbiw	r28, 0x09	; 9
    3e74:	0f b6       	in	r0, 0x3f	; 63
    3e76:	f8 94       	cli
    3e78:	de bf       	out	0x3e, r29	; 62
    3e7a:	0f be       	out	0x3f, r0	; 63
    3e7c:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    3e7e:	1d 82       	std	Y+5, r1	; 0x05
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3e80:	80 91 b0 07 	lds	r24, 0x07B0
    3e84:	88 23       	and	r24, r24
    3e86:	09 f0       	breq	.+2      	; 0x3e8a <xTaskIncrementTick+0x20>
    3e88:	c6 c0       	rjmp	.+396    	; 0x4016 <xTaskIncrementTick+0x1ac>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3e8a:	80 91 a3 07 	lds	r24, 0x07A3
    3e8e:	90 91 a4 07 	lds	r25, 0x07A4
    3e92:	01 96       	adiw	r24, 0x01	; 1
    3e94:	9c 83       	std	Y+4, r25	; 0x04
    3e96:	8b 83       	std	Y+3, r24	; 0x03

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    3e98:	8b 81       	ldd	r24, Y+3	; 0x03
    3e9a:	9c 81       	ldd	r25, Y+4	; 0x04
    3e9c:	90 93 a4 07 	sts	0x07A4, r25
    3ea0:	80 93 a3 07 	sts	0x07A3, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    3ea4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ea6:	9c 81       	ldd	r25, Y+4	; 0x04
    3ea8:	00 97       	sbiw	r24, 0x00	; 0
    3eaa:	d9 f4       	brne	.+54     	; 0x3ee2 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    3eac:	80 91 e7 07 	lds	r24, 0x07E7
    3eb0:	90 91 e8 07 	lds	r25, 0x07E8
    3eb4:	9a 83       	std	Y+2, r25	; 0x02
    3eb6:	89 83       	std	Y+1, r24	; 0x01
    3eb8:	80 91 e9 07 	lds	r24, 0x07E9
    3ebc:	90 91 ea 07 	lds	r25, 0x07EA
    3ec0:	90 93 e8 07 	sts	0x07E8, r25
    3ec4:	80 93 e7 07 	sts	0x07E7, r24
    3ec8:	89 81       	ldd	r24, Y+1	; 0x01
    3eca:	9a 81       	ldd	r25, Y+2	; 0x02
    3ecc:	90 93 ea 07 	sts	0x07EA, r25
    3ed0:	80 93 e9 07 	sts	0x07E9, r24
    3ed4:	80 91 aa 07 	lds	r24, 0x07AA
    3ed8:	8f 5f       	subi	r24, 0xFF	; 255
    3eda:	80 93 aa 07 	sts	0x07AA, r24
    3ede:	0e 94 46 24 	call	0x488c	; 0x488c <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    3ee2:	20 91 ac 07 	lds	r18, 0x07AC
    3ee6:	30 91 ad 07 	lds	r19, 0x07AD
    3eea:	8b 81       	ldd	r24, Y+3	; 0x03
    3eec:	9c 81       	ldd	r25, Y+4	; 0x04
    3eee:	82 17       	cp	r24, r18
    3ef0:	93 07       	cpc	r25, r19
    3ef2:	08 f4       	brcc	.+2      	; 0x3ef6 <xTaskIncrementTick+0x8c>
    3ef4:	71 c0       	rjmp	.+226    	; 0x3fd8 <xTaskIncrementTick+0x16e>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3ef6:	e0 91 e7 07 	lds	r30, 0x07E7
    3efa:	f0 91 e8 07 	lds	r31, 0x07E8
    3efe:	80 81       	ld	r24, Z
    3f00:	88 23       	and	r24, r24
    3f02:	39 f4       	brne	.+14     	; 0x3f12 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3f04:	8f ef       	ldi	r24, 0xFF	; 255
    3f06:	9f ef       	ldi	r25, 0xFF	; 255
    3f08:	90 93 ad 07 	sts	0x07AD, r25
    3f0c:	80 93 ac 07 	sts	0x07AC, r24
    3f10:	63 c0       	rjmp	.+198    	; 0x3fd8 <xTaskIncrementTick+0x16e>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3f12:	e0 91 e7 07 	lds	r30, 0x07E7
    3f16:	f0 91 e8 07 	lds	r31, 0x07E8
    3f1a:	05 80       	ldd	r0, Z+5	; 0x05
    3f1c:	f6 81       	ldd	r31, Z+6	; 0x06
    3f1e:	e0 2d       	mov	r30, r0
    3f20:	86 81       	ldd	r24, Z+6	; 0x06
    3f22:	97 81       	ldd	r25, Z+7	; 0x07
    3f24:	99 87       	std	Y+9, r25	; 0x09
    3f26:	88 87       	std	Y+8, r24	; 0x08
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3f28:	e8 85       	ldd	r30, Y+8	; 0x08
    3f2a:	f9 85       	ldd	r31, Y+9	; 0x09
    3f2c:	82 81       	ldd	r24, Z+2	; 0x02
    3f2e:	93 81       	ldd	r25, Z+3	; 0x03
    3f30:	9f 83       	std	Y+7, r25	; 0x07
    3f32:	8e 83       	std	Y+6, r24	; 0x06

                    if( xConstTickCount < xItemValue )
    3f34:	2b 81       	ldd	r18, Y+3	; 0x03
    3f36:	3c 81       	ldd	r19, Y+4	; 0x04
    3f38:	8e 81       	ldd	r24, Y+6	; 0x06
    3f3a:	9f 81       	ldd	r25, Y+7	; 0x07
    3f3c:	28 17       	cp	r18, r24
    3f3e:	39 07       	cpc	r19, r25
    3f40:	38 f4       	brcc	.+14     	; 0x3f50 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    3f42:	8e 81       	ldd	r24, Y+6	; 0x06
    3f44:	9f 81       	ldd	r25, Y+7	; 0x07
    3f46:	90 93 ad 07 	sts	0x07AD, r25
    3f4a:	80 93 ac 07 	sts	0x07AC, r24
    3f4e:	44 c0       	rjmp	.+136    	; 0x3fd8 <xTaskIncrementTick+0x16e>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3f50:	88 85       	ldd	r24, Y+8	; 0x08
    3f52:	99 85       	ldd	r25, Y+9	; 0x09
    3f54:	02 96       	adiw	r24, 0x02	; 2
    3f56:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3f5a:	e8 85       	ldd	r30, Y+8	; 0x08
    3f5c:	f9 85       	ldd	r31, Y+9	; 0x09
    3f5e:	84 89       	ldd	r24, Z+20	; 0x14
    3f60:	95 89       	ldd	r25, Z+21	; 0x15
    3f62:	00 97       	sbiw	r24, 0x00	; 0
    3f64:	29 f0       	breq	.+10     	; 0x3f70 <xTaskIncrementTick+0x106>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3f66:	88 85       	ldd	r24, Y+8	; 0x08
    3f68:	99 85       	ldd	r25, Y+9	; 0x09
    3f6a:	0c 96       	adiw	r24, 0x0c	; 12
    3f6c:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    3f70:	e8 85       	ldd	r30, Y+8	; 0x08
    3f72:	f9 85       	ldd	r31, Y+9	; 0x09
    3f74:	96 89       	ldd	r25, Z+22	; 0x16
    3f76:	80 91 a5 07 	lds	r24, 0x07A5
    3f7a:	89 17       	cp	r24, r25
    3f7c:	28 f4       	brcc	.+10     	; 0x3f88 <xTaskIncrementTick+0x11e>
    3f7e:	e8 85       	ldd	r30, Y+8	; 0x08
    3f80:	f9 85       	ldd	r31, Y+9	; 0x09
    3f82:	86 89       	ldd	r24, Z+22	; 0x16
    3f84:	80 93 a5 07 	sts	0x07A5, r24
    3f88:	e8 85       	ldd	r30, Y+8	; 0x08
    3f8a:	f9 85       	ldd	r31, Y+9	; 0x09
    3f8c:	86 89       	ldd	r24, Z+22	; 0x16
    3f8e:	28 2f       	mov	r18, r24
    3f90:	30 e0       	ldi	r19, 0x00	; 0
    3f92:	c9 01       	movw	r24, r18
    3f94:	88 0f       	add	r24, r24
    3f96:	99 1f       	adc	r25, r25
    3f98:	88 0f       	add	r24, r24
    3f9a:	99 1f       	adc	r25, r25
    3f9c:	88 0f       	add	r24, r24
    3f9e:	99 1f       	adc	r25, r25
    3fa0:	82 0f       	add	r24, r18
    3fa2:	93 1f       	adc	r25, r19
    3fa4:	ac 01       	movw	r20, r24
    3fa6:	4f 54       	subi	r20, 0x4F	; 79
    3fa8:	58 4f       	sbci	r21, 0xF8	; 248
    3faa:	88 85       	ldd	r24, Y+8	; 0x08
    3fac:	99 85       	ldd	r25, Y+9	; 0x09
    3fae:	9c 01       	movw	r18, r24
    3fb0:	2e 5f       	subi	r18, 0xFE	; 254
    3fb2:	3f 4f       	sbci	r19, 0xFF	; 255
    3fb4:	ca 01       	movw	r24, r20
    3fb6:	b9 01       	movw	r22, r18
    3fb8:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3fbc:	e8 85       	ldd	r30, Y+8	; 0x08
    3fbe:	f9 85       	ldd	r31, Y+9	; 0x09
    3fc0:	96 89       	ldd	r25, Z+22	; 0x16
    3fc2:	e0 91 a0 07 	lds	r30, 0x07A0
    3fc6:	f0 91 a1 07 	lds	r31, 0x07A1
    3fca:	86 89       	ldd	r24, Z+22	; 0x16
    3fcc:	98 17       	cp	r25, r24
    3fce:	08 f4       	brcc	.+2      	; 0x3fd2 <xTaskIncrementTick+0x168>
    3fd0:	92 cf       	rjmp	.-220    	; 0x3ef6 <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    3fd2:	81 e0       	ldi	r24, 0x01	; 1
    3fd4:	8d 83       	std	Y+5, r24	; 0x05
    3fd6:	8f cf       	rjmp	.-226    	; 0x3ef6 <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3fd8:	e0 91 a0 07 	lds	r30, 0x07A0
    3fdc:	f0 91 a1 07 	lds	r31, 0x07A1
    3fe0:	86 89       	ldd	r24, Z+22	; 0x16
    3fe2:	28 2f       	mov	r18, r24
    3fe4:	30 e0       	ldi	r19, 0x00	; 0
    3fe6:	c9 01       	movw	r24, r18
    3fe8:	88 0f       	add	r24, r24
    3fea:	99 1f       	adc	r25, r25
    3fec:	88 0f       	add	r24, r24
    3fee:	99 1f       	adc	r25, r25
    3ff0:	88 0f       	add	r24, r24
    3ff2:	99 1f       	adc	r25, r25
    3ff4:	82 0f       	add	r24, r18
    3ff6:	93 1f       	adc	r25, r19
    3ff8:	fc 01       	movw	r30, r24
    3ffa:	ef 54       	subi	r30, 0x4F	; 79
    3ffc:	f8 4f       	sbci	r31, 0xF8	; 248
    3ffe:	80 81       	ld	r24, Z
    4000:	82 30       	cpi	r24, 0x02	; 2
    4002:	10 f0       	brcs	.+4      	; 0x4008 <xTaskIncrementTick+0x19e>
                {
                    xSwitchRequired = pdTRUE;
    4004:	81 e0       	ldi	r24, 0x01	; 1
    4006:	8d 83       	std	Y+5, r24	; 0x05
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    4008:	80 91 a9 07 	lds	r24, 0x07A9
    400c:	88 23       	and	r24, r24
    400e:	61 f0       	breq	.+24     	; 0x4028 <xTaskIncrementTick+0x1be>
                {
                    xSwitchRequired = pdTRUE;
    4010:	81 e0       	ldi	r24, 0x01	; 1
    4012:	8d 83       	std	Y+5, r24	; 0x05
    4014:	09 c0       	rjmp	.+18     	; 0x4028 <xTaskIncrementTick+0x1be>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    4016:	80 91 a7 07 	lds	r24, 0x07A7
    401a:	90 91 a8 07 	lds	r25, 0x07A8
    401e:	01 96       	adiw	r24, 0x01	; 1
    4020:	90 93 a8 07 	sts	0x07A8, r25
    4024:	80 93 a7 07 	sts	0x07A7, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    4028:	8d 81       	ldd	r24, Y+5	; 0x05
}
    402a:	29 96       	adiw	r28, 0x09	; 9
    402c:	0f b6       	in	r0, 0x3f	; 63
    402e:	f8 94       	cli
    4030:	de bf       	out	0x3e, r29	; 62
    4032:	0f be       	out	0x3f, r0	; 63
    4034:	cd bf       	out	0x3d, r28	; 61
    4036:	cf 91       	pop	r28
    4038:	df 91       	pop	r29
    403a:	08 95       	ret

0000403c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    403c:	df 93       	push	r29
    403e:	cf 93       	push	r28
    4040:	00 d0       	rcall	.+0      	; 0x4042 <vTaskSwitchContext+0x6>
    4042:	0f 92       	push	r0
    4044:	cd b7       	in	r28, 0x3d	; 61
    4046:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4048:	80 91 b0 07 	lds	r24, 0x07B0
    404c:	88 23       	and	r24, r24
    404e:	21 f0       	breq	.+8      	; 0x4058 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    4050:	81 e0       	ldi	r24, 0x01	; 1
    4052:	80 93 a9 07 	sts	0x07A9, r24
    4056:	59 c0       	rjmp	.+178    	; 0x410a <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    4058:	10 92 a9 07 	sts	0x07A9, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    405c:	80 91 a5 07 	lds	r24, 0x07A5
    4060:	8b 83       	std	Y+3, r24	; 0x03
    4062:	03 c0       	rjmp	.+6      	; 0x406a <vTaskSwitchContext+0x2e>
    4064:	8b 81       	ldd	r24, Y+3	; 0x03
    4066:	81 50       	subi	r24, 0x01	; 1
    4068:	8b 83       	std	Y+3, r24	; 0x03
    406a:	8b 81       	ldd	r24, Y+3	; 0x03
    406c:	28 2f       	mov	r18, r24
    406e:	30 e0       	ldi	r19, 0x00	; 0
    4070:	c9 01       	movw	r24, r18
    4072:	88 0f       	add	r24, r24
    4074:	99 1f       	adc	r25, r25
    4076:	88 0f       	add	r24, r24
    4078:	99 1f       	adc	r25, r25
    407a:	88 0f       	add	r24, r24
    407c:	99 1f       	adc	r25, r25
    407e:	82 0f       	add	r24, r18
    4080:	93 1f       	adc	r25, r19
    4082:	fc 01       	movw	r30, r24
    4084:	ef 54       	subi	r30, 0x4F	; 79
    4086:	f8 4f       	sbci	r31, 0xF8	; 248
    4088:	80 81       	ld	r24, Z
    408a:	88 23       	and	r24, r24
    408c:	59 f3       	breq	.-42     	; 0x4064 <vTaskSwitchContext+0x28>
    408e:	8b 81       	ldd	r24, Y+3	; 0x03
    4090:	28 2f       	mov	r18, r24
    4092:	30 e0       	ldi	r19, 0x00	; 0
    4094:	c9 01       	movw	r24, r18
    4096:	88 0f       	add	r24, r24
    4098:	99 1f       	adc	r25, r25
    409a:	88 0f       	add	r24, r24
    409c:	99 1f       	adc	r25, r25
    409e:	88 0f       	add	r24, r24
    40a0:	99 1f       	adc	r25, r25
    40a2:	82 0f       	add	r24, r18
    40a4:	93 1f       	adc	r25, r19
    40a6:	8f 54       	subi	r24, 0x4F	; 79
    40a8:	98 4f       	sbci	r25, 0xF8	; 248
    40aa:	9a 83       	std	Y+2, r25	; 0x02
    40ac:	89 83       	std	Y+1, r24	; 0x01
    40ae:	e9 81       	ldd	r30, Y+1	; 0x01
    40b0:	fa 81       	ldd	r31, Y+2	; 0x02
    40b2:	01 80       	ldd	r0, Z+1	; 0x01
    40b4:	f2 81       	ldd	r31, Z+2	; 0x02
    40b6:	e0 2d       	mov	r30, r0
    40b8:	82 81       	ldd	r24, Z+2	; 0x02
    40ba:	93 81       	ldd	r25, Z+3	; 0x03
    40bc:	e9 81       	ldd	r30, Y+1	; 0x01
    40be:	fa 81       	ldd	r31, Y+2	; 0x02
    40c0:	92 83       	std	Z+2, r25	; 0x02
    40c2:	81 83       	std	Z+1, r24	; 0x01
    40c4:	e9 81       	ldd	r30, Y+1	; 0x01
    40c6:	fa 81       	ldd	r31, Y+2	; 0x02
    40c8:	21 81       	ldd	r18, Z+1	; 0x01
    40ca:	32 81       	ldd	r19, Z+2	; 0x02
    40cc:	89 81       	ldd	r24, Y+1	; 0x01
    40ce:	9a 81       	ldd	r25, Y+2	; 0x02
    40d0:	03 96       	adiw	r24, 0x03	; 3
    40d2:	28 17       	cp	r18, r24
    40d4:	39 07       	cpc	r19, r25
    40d6:	59 f4       	brne	.+22     	; 0x40ee <vTaskSwitchContext+0xb2>
    40d8:	e9 81       	ldd	r30, Y+1	; 0x01
    40da:	fa 81       	ldd	r31, Y+2	; 0x02
    40dc:	01 80       	ldd	r0, Z+1	; 0x01
    40de:	f2 81       	ldd	r31, Z+2	; 0x02
    40e0:	e0 2d       	mov	r30, r0
    40e2:	82 81       	ldd	r24, Z+2	; 0x02
    40e4:	93 81       	ldd	r25, Z+3	; 0x03
    40e6:	e9 81       	ldd	r30, Y+1	; 0x01
    40e8:	fa 81       	ldd	r31, Y+2	; 0x02
    40ea:	92 83       	std	Z+2, r25	; 0x02
    40ec:	81 83       	std	Z+1, r24	; 0x01
    40ee:	e9 81       	ldd	r30, Y+1	; 0x01
    40f0:	fa 81       	ldd	r31, Y+2	; 0x02
    40f2:	01 80       	ldd	r0, Z+1	; 0x01
    40f4:	f2 81       	ldd	r31, Z+2	; 0x02
    40f6:	e0 2d       	mov	r30, r0
    40f8:	86 81       	ldd	r24, Z+6	; 0x06
    40fa:	97 81       	ldd	r25, Z+7	; 0x07
    40fc:	90 93 a1 07 	sts	0x07A1, r25
    4100:	80 93 a0 07 	sts	0x07A0, r24
    4104:	8b 81       	ldd	r24, Y+3	; 0x03
    4106:	80 93 a5 07 	sts	0x07A5, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    410a:	0f 90       	pop	r0
    410c:	0f 90       	pop	r0
    410e:	0f 90       	pop	r0
    4110:	cf 91       	pop	r28
    4112:	df 91       	pop	r29
    4114:	08 95       	ret

00004116 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    4116:	df 93       	push	r29
    4118:	cf 93       	push	r28
    411a:	00 d0       	rcall	.+0      	; 0x411c <vTaskPlaceOnEventList+0x6>
    411c:	00 d0       	rcall	.+0      	; 0x411e <vTaskPlaceOnEventList+0x8>
    411e:	cd b7       	in	r28, 0x3d	; 61
    4120:	de b7       	in	r29, 0x3e	; 62
    4122:	9a 83       	std	Y+2, r25	; 0x02
    4124:	89 83       	std	Y+1, r24	; 0x01
    4126:	7c 83       	std	Y+4, r23	; 0x04
    4128:	6b 83       	std	Y+3, r22	; 0x03

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    412a:	80 91 a0 07 	lds	r24, 0x07A0
    412e:	90 91 a1 07 	lds	r25, 0x07A1
    4132:	9c 01       	movw	r18, r24
    4134:	24 5f       	subi	r18, 0xF4	; 244
    4136:	3f 4f       	sbci	r19, 0xFF	; 255
    4138:	89 81       	ldd	r24, Y+1	; 0x01
    413a:	9a 81       	ldd	r25, Y+2	; 0x02
    413c:	b9 01       	movw	r22, r18
    413e:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4142:	8b 81       	ldd	r24, Y+3	; 0x03
    4144:	9c 81       	ldd	r25, Y+4	; 0x04
    4146:	61 e0       	ldi	r22, 0x01	; 1
    4148:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <prvAddCurrentTaskToDelayedList>
}
    414c:	0f 90       	pop	r0
    414e:	0f 90       	pop	r0
    4150:	0f 90       	pop	r0
    4152:	0f 90       	pop	r0
    4154:	cf 91       	pop	r28
    4156:	df 91       	pop	r29
    4158:	08 95       	ret

0000415a <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    415a:	df 93       	push	r29
    415c:	cf 93       	push	r28
    415e:	00 d0       	rcall	.+0      	; 0x4160 <vTaskPlaceOnUnorderedEventList+0x6>
    4160:	00 d0       	rcall	.+0      	; 0x4162 <vTaskPlaceOnUnorderedEventList+0x8>
    4162:	00 d0       	rcall	.+0      	; 0x4164 <vTaskPlaceOnUnorderedEventList+0xa>
    4164:	cd b7       	in	r28, 0x3d	; 61
    4166:	de b7       	in	r29, 0x3e	; 62
    4168:	9a 83       	std	Y+2, r25	; 0x02
    416a:	89 83       	std	Y+1, r24	; 0x01
    416c:	7c 83       	std	Y+4, r23	; 0x04
    416e:	6b 83       	std	Y+3, r22	; 0x03
    4170:	5e 83       	std	Y+6, r21	; 0x06
    4172:	4d 83       	std	Y+5, r20	; 0x05
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4174:	e0 91 a0 07 	lds	r30, 0x07A0
    4178:	f0 91 a1 07 	lds	r31, 0x07A1
    417c:	8b 81       	ldd	r24, Y+3	; 0x03
    417e:	9c 81       	ldd	r25, Y+4	; 0x04
    4180:	90 68       	ori	r25, 0x80	; 128
    4182:	95 87       	std	Z+13, r25	; 0x0d
    4184:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4186:	80 91 a0 07 	lds	r24, 0x07A0
    418a:	90 91 a1 07 	lds	r25, 0x07A1
    418e:	9c 01       	movw	r18, r24
    4190:	24 5f       	subi	r18, 0xF4	; 244
    4192:	3f 4f       	sbci	r19, 0xFF	; 255
    4194:	89 81       	ldd	r24, Y+1	; 0x01
    4196:	9a 81       	ldd	r25, Y+2	; 0x02
    4198:	b9 01       	movw	r22, r18
    419a:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    419e:	8d 81       	ldd	r24, Y+5	; 0x05
    41a0:	9e 81       	ldd	r25, Y+6	; 0x06
    41a2:	61 e0       	ldi	r22, 0x01	; 1
    41a4:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <prvAddCurrentTaskToDelayedList>
}
    41a8:	26 96       	adiw	r28, 0x06	; 6
    41aa:	0f b6       	in	r0, 0x3f	; 63
    41ac:	f8 94       	cli
    41ae:	de bf       	out	0x3e, r29	; 62
    41b0:	0f be       	out	0x3f, r0	; 63
    41b2:	cd bf       	out	0x3d, r28	; 61
    41b4:	cf 91       	pop	r28
    41b6:	df 91       	pop	r29
    41b8:	08 95       	ret

000041ba <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    41ba:	df 93       	push	r29
    41bc:	cf 93       	push	r28
    41be:	00 d0       	rcall	.+0      	; 0x41c0 <xTaskRemoveFromEventList+0x6>
    41c0:	00 d0       	rcall	.+0      	; 0x41c2 <xTaskRemoveFromEventList+0x8>
    41c2:	0f 92       	push	r0
    41c4:	cd b7       	in	r28, 0x3d	; 61
    41c6:	de b7       	in	r29, 0x3e	; 62
    41c8:	9d 83       	std	Y+5, r25	; 0x05
    41ca:	8c 83       	std	Y+4, r24	; 0x04
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    41cc:	ec 81       	ldd	r30, Y+4	; 0x04
    41ce:	fd 81       	ldd	r31, Y+5	; 0x05
    41d0:	05 80       	ldd	r0, Z+5	; 0x05
    41d2:	f6 81       	ldd	r31, Z+6	; 0x06
    41d4:	e0 2d       	mov	r30, r0
    41d6:	86 81       	ldd	r24, Z+6	; 0x06
    41d8:	97 81       	ldd	r25, Z+7	; 0x07
    41da:	9b 83       	std	Y+3, r25	; 0x03
    41dc:	8a 83       	std	Y+2, r24	; 0x02
    configASSERT( pxUnblockedTCB );
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    41de:	8a 81       	ldd	r24, Y+2	; 0x02
    41e0:	9b 81       	ldd	r25, Y+3	; 0x03
    41e2:	0c 96       	adiw	r24, 0x0c	; 12
    41e4:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    41e8:	80 91 b0 07 	lds	r24, 0x07B0
    41ec:	88 23       	and	r24, r24
    41ee:	61 f5       	brne	.+88     	; 0x4248 <xTaskRemoveFromEventList+0x8e>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    41f0:	8a 81       	ldd	r24, Y+2	; 0x02
    41f2:	9b 81       	ldd	r25, Y+3	; 0x03
    41f4:	02 96       	adiw	r24, 0x02	; 2
    41f6:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
        prvAddTaskToReadyList( pxUnblockedTCB );
    41fa:	ea 81       	ldd	r30, Y+2	; 0x02
    41fc:	fb 81       	ldd	r31, Y+3	; 0x03
    41fe:	96 89       	ldd	r25, Z+22	; 0x16
    4200:	80 91 a5 07 	lds	r24, 0x07A5
    4204:	89 17       	cp	r24, r25
    4206:	28 f4       	brcc	.+10     	; 0x4212 <xTaskRemoveFromEventList+0x58>
    4208:	ea 81       	ldd	r30, Y+2	; 0x02
    420a:	fb 81       	ldd	r31, Y+3	; 0x03
    420c:	86 89       	ldd	r24, Z+22	; 0x16
    420e:	80 93 a5 07 	sts	0x07A5, r24
    4212:	ea 81       	ldd	r30, Y+2	; 0x02
    4214:	fb 81       	ldd	r31, Y+3	; 0x03
    4216:	86 89       	ldd	r24, Z+22	; 0x16
    4218:	28 2f       	mov	r18, r24
    421a:	30 e0       	ldi	r19, 0x00	; 0
    421c:	c9 01       	movw	r24, r18
    421e:	88 0f       	add	r24, r24
    4220:	99 1f       	adc	r25, r25
    4222:	88 0f       	add	r24, r24
    4224:	99 1f       	adc	r25, r25
    4226:	88 0f       	add	r24, r24
    4228:	99 1f       	adc	r25, r25
    422a:	82 0f       	add	r24, r18
    422c:	93 1f       	adc	r25, r19
    422e:	ac 01       	movw	r20, r24
    4230:	4f 54       	subi	r20, 0x4F	; 79
    4232:	58 4f       	sbci	r21, 0xF8	; 248
    4234:	8a 81       	ldd	r24, Y+2	; 0x02
    4236:	9b 81       	ldd	r25, Y+3	; 0x03
    4238:	9c 01       	movw	r18, r24
    423a:	2e 5f       	subi	r18, 0xFE	; 254
    423c:	3f 4f       	sbci	r19, 0xFF	; 255
    423e:	ca 01       	movw	r24, r20
    4240:	b9 01       	movw	r22, r18
    4242:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
    4246:	0a c0       	rjmp	.+20     	; 0x425c <xTaskRemoveFromEventList+0xa2>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4248:	8a 81       	ldd	r24, Y+2	; 0x02
    424a:	9b 81       	ldd	r25, Y+3	; 0x03
    424c:	9c 01       	movw	r18, r24
    424e:	24 5f       	subi	r18, 0xF4	; 244
    4250:	3f 4f       	sbci	r19, 0xFF	; 255
    4252:	8b ee       	ldi	r24, 0xEB	; 235
    4254:	97 e0       	ldi	r25, 0x07	; 7
    4256:	b9 01       	movw	r22, r18
    4258:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    425c:	ea 81       	ldd	r30, Y+2	; 0x02
    425e:	fb 81       	ldd	r31, Y+3	; 0x03
    4260:	96 89       	ldd	r25, Z+22	; 0x16
    4262:	e0 91 a0 07 	lds	r30, 0x07A0
    4266:	f0 91 a1 07 	lds	r31, 0x07A1
    426a:	86 89       	ldd	r24, Z+22	; 0x16
    426c:	89 17       	cp	r24, r25
    426e:	30 f4       	brcc	.+12     	; 0x427c <xTaskRemoveFromEventList+0xc2>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    4270:	81 e0       	ldi	r24, 0x01	; 1
    4272:	89 83       	std	Y+1, r24	; 0x01

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    4274:	81 e0       	ldi	r24, 0x01	; 1
    4276:	80 93 a9 07 	sts	0x07A9, r24
    427a:	01 c0       	rjmp	.+2      	; 0x427e <xTaskRemoveFromEventList+0xc4>
    }
    else
    {
        xReturn = pdFALSE;
    427c:	19 82       	std	Y+1, r1	; 0x01
    }

    return xReturn;
    427e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4280:	0f 90       	pop	r0
    4282:	0f 90       	pop	r0
    4284:	0f 90       	pop	r0
    4286:	0f 90       	pop	r0
    4288:	0f 90       	pop	r0
    428a:	cf 91       	pop	r28
    428c:	df 91       	pop	r29
    428e:	08 95       	ret

00004290 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    4290:	df 93       	push	r29
    4292:	cf 93       	push	r28
    4294:	00 d0       	rcall	.+0      	; 0x4296 <vTaskRemoveFromUnorderedEventList+0x6>
    4296:	00 d0       	rcall	.+0      	; 0x4298 <vTaskRemoveFromUnorderedEventList+0x8>
    4298:	00 d0       	rcall	.+0      	; 0x429a <vTaskRemoveFromUnorderedEventList+0xa>
    429a:	cd b7       	in	r28, 0x3d	; 61
    429c:	de b7       	in	r29, 0x3e	; 62
    429e:	9c 83       	std	Y+4, r25	; 0x04
    42a0:	8b 83       	std	Y+3, r24	; 0x03
    42a2:	7e 83       	std	Y+6, r23	; 0x06
    42a4:	6d 83       	std	Y+5, r22	; 0x05
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    42a6:	8d 81       	ldd	r24, Y+5	; 0x05
    42a8:	9e 81       	ldd	r25, Y+6	; 0x06
    42aa:	90 68       	ori	r25, 0x80	; 128
    42ac:	eb 81       	ldd	r30, Y+3	; 0x03
    42ae:	fc 81       	ldd	r31, Y+4	; 0x04
    42b0:	91 83       	std	Z+1, r25	; 0x01
    42b2:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    42b4:	eb 81       	ldd	r30, Y+3	; 0x03
    42b6:	fc 81       	ldd	r31, Y+4	; 0x04
    42b8:	86 81       	ldd	r24, Z+6	; 0x06
    42ba:	97 81       	ldd	r25, Z+7	; 0x07
    42bc:	9a 83       	std	Y+2, r25	; 0x02
    42be:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxUnblockedTCB );
    ( void ) uxListRemove( pxEventListItem );
    42c0:	8b 81       	ldd	r24, Y+3	; 0x03
    42c2:	9c 81       	ldd	r25, Y+4	; 0x04
    42c4:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    42c8:	89 81       	ldd	r24, Y+1	; 0x01
    42ca:	9a 81       	ldd	r25, Y+2	; 0x02
    42cc:	02 96       	adiw	r24, 0x02	; 2
    42ce:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
    prvAddTaskToReadyList( pxUnblockedTCB );
    42d2:	e9 81       	ldd	r30, Y+1	; 0x01
    42d4:	fa 81       	ldd	r31, Y+2	; 0x02
    42d6:	96 89       	ldd	r25, Z+22	; 0x16
    42d8:	80 91 a5 07 	lds	r24, 0x07A5
    42dc:	89 17       	cp	r24, r25
    42de:	28 f4       	brcc	.+10     	; 0x42ea <vTaskRemoveFromUnorderedEventList+0x5a>
    42e0:	e9 81       	ldd	r30, Y+1	; 0x01
    42e2:	fa 81       	ldd	r31, Y+2	; 0x02
    42e4:	86 89       	ldd	r24, Z+22	; 0x16
    42e6:	80 93 a5 07 	sts	0x07A5, r24
    42ea:	e9 81       	ldd	r30, Y+1	; 0x01
    42ec:	fa 81       	ldd	r31, Y+2	; 0x02
    42ee:	86 89       	ldd	r24, Z+22	; 0x16
    42f0:	28 2f       	mov	r18, r24
    42f2:	30 e0       	ldi	r19, 0x00	; 0
    42f4:	c9 01       	movw	r24, r18
    42f6:	88 0f       	add	r24, r24
    42f8:	99 1f       	adc	r25, r25
    42fa:	88 0f       	add	r24, r24
    42fc:	99 1f       	adc	r25, r25
    42fe:	88 0f       	add	r24, r24
    4300:	99 1f       	adc	r25, r25
    4302:	82 0f       	add	r24, r18
    4304:	93 1f       	adc	r25, r19
    4306:	ac 01       	movw	r20, r24
    4308:	4f 54       	subi	r20, 0x4F	; 79
    430a:	58 4f       	sbci	r21, 0xF8	; 248
    430c:	89 81       	ldd	r24, Y+1	; 0x01
    430e:	9a 81       	ldd	r25, Y+2	; 0x02
    4310:	9c 01       	movw	r18, r24
    4312:	2e 5f       	subi	r18, 0xFE	; 254
    4314:	3f 4f       	sbci	r19, 0xFF	; 255
    4316:	ca 01       	movw	r24, r20
    4318:	b9 01       	movw	r22, r18
    431a:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    431e:	e9 81       	ldd	r30, Y+1	; 0x01
    4320:	fa 81       	ldd	r31, Y+2	; 0x02
    4322:	96 89       	ldd	r25, Z+22	; 0x16
    4324:	e0 91 a0 07 	lds	r30, 0x07A0
    4328:	f0 91 a1 07 	lds	r31, 0x07A1
    432c:	86 89       	ldd	r24, Z+22	; 0x16
    432e:	89 17       	cp	r24, r25
    4330:	18 f4       	brcc	.+6      	; 0x4338 <vTaskRemoveFromUnorderedEventList+0xa8>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    4332:	81 e0       	ldi	r24, 0x01	; 1
    4334:	80 93 a9 07 	sts	0x07A9, r24
    }
}
    4338:	26 96       	adiw	r28, 0x06	; 6
    433a:	0f b6       	in	r0, 0x3f	; 63
    433c:	f8 94       	cli
    433e:	de bf       	out	0x3e, r29	; 62
    4340:	0f be       	out	0x3f, r0	; 63
    4342:	cd bf       	out	0x3d, r28	; 61
    4344:	cf 91       	pop	r28
    4346:	df 91       	pop	r29
    4348:	08 95       	ret

0000434a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    434a:	df 93       	push	r29
    434c:	cf 93       	push	r28
    434e:	00 d0       	rcall	.+0      	; 0x4350 <vTaskSetTimeOutState+0x6>
    4350:	cd b7       	in	r28, 0x3d	; 61
    4352:	de b7       	in	r29, 0x3e	; 62
    4354:	9a 83       	std	Y+2, r25	; 0x02
    4356:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    4358:	0f b6       	in	r0, 0x3f	; 63
    435a:	f8 94       	cli
    435c:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    435e:	80 91 aa 07 	lds	r24, 0x07AA
    4362:	e9 81       	ldd	r30, Y+1	; 0x01
    4364:	fa 81       	ldd	r31, Y+2	; 0x02
    4366:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    4368:	80 91 a3 07 	lds	r24, 0x07A3
    436c:	90 91 a4 07 	lds	r25, 0x07A4
    4370:	e9 81       	ldd	r30, Y+1	; 0x01
    4372:	fa 81       	ldd	r31, Y+2	; 0x02
    4374:	92 83       	std	Z+2, r25	; 0x02
    4376:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    4378:	0f 90       	pop	r0
    437a:	0f be       	out	0x3f, r0	; 63
}
    437c:	0f 90       	pop	r0
    437e:	0f 90       	pop	r0
    4380:	cf 91       	pop	r28
    4382:	df 91       	pop	r29
    4384:	08 95       	ret

00004386 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4386:	df 93       	push	r29
    4388:	cf 93       	push	r28
    438a:	00 d0       	rcall	.+0      	; 0x438c <vTaskInternalSetTimeOutState+0x6>
    438c:	cd b7       	in	r28, 0x3d	; 61
    438e:	de b7       	in	r29, 0x3e	; 62
    4390:	9a 83       	std	Y+2, r25	; 0x02
    4392:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4394:	80 91 aa 07 	lds	r24, 0x07AA
    4398:	e9 81       	ldd	r30, Y+1	; 0x01
    439a:	fa 81       	ldd	r31, Y+2	; 0x02
    439c:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    439e:	80 91 a3 07 	lds	r24, 0x07A3
    43a2:	90 91 a4 07 	lds	r25, 0x07A4
    43a6:	e9 81       	ldd	r30, Y+1	; 0x01
    43a8:	fa 81       	ldd	r31, Y+2	; 0x02
    43aa:	92 83       	std	Z+2, r25	; 0x02
    43ac:	81 83       	std	Z+1, r24	; 0x01
}
    43ae:	0f 90       	pop	r0
    43b0:	0f 90       	pop	r0
    43b2:	cf 91       	pop	r28
    43b4:	df 91       	pop	r29
    43b6:	08 95       	ret

000043b8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    43b8:	df 93       	push	r29
    43ba:	cf 93       	push	r28
    43bc:	cd b7       	in	r28, 0x3d	; 61
    43be:	de b7       	in	r29, 0x3e	; 62
    43c0:	29 97       	sbiw	r28, 0x09	; 9
    43c2:	0f b6       	in	r0, 0x3f	; 63
    43c4:	f8 94       	cli
    43c6:	de bf       	out	0x3e, r29	; 62
    43c8:	0f be       	out	0x3f, r0	; 63
    43ca:	cd bf       	out	0x3d, r28	; 61
    43cc:	9f 83       	std	Y+7, r25	; 0x07
    43ce:	8e 83       	std	Y+6, r24	; 0x06
    43d0:	79 87       	std	Y+9, r23	; 0x09
    43d2:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    43d4:	0f b6       	in	r0, 0x3f	; 63
    43d6:	f8 94       	cli
    43d8:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    43da:	80 91 a3 07 	lds	r24, 0x07A3
    43de:	90 91 a4 07 	lds	r25, 0x07A4
    43e2:	9c 83       	std	Y+4, r25	; 0x04
    43e4:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    43e6:	ee 81       	ldd	r30, Y+6	; 0x06
    43e8:	ff 81       	ldd	r31, Y+7	; 0x07
    43ea:	21 81       	ldd	r18, Z+1	; 0x01
    43ec:	32 81       	ldd	r19, Z+2	; 0x02
    43ee:	8b 81       	ldd	r24, Y+3	; 0x03
    43f0:	9c 81       	ldd	r25, Y+4	; 0x04
    43f2:	82 1b       	sub	r24, r18
    43f4:	93 0b       	sbc	r25, r19
    43f6:	9a 83       	std	Y+2, r25	; 0x02
    43f8:	89 83       	std	Y+1, r24	; 0x01
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
    43fa:	e8 85       	ldd	r30, Y+8	; 0x08
    43fc:	f9 85       	ldd	r31, Y+9	; 0x09
    43fe:	80 81       	ld	r24, Z
    4400:	91 81       	ldd	r25, Z+1	; 0x01
    4402:	2f ef       	ldi	r18, 0xFF	; 255
    4404:	8f 3f       	cpi	r24, 0xFF	; 255
    4406:	92 07       	cpc	r25, r18
    4408:	11 f4       	brne	.+4      	; 0x440e <xTaskCheckForTimeOut+0x56>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
    440a:	1d 82       	std	Y+5, r1	; 0x05
    440c:	3a c0       	rjmp	.+116    	; 0x4482 <xTaskCheckForTimeOut+0xca>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    440e:	ee 81       	ldd	r30, Y+6	; 0x06
    4410:	ff 81       	ldd	r31, Y+7	; 0x07
    4412:	90 81       	ld	r25, Z
    4414:	80 91 aa 07 	lds	r24, 0x07AA
    4418:	98 17       	cp	r25, r24
    441a:	81 f0       	breq	.+32     	; 0x443c <xTaskCheckForTimeOut+0x84>
    441c:	ee 81       	ldd	r30, Y+6	; 0x06
    441e:	ff 81       	ldd	r31, Y+7	; 0x07
    4420:	21 81       	ldd	r18, Z+1	; 0x01
    4422:	32 81       	ldd	r19, Z+2	; 0x02
    4424:	8b 81       	ldd	r24, Y+3	; 0x03
    4426:	9c 81       	ldd	r25, Y+4	; 0x04
    4428:	82 17       	cp	r24, r18
    442a:	93 07       	cpc	r25, r19
    442c:	38 f0       	brcs	.+14     	; 0x443c <xTaskCheckForTimeOut+0x84>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    442e:	81 e0       	ldi	r24, 0x01	; 1
    4430:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    4432:	e8 85       	ldd	r30, Y+8	; 0x08
    4434:	f9 85       	ldd	r31, Y+9	; 0x09
    4436:	11 82       	std	Z+1, r1	; 0x01
    4438:	10 82       	st	Z, r1
    443a:	23 c0       	rjmp	.+70     	; 0x4482 <xTaskCheckForTimeOut+0xca>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    443c:	e8 85       	ldd	r30, Y+8	; 0x08
    443e:	f9 85       	ldd	r31, Y+9	; 0x09
    4440:	20 81       	ld	r18, Z
    4442:	31 81       	ldd	r19, Z+1	; 0x01
    4444:	89 81       	ldd	r24, Y+1	; 0x01
    4446:	9a 81       	ldd	r25, Y+2	; 0x02
    4448:	82 17       	cp	r24, r18
    444a:	93 07       	cpc	r25, r19
    444c:	a0 f4       	brcc	.+40     	; 0x4476 <xTaskCheckForTimeOut+0xbe>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    444e:	e8 85       	ldd	r30, Y+8	; 0x08
    4450:	f9 85       	ldd	r31, Y+9	; 0x09
    4452:	20 81       	ld	r18, Z
    4454:	31 81       	ldd	r19, Z+1	; 0x01
    4456:	89 81       	ldd	r24, Y+1	; 0x01
    4458:	9a 81       	ldd	r25, Y+2	; 0x02
    445a:	a9 01       	movw	r20, r18
    445c:	48 1b       	sub	r20, r24
    445e:	59 0b       	sbc	r21, r25
    4460:	ca 01       	movw	r24, r20
    4462:	e8 85       	ldd	r30, Y+8	; 0x08
    4464:	f9 85       	ldd	r31, Y+9	; 0x09
    4466:	91 83       	std	Z+1, r25	; 0x01
    4468:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    446a:	8e 81       	ldd	r24, Y+6	; 0x06
    446c:	9f 81       	ldd	r25, Y+7	; 0x07
    446e:	0e 94 c3 21 	call	0x4386	; 0x4386 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    4472:	1d 82       	std	Y+5, r1	; 0x05
    4474:	06 c0       	rjmp	.+12     	; 0x4482 <xTaskCheckForTimeOut+0xca>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    4476:	e8 85       	ldd	r30, Y+8	; 0x08
    4478:	f9 85       	ldd	r31, Y+9	; 0x09
    447a:	11 82       	std	Z+1, r1	; 0x01
    447c:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    447e:	81 e0       	ldi	r24, 0x01	; 1
    4480:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    4482:	0f 90       	pop	r0
    4484:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4486:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4488:	29 96       	adiw	r28, 0x09	; 9
    448a:	0f b6       	in	r0, 0x3f	; 63
    448c:	f8 94       	cli
    448e:	de bf       	out	0x3e, r29	; 62
    4490:	0f be       	out	0x3f, r0	; 63
    4492:	cd bf       	out	0x3d, r28	; 61
    4494:	cf 91       	pop	r28
    4496:	df 91       	pop	r29
    4498:	08 95       	ret

0000449a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    449a:	df 93       	push	r29
    449c:	cf 93       	push	r28
    449e:	cd b7       	in	r28, 0x3d	; 61
    44a0:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    44a2:	81 e0       	ldi	r24, 0x01	; 1
    44a4:	80 93 a9 07 	sts	0x07A9, r24
}
    44a8:	cf 91       	pop	r28
    44aa:	df 91       	pop	r29
    44ac:	08 95       	ret

000044ae <uxTaskGetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
    {
    44ae:	df 93       	push	r29
    44b0:	cf 93       	push	r28
    44b2:	00 d0       	rcall	.+0      	; 0x44b4 <uxTaskGetTaskNumber+0x6>
    44b4:	00 d0       	rcall	.+0      	; 0x44b6 <uxTaskGetTaskNumber+0x8>
    44b6:	0f 92       	push	r0
    44b8:	cd b7       	in	r28, 0x3d	; 61
    44ba:	de b7       	in	r29, 0x3e	; 62
    44bc:	9d 83       	std	Y+5, r25	; 0x05
    44be:	8c 83       	std	Y+4, r24	; 0x04
        UBaseType_t uxReturn;
        TCB_t const * pxTCB;

        if( xTask != NULL )
    44c0:	8c 81       	ldd	r24, Y+4	; 0x04
    44c2:	9d 81       	ldd	r25, Y+5	; 0x05
    44c4:	00 97       	sbiw	r24, 0x00	; 0
    44c6:	49 f0       	breq	.+18     	; 0x44da <uxTaskGetTaskNumber+0x2c>
        {
            pxTCB = xTask;
    44c8:	8c 81       	ldd	r24, Y+4	; 0x04
    44ca:	9d 81       	ldd	r25, Y+5	; 0x05
    44cc:	9a 83       	std	Y+2, r25	; 0x02
    44ce:	89 83       	std	Y+1, r24	; 0x01
            uxReturn = pxTCB->uxTaskNumber;
    44d0:	e9 81       	ldd	r30, Y+1	; 0x01
    44d2:	fa 81       	ldd	r31, Y+2	; 0x02
    44d4:	86 a1       	ldd	r24, Z+38	; 0x26
    44d6:	8b 83       	std	Y+3, r24	; 0x03
    44d8:	01 c0       	rjmp	.+2      	; 0x44dc <uxTaskGetTaskNumber+0x2e>
        }
        else
        {
            uxReturn = 0U;
    44da:	1b 82       	std	Y+3, r1	; 0x03
        }

        return uxReturn;
    44dc:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    44de:	0f 90       	pop	r0
    44e0:	0f 90       	pop	r0
    44e2:	0f 90       	pop	r0
    44e4:	0f 90       	pop	r0
    44e6:	0f 90       	pop	r0
    44e8:	cf 91       	pop	r28
    44ea:	df 91       	pop	r29
    44ec:	08 95       	ret

000044ee <vTaskSetTaskNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

    void vTaskSetTaskNumber( TaskHandle_t xTask,
                             const UBaseType_t uxHandle )
    {
    44ee:	df 93       	push	r29
    44f0:	cf 93       	push	r28
    44f2:	00 d0       	rcall	.+0      	; 0x44f4 <vTaskSetTaskNumber+0x6>
    44f4:	00 d0       	rcall	.+0      	; 0x44f6 <vTaskSetTaskNumber+0x8>
    44f6:	0f 92       	push	r0
    44f8:	cd b7       	in	r28, 0x3d	; 61
    44fa:	de b7       	in	r29, 0x3e	; 62
    44fc:	9c 83       	std	Y+4, r25	; 0x04
    44fe:	8b 83       	std	Y+3, r24	; 0x03
    4500:	6d 83       	std	Y+5, r22	; 0x05
        TCB_t * pxTCB;

        if( xTask != NULL )
    4502:	8b 81       	ldd	r24, Y+3	; 0x03
    4504:	9c 81       	ldd	r25, Y+4	; 0x04
    4506:	00 97       	sbiw	r24, 0x00	; 0
    4508:	41 f0       	breq	.+16     	; 0x451a <vTaskSetTaskNumber+0x2c>
        {
            pxTCB = xTask;
    450a:	8b 81       	ldd	r24, Y+3	; 0x03
    450c:	9c 81       	ldd	r25, Y+4	; 0x04
    450e:	9a 83       	std	Y+2, r25	; 0x02
    4510:	89 83       	std	Y+1, r24	; 0x01
            pxTCB->uxTaskNumber = uxHandle;
    4512:	e9 81       	ldd	r30, Y+1	; 0x01
    4514:	fa 81       	ldd	r31, Y+2	; 0x02
    4516:	8d 81       	ldd	r24, Y+5	; 0x05
    4518:	86 a3       	std	Z+38, r24	; 0x26
        }
    }
    451a:	0f 90       	pop	r0
    451c:	0f 90       	pop	r0
    451e:	0f 90       	pop	r0
    4520:	0f 90       	pop	r0
    4522:	0f 90       	pop	r0
    4524:	cf 91       	pop	r28
    4526:	df 91       	pop	r29
    4528:	08 95       	ret

0000452a <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    452a:	df 93       	push	r29
    452c:	cf 93       	push	r28
    452e:	00 d0       	rcall	.+0      	; 0x4530 <prvIdleTask+0x6>
    4530:	cd b7       	in	r28, 0x3d	; 61
    4532:	de b7       	in	r29, 0x3e	; 62
    4534:	9a 83       	std	Y+2, r25	; 0x02
    4536:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    4538:	0e 94 e2 22 	call	0x45c4	; 0x45c4 <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    453c:	80 91 b1 07 	lds	r24, 0x07B1
    4540:	82 30       	cpi	r24, 0x02	; 2
    4542:	d0 f3       	brcs	.-12     	; 0x4538 <prvIdleTask+0xe>
                {
                    taskYIELD();
    4544:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
    4548:	f7 cf       	rjmp	.-18     	; 0x4538 <prvIdleTask+0xe>

0000454a <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    454a:	df 93       	push	r29
    454c:	cf 93       	push	r28
    454e:	0f 92       	push	r0
    4550:	cd b7       	in	r28, 0x3d	; 61
    4552:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4554:	19 82       	std	Y+1, r1	; 0x01
    4556:	13 c0       	rjmp	.+38     	; 0x457e <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4558:	89 81       	ldd	r24, Y+1	; 0x01
    455a:	28 2f       	mov	r18, r24
    455c:	30 e0       	ldi	r19, 0x00	; 0
    455e:	c9 01       	movw	r24, r18
    4560:	88 0f       	add	r24, r24
    4562:	99 1f       	adc	r25, r25
    4564:	88 0f       	add	r24, r24
    4566:	99 1f       	adc	r25, r25
    4568:	88 0f       	add	r24, r24
    456a:	99 1f       	adc	r25, r25
    456c:	82 0f       	add	r24, r18
    456e:	93 1f       	adc	r25, r19
    4570:	8f 54       	subi	r24, 0x4F	; 79
    4572:	98 4f       	sbci	r25, 0xF8	; 248
    4574:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4578:	89 81       	ldd	r24, Y+1	; 0x01
    457a:	8f 5f       	subi	r24, 0xFF	; 255
    457c:	89 83       	std	Y+1, r24	; 0x01
    457e:	89 81       	ldd	r24, Y+1	; 0x01
    4580:	84 30       	cpi	r24, 0x04	; 4
    4582:	50 f3       	brcs	.-44     	; 0x4558 <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    4584:	85 ed       	ldi	r24, 0xD5	; 213
    4586:	97 e0       	ldi	r25, 0x07	; 7
    4588:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    458c:	8e ed       	ldi	r24, 0xDE	; 222
    458e:	97 e0       	ldi	r25, 0x07	; 7
    4590:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4594:	8b ee       	ldi	r24, 0xEB	; 235
    4596:	97 e0       	ldi	r25, 0x07	; 7
    4598:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
    459c:	84 ef       	ldi	r24, 0xF4	; 244
    459e:	97 e0       	ldi	r25, 0x07	; 7
    45a0:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    45a4:	85 ed       	ldi	r24, 0xD5	; 213
    45a6:	97 e0       	ldi	r25, 0x07	; 7
    45a8:	90 93 e8 07 	sts	0x07E8, r25
    45ac:	80 93 e7 07 	sts	0x07E7, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    45b0:	8e ed       	ldi	r24, 0xDE	; 222
    45b2:	97 e0       	ldi	r25, 0x07	; 7
    45b4:	90 93 ea 07 	sts	0x07EA, r25
    45b8:	80 93 e9 07 	sts	0x07E9, r24
}
    45bc:	0f 90       	pop	r0
    45be:	cf 91       	pop	r28
    45c0:	df 91       	pop	r29
    45c2:	08 95       	ret

000045c4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    45c4:	df 93       	push	r29
    45c6:	cf 93       	push	r28
    45c8:	cd b7       	in	r28, 0x3d	; 61
    45ca:	de b7       	in	r29, 0x3e	; 62

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    45cc:	cf 91       	pop	r28
    45ce:	df 91       	pop	r29
    45d0:	08 95       	ret

000045d2 <vTaskGetInfo>:

    void vTaskGetInfo( TaskHandle_t xTask,
                       TaskStatus_t * pxTaskStatus,
                       BaseType_t xGetFreeStackSpace,
                       eTaskState eState )
    {
    45d2:	df 93       	push	r29
    45d4:	cf 93       	push	r28
    45d6:	cd b7       	in	r28, 0x3d	; 61
    45d8:	de b7       	in	r29, 0x3e	; 62
    45da:	2a 97       	sbiw	r28, 0x0a	; 10
    45dc:	0f b6       	in	r0, 0x3f	; 63
    45de:	f8 94       	cli
    45e0:	de bf       	out	0x3e, r29	; 62
    45e2:	0f be       	out	0x3f, r0	; 63
    45e4:	cd bf       	out	0x3d, r28	; 61
    45e6:	9c 83       	std	Y+4, r25	; 0x04
    45e8:	8b 83       	std	Y+3, r24	; 0x03
    45ea:	7e 83       	std	Y+6, r23	; 0x06
    45ec:	6d 83       	std	Y+5, r22	; 0x05
    45ee:	4f 83       	std	Y+7, r20	; 0x07
    45f0:	28 87       	std	Y+8, r18	; 0x08
        TCB_t * pxTCB;

        /* xTask is NULL then get the state of the calling task. */
        pxTCB = prvGetTCBFromHandle( xTask );
    45f2:	8b 81       	ldd	r24, Y+3	; 0x03
    45f4:	9c 81       	ldd	r25, Y+4	; 0x04
    45f6:	00 97       	sbiw	r24, 0x00	; 0
    45f8:	39 f4       	brne	.+14     	; 0x4608 <vTaskGetInfo+0x36>
    45fa:	80 91 a0 07 	lds	r24, 0x07A0
    45fe:	90 91 a1 07 	lds	r25, 0x07A1
    4602:	9a 87       	std	Y+10, r25	; 0x0a
    4604:	89 87       	std	Y+9, r24	; 0x09
    4606:	04 c0       	rjmp	.+8      	; 0x4610 <vTaskGetInfo+0x3e>
    4608:	8b 81       	ldd	r24, Y+3	; 0x03
    460a:	9c 81       	ldd	r25, Y+4	; 0x04
    460c:	9a 87       	std	Y+10, r25	; 0x0a
    460e:	89 87       	std	Y+9, r24	; 0x09
    4610:	89 85       	ldd	r24, Y+9	; 0x09
    4612:	9a 85       	ldd	r25, Y+10	; 0x0a
    4614:	9a 83       	std	Y+2, r25	; 0x02
    4616:	89 83       	std	Y+1, r24	; 0x01

        pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
    4618:	ed 81       	ldd	r30, Y+5	; 0x05
    461a:	fe 81       	ldd	r31, Y+6	; 0x06
    461c:	89 81       	ldd	r24, Y+1	; 0x01
    461e:	9a 81       	ldd	r25, Y+2	; 0x02
    4620:	91 83       	std	Z+1, r25	; 0x01
    4622:	80 83       	st	Z, r24
        pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
    4624:	89 81       	ldd	r24, Y+1	; 0x01
    4626:	9a 81       	ldd	r25, Y+2	; 0x02
    4628:	49 96       	adiw	r24, 0x19	; 25
    462a:	ed 81       	ldd	r30, Y+5	; 0x05
    462c:	fe 81       	ldd	r31, Y+6	; 0x06
    462e:	93 83       	std	Z+3, r25	; 0x03
    4630:	82 83       	std	Z+2, r24	; 0x02
        pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
    4632:	e9 81       	ldd	r30, Y+1	; 0x01
    4634:	fa 81       	ldd	r31, Y+2	; 0x02
    4636:	86 89       	ldd	r24, Z+22	; 0x16
    4638:	ed 81       	ldd	r30, Y+5	; 0x05
    463a:	fe 81       	ldd	r31, Y+6	; 0x06
    463c:	86 83       	std	Z+6, r24	; 0x06
        pxTaskStatus->pxStackBase = pxTCB->pxStack;
    463e:	e9 81       	ldd	r30, Y+1	; 0x01
    4640:	fa 81       	ldd	r31, Y+2	; 0x02
    4642:	87 89       	ldd	r24, Z+23	; 0x17
    4644:	90 8d       	ldd	r25, Z+24	; 0x18
    4646:	ed 81       	ldd	r30, Y+5	; 0x05
    4648:	fe 81       	ldd	r31, Y+6	; 0x06
    464a:	95 87       	std	Z+13, r25	; 0x0d
    464c:	84 87       	std	Z+12, r24	; 0x0c
        pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
    464e:	e9 81       	ldd	r30, Y+1	; 0x01
    4650:	fa 81       	ldd	r31, Y+2	; 0x02
    4652:	85 a1       	ldd	r24, Z+37	; 0x25
    4654:	ed 81       	ldd	r30, Y+5	; 0x05
    4656:	fe 81       	ldd	r31, Y+6	; 0x06
    4658:	84 83       	std	Z+4, r24	; 0x04
            {
                pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
            }
        #else
            {
                pxTaskStatus->uxBasePriority = 0;
    465a:	ed 81       	ldd	r30, Y+5	; 0x05
    465c:	fe 81       	ldd	r31, Y+6	; 0x06
    465e:	17 82       	std	Z+7, r1	; 0x07
            {
                pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
            }
        #else
            {
                pxTaskStatus->ulRunTimeCounter = 0;
    4660:	ed 81       	ldd	r30, Y+5	; 0x05
    4662:	fe 81       	ldd	r31, Y+6	; 0x06
    4664:	10 86       	std	Z+8, r1	; 0x08
    4666:	11 86       	std	Z+9, r1	; 0x09
    4668:	12 86       	std	Z+10, r1	; 0x0a
    466a:	13 86       	std	Z+11, r1	; 0x0b
        #endif

        /* Obtaining the task state is a little fiddly, so is only done if the
         * value of eState passed into this function is eInvalid - otherwise the
         * state is just set to whatever is passed in. */
        if( eState != eInvalid )
    466c:	88 85       	ldd	r24, Y+8	; 0x08
    466e:	85 30       	cpi	r24, 0x05	; 5
    4670:	19 f1       	breq	.+70     	; 0x46b8 <vTaskGetInfo+0xe6>
        {
            if( pxTCB == pxCurrentTCB )
    4672:	20 91 a0 07 	lds	r18, 0x07A0
    4676:	30 91 a1 07 	lds	r19, 0x07A1
    467a:	89 81       	ldd	r24, Y+1	; 0x01
    467c:	9a 81       	ldd	r25, Y+2	; 0x02
    467e:	82 17       	cp	r24, r18
    4680:	93 07       	cpc	r25, r19
    4682:	21 f4       	brne	.+8      	; 0x468c <vTaskGetInfo+0xba>
            {
                pxTaskStatus->eCurrentState = eRunning;
    4684:	ed 81       	ldd	r30, Y+5	; 0x05
    4686:	fe 81       	ldd	r31, Y+6	; 0x06
    4688:	15 82       	std	Z+5, r1	; 0x05
    468a:	1d c0       	rjmp	.+58     	; 0x46c6 <vTaskGetInfo+0xf4>
            }
            else
            {
                pxTaskStatus->eCurrentState = eState;
    468c:	ed 81       	ldd	r30, Y+5	; 0x05
    468e:	fe 81       	ldd	r31, Y+6	; 0x06
    4690:	88 85       	ldd	r24, Y+8	; 0x08
    4692:	85 83       	std	Z+5, r24	; 0x05
                #if ( INCLUDE_vTaskSuspend == 1 )
                    {
                        /* If the task is in the suspended list then there is a
                         *  chance it is actually just blocked indefinitely - so really
                         *  it should be reported as being in the Blocked state. */
                        if( eState == eSuspended )
    4694:	88 85       	ldd	r24, Y+8	; 0x08
    4696:	83 30       	cpi	r24, 0x03	; 3
    4698:	b1 f4       	brne	.+44     	; 0x46c6 <vTaskGetInfo+0xf4>
                        {
                            vTaskSuspendAll();
    469a:	0e 94 65 1d 	call	0x3aca	; 0x3aca <vTaskSuspendAll>
                            {
                                if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    469e:	e9 81       	ldd	r30, Y+1	; 0x01
    46a0:	fa 81       	ldd	r31, Y+2	; 0x02
    46a2:	84 89       	ldd	r24, Z+20	; 0x14
    46a4:	95 89       	ldd	r25, Z+21	; 0x15
    46a6:	00 97       	sbiw	r24, 0x00	; 0
    46a8:	21 f0       	breq	.+8      	; 0x46b2 <vTaskGetInfo+0xe0>
                                {
                                    pxTaskStatus->eCurrentState = eBlocked;
    46aa:	ed 81       	ldd	r30, Y+5	; 0x05
    46ac:	fe 81       	ldd	r31, Y+6	; 0x06
    46ae:	82 e0       	ldi	r24, 0x02	; 2
    46b0:	85 83       	std	Z+5, r24	; 0x05
                                }
                            }
                            ( void ) xTaskResumeAll();
    46b2:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <xTaskResumeAll>
    46b6:	07 c0       	rjmp	.+14     	; 0x46c6 <vTaskGetInfo+0xf4>
                #endif /* INCLUDE_vTaskSuspend */
            }
        }
        else
        {
            pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
    46b8:	89 81       	ldd	r24, Y+1	; 0x01
    46ba:	9a 81       	ldd	r25, Y+2	; 0x02
    46bc:	0e 94 1d 1b 	call	0x363a	; 0x363a <eTaskGetState>
    46c0:	ed 81       	ldd	r30, Y+5	; 0x05
    46c2:	fe 81       	ldd	r31, Y+6	; 0x06
    46c4:	85 83       	std	Z+5, r24	; 0x05
        }

        /* Obtaining the stack space takes some time, so the xGetFreeStackSpace
         * parameter is provided to allow it to be skipped. */
        if( xGetFreeStackSpace != pdFALSE )
    46c6:	8f 81       	ldd	r24, Y+7	; 0x07
    46c8:	88 23       	and	r24, r24
    46ca:	59 f0       	breq	.+22     	; 0x46e2 <vTaskGetInfo+0x110>
                {
                    pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
                }
            #else
                {
                    pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
    46cc:	e9 81       	ldd	r30, Y+1	; 0x01
    46ce:	fa 81       	ldd	r31, Y+2	; 0x02
    46d0:	87 89       	ldd	r24, Z+23	; 0x17
    46d2:	90 8d       	ldd	r25, Z+24	; 0x18
    46d4:	0e 94 18 24 	call	0x4830	; 0x4830 <prvTaskCheckFreeStackSpace>
    46d8:	ed 81       	ldd	r30, Y+5	; 0x05
    46da:	fe 81       	ldd	r31, Y+6	; 0x06
    46dc:	97 87       	std	Z+15, r25	; 0x0f
    46de:	86 87       	std	Z+14, r24	; 0x0e
    46e0:	04 c0       	rjmp	.+8      	; 0x46ea <vTaskGetInfo+0x118>
                }
            #endif
        }
        else
        {
            pxTaskStatus->usStackHighWaterMark = 0;
    46e2:	ed 81       	ldd	r30, Y+5	; 0x05
    46e4:	fe 81       	ldd	r31, Y+6	; 0x06
    46e6:	17 86       	std	Z+15, r1	; 0x0f
    46e8:	16 86       	std	Z+14, r1	; 0x0e
        }
    }
    46ea:	2a 96       	adiw	r28, 0x0a	; 10
    46ec:	0f b6       	in	r0, 0x3f	; 63
    46ee:	f8 94       	cli
    46f0:	de bf       	out	0x3e, r29	; 62
    46f2:	0f be       	out	0x3f, r0	; 63
    46f4:	cd bf       	out	0x3d, r28	; 61
    46f6:	cf 91       	pop	r28
    46f8:	df 91       	pop	r29
    46fa:	08 95       	ret

000046fc <prvListTasksWithinSingleList>:
#if ( configUSE_TRACE_FACILITY == 1 )

    static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
                                                     List_t * pxList,
                                                     eTaskState eState )
    {
    46fc:	df 93       	push	r29
    46fe:	cf 93       	push	r28
    4700:	cd b7       	in	r28, 0x3d	; 61
    4702:	de b7       	in	r29, 0x3e	; 62
    4704:	2e 97       	sbiw	r28, 0x0e	; 14
    4706:	0f b6       	in	r0, 0x3f	; 63
    4708:	f8 94       	cli
    470a:	de bf       	out	0x3e, r29	; 62
    470c:	0f be       	out	0x3f, r0	; 63
    470e:	cd bf       	out	0x3d, r28	; 61
    4710:	9b 87       	std	Y+11, r25	; 0x0b
    4712:	8a 87       	std	Y+10, r24	; 0x0a
    4714:	7d 87       	std	Y+13, r23	; 0x0d
    4716:	6c 87       	std	Y+12, r22	; 0x0c
    4718:	4e 87       	std	Y+14, r20	; 0x0e
        configLIST_VOLATILE TCB_t * pxNextTCB, * pxFirstTCB;
        UBaseType_t uxTask = 0;
    471a:	1d 82       	std	Y+5, r1	; 0x05

        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
    471c:	ec 85       	ldd	r30, Y+12	; 0x0c
    471e:	fd 85       	ldd	r31, Y+13	; 0x0d
    4720:	80 81       	ld	r24, Z
    4722:	88 23       	and	r24, r24
    4724:	09 f4       	brne	.+2      	; 0x4728 <prvListTasksWithinSingleList+0x2c>
    4726:	7a c0       	rjmp	.+244    	; 0x481c <prvListTasksWithinSingleList+0x120>
        {
            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4728:	8c 85       	ldd	r24, Y+12	; 0x0c
    472a:	9d 85       	ldd	r25, Y+13	; 0x0d
    472c:	9c 83       	std	Y+4, r25	; 0x04
    472e:	8b 83       	std	Y+3, r24	; 0x03
    4730:	eb 81       	ldd	r30, Y+3	; 0x03
    4732:	fc 81       	ldd	r31, Y+4	; 0x04
    4734:	01 80       	ldd	r0, Z+1	; 0x01
    4736:	f2 81       	ldd	r31, Z+2	; 0x02
    4738:	e0 2d       	mov	r30, r0
    473a:	82 81       	ldd	r24, Z+2	; 0x02
    473c:	93 81       	ldd	r25, Z+3	; 0x03
    473e:	eb 81       	ldd	r30, Y+3	; 0x03
    4740:	fc 81       	ldd	r31, Y+4	; 0x04
    4742:	92 83       	std	Z+2, r25	; 0x02
    4744:	81 83       	std	Z+1, r24	; 0x01
    4746:	eb 81       	ldd	r30, Y+3	; 0x03
    4748:	fc 81       	ldd	r31, Y+4	; 0x04
    474a:	21 81       	ldd	r18, Z+1	; 0x01
    474c:	32 81       	ldd	r19, Z+2	; 0x02
    474e:	8b 81       	ldd	r24, Y+3	; 0x03
    4750:	9c 81       	ldd	r25, Y+4	; 0x04
    4752:	03 96       	adiw	r24, 0x03	; 3
    4754:	28 17       	cp	r18, r24
    4756:	39 07       	cpc	r19, r25
    4758:	59 f4       	brne	.+22     	; 0x4770 <prvListTasksWithinSingleList+0x74>
    475a:	eb 81       	ldd	r30, Y+3	; 0x03
    475c:	fc 81       	ldd	r31, Y+4	; 0x04
    475e:	01 80       	ldd	r0, Z+1	; 0x01
    4760:	f2 81       	ldd	r31, Z+2	; 0x02
    4762:	e0 2d       	mov	r30, r0
    4764:	82 81       	ldd	r24, Z+2	; 0x02
    4766:	93 81       	ldd	r25, Z+3	; 0x03
    4768:	eb 81       	ldd	r30, Y+3	; 0x03
    476a:	fc 81       	ldd	r31, Y+4	; 0x04
    476c:	92 83       	std	Z+2, r25	; 0x02
    476e:	81 83       	std	Z+1, r24	; 0x01
    4770:	eb 81       	ldd	r30, Y+3	; 0x03
    4772:	fc 81       	ldd	r31, Y+4	; 0x04
    4774:	01 80       	ldd	r0, Z+1	; 0x01
    4776:	f2 81       	ldd	r31, Z+2	; 0x02
    4778:	e0 2d       	mov	r30, r0
    477a:	86 81       	ldd	r24, Z+6	; 0x06
    477c:	97 81       	ldd	r25, Z+7	; 0x07
    477e:	9f 83       	std	Y+7, r25	; 0x07
    4780:	8e 83       	std	Y+6, r24	; 0x06
             * pxTaskStatusArray array for each task that is referenced from
             * pxList.  See the definition of TaskStatus_t in task.h for the
             * meaning of each TaskStatus_t structure member. */
            do
            {
                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4782:	8c 85       	ldd	r24, Y+12	; 0x0c
    4784:	9d 85       	ldd	r25, Y+13	; 0x0d
    4786:	9a 83       	std	Y+2, r25	; 0x02
    4788:	89 83       	std	Y+1, r24	; 0x01
    478a:	e9 81       	ldd	r30, Y+1	; 0x01
    478c:	fa 81       	ldd	r31, Y+2	; 0x02
    478e:	01 80       	ldd	r0, Z+1	; 0x01
    4790:	f2 81       	ldd	r31, Z+2	; 0x02
    4792:	e0 2d       	mov	r30, r0
    4794:	82 81       	ldd	r24, Z+2	; 0x02
    4796:	93 81       	ldd	r25, Z+3	; 0x03
    4798:	e9 81       	ldd	r30, Y+1	; 0x01
    479a:	fa 81       	ldd	r31, Y+2	; 0x02
    479c:	92 83       	std	Z+2, r25	; 0x02
    479e:	81 83       	std	Z+1, r24	; 0x01
    47a0:	e9 81       	ldd	r30, Y+1	; 0x01
    47a2:	fa 81       	ldd	r31, Y+2	; 0x02
    47a4:	21 81       	ldd	r18, Z+1	; 0x01
    47a6:	32 81       	ldd	r19, Z+2	; 0x02
    47a8:	89 81       	ldd	r24, Y+1	; 0x01
    47aa:	9a 81       	ldd	r25, Y+2	; 0x02
    47ac:	03 96       	adiw	r24, 0x03	; 3
    47ae:	28 17       	cp	r18, r24
    47b0:	39 07       	cpc	r19, r25
    47b2:	59 f4       	brne	.+22     	; 0x47ca <prvListTasksWithinSingleList+0xce>
    47b4:	e9 81       	ldd	r30, Y+1	; 0x01
    47b6:	fa 81       	ldd	r31, Y+2	; 0x02
    47b8:	01 80       	ldd	r0, Z+1	; 0x01
    47ba:	f2 81       	ldd	r31, Z+2	; 0x02
    47bc:	e0 2d       	mov	r30, r0
    47be:	82 81       	ldd	r24, Z+2	; 0x02
    47c0:	93 81       	ldd	r25, Z+3	; 0x03
    47c2:	e9 81       	ldd	r30, Y+1	; 0x01
    47c4:	fa 81       	ldd	r31, Y+2	; 0x02
    47c6:	92 83       	std	Z+2, r25	; 0x02
    47c8:	81 83       	std	Z+1, r24	; 0x01
    47ca:	e9 81       	ldd	r30, Y+1	; 0x01
    47cc:	fa 81       	ldd	r31, Y+2	; 0x02
    47ce:	01 80       	ldd	r0, Z+1	; 0x01
    47d0:	f2 81       	ldd	r31, Z+2	; 0x02
    47d2:	e0 2d       	mov	r30, r0
    47d4:	86 81       	ldd	r24, Z+6	; 0x06
    47d6:	97 81       	ldd	r25, Z+7	; 0x07
    47d8:	99 87       	std	Y+9, r25	; 0x09
    47da:	88 87       	std	Y+8, r24	; 0x08
                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
    47dc:	8d 81       	ldd	r24, Y+5	; 0x05
    47de:	88 2f       	mov	r24, r24
    47e0:	90 e0       	ldi	r25, 0x00	; 0
    47e2:	9c 01       	movw	r18, r24
    47e4:	22 95       	swap	r18
    47e6:	32 95       	swap	r19
    47e8:	30 7f       	andi	r19, 0xF0	; 240
    47ea:	32 27       	eor	r19, r18
    47ec:	20 7f       	andi	r18, 0xF0	; 240
    47ee:	32 27       	eor	r19, r18
    47f0:	8a 85       	ldd	r24, Y+10	; 0x0a
    47f2:	9b 85       	ldd	r25, Y+11	; 0x0b
    47f4:	28 0f       	add	r18, r24
    47f6:	39 1f       	adc	r19, r25
    47f8:	88 85       	ldd	r24, Y+8	; 0x08
    47fa:	99 85       	ldd	r25, Y+9	; 0x09
    47fc:	b9 01       	movw	r22, r18
    47fe:	41 e0       	ldi	r20, 0x01	; 1
    4800:	2e 85       	ldd	r18, Y+14	; 0x0e
    4802:	0e 94 e9 22 	call	0x45d2	; 0x45d2 <vTaskGetInfo>
                uxTask++;
    4806:	8d 81       	ldd	r24, Y+5	; 0x05
    4808:	8f 5f       	subi	r24, 0xFF	; 255
    480a:	8d 83       	std	Y+5, r24	; 0x05
            } while( pxNextTCB != pxFirstTCB );
    480c:	28 85       	ldd	r18, Y+8	; 0x08
    480e:	39 85       	ldd	r19, Y+9	; 0x09
    4810:	8e 81       	ldd	r24, Y+6	; 0x06
    4812:	9f 81       	ldd	r25, Y+7	; 0x07
    4814:	28 17       	cp	r18, r24
    4816:	39 07       	cpc	r19, r25
    4818:	09 f0       	breq	.+2      	; 0x481c <prvListTasksWithinSingleList+0x120>
    481a:	b3 cf       	rjmp	.-154    	; 0x4782 <prvListTasksWithinSingleList+0x86>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return uxTask;
    481c:	8d 81       	ldd	r24, Y+5	; 0x05
    }
    481e:	2e 96       	adiw	r28, 0x0e	; 14
    4820:	0f b6       	in	r0, 0x3f	; 63
    4822:	f8 94       	cli
    4824:	de bf       	out	0x3e, r29	; 62
    4826:	0f be       	out	0x3f, r0	; 63
    4828:	cd bf       	out	0x3d, r28	; 61
    482a:	cf 91       	pop	r28
    482c:	df 91       	pop	r29
    482e:	08 95       	ret

00004830 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
    4830:	df 93       	push	r29
    4832:	cf 93       	push	r28
    4834:	00 d0       	rcall	.+0      	; 0x4836 <prvTaskCheckFreeStackSpace+0x6>
    4836:	00 d0       	rcall	.+0      	; 0x4838 <prvTaskCheckFreeStackSpace+0x8>
    4838:	00 d0       	rcall	.+0      	; 0x483a <prvTaskCheckFreeStackSpace+0xa>
    483a:	cd b7       	in	r28, 0x3d	; 61
    483c:	de b7       	in	r29, 0x3e	; 62
    483e:	9e 83       	std	Y+6, r25	; 0x06
    4840:	8d 83       	std	Y+5, r24	; 0x05
        uint32_t ulCount = 0U;
    4842:	19 82       	std	Y+1, r1	; 0x01
    4844:	1a 82       	std	Y+2, r1	; 0x02
    4846:	1b 82       	std	Y+3, r1	; 0x03
    4848:	1c 82       	std	Y+4, r1	; 0x04
    484a:	10 c0       	rjmp	.+32     	; 0x486c <prvTaskCheckFreeStackSpace+0x3c>

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
        {
            pucStackByte -= portSTACK_GROWTH;
    484c:	8d 81       	ldd	r24, Y+5	; 0x05
    484e:	9e 81       	ldd	r25, Y+6	; 0x06
    4850:	01 96       	adiw	r24, 0x01	; 1
    4852:	9e 83       	std	Y+6, r25	; 0x06
    4854:	8d 83       	std	Y+5, r24	; 0x05
            ulCount++;
    4856:	89 81       	ldd	r24, Y+1	; 0x01
    4858:	9a 81       	ldd	r25, Y+2	; 0x02
    485a:	ab 81       	ldd	r26, Y+3	; 0x03
    485c:	bc 81       	ldd	r27, Y+4	; 0x04
    485e:	01 96       	adiw	r24, 0x01	; 1
    4860:	a1 1d       	adc	r26, r1
    4862:	b1 1d       	adc	r27, r1
    4864:	89 83       	std	Y+1, r24	; 0x01
    4866:	9a 83       	std	Y+2, r25	; 0x02
    4868:	ab 83       	std	Y+3, r26	; 0x03
    486a:	bc 83       	std	Y+4, r27	; 0x04

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
        uint32_t ulCount = 0U;

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    486c:	ed 81       	ldd	r30, Y+5	; 0x05
    486e:	fe 81       	ldd	r31, Y+6	; 0x06
    4870:	80 81       	ld	r24, Z
    4872:	85 3a       	cpi	r24, 0xA5	; 165
    4874:	59 f3       	breq	.-42     	; 0x484c <prvTaskCheckFreeStackSpace+0x1c>
            ulCount++;
        }

        ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */

        return ( configSTACK_DEPTH_TYPE ) ulCount;
    4876:	89 81       	ldd	r24, Y+1	; 0x01
    4878:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    487a:	26 96       	adiw	r28, 0x06	; 6
    487c:	0f b6       	in	r0, 0x3f	; 63
    487e:	f8 94       	cli
    4880:	de bf       	out	0x3e, r29	; 62
    4882:	0f be       	out	0x3f, r0	; 63
    4884:	cd bf       	out	0x3d, r28	; 61
    4886:	cf 91       	pop	r28
    4888:	df 91       	pop	r29
    488a:	08 95       	ret

0000488c <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    488c:	df 93       	push	r29
    488e:	cf 93       	push	r28
    4890:	cd b7       	in	r28, 0x3d	; 61
    4892:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4894:	e0 91 e7 07 	lds	r30, 0x07E7
    4898:	f0 91 e8 07 	lds	r31, 0x07E8
    489c:	80 81       	ld	r24, Z
    489e:	88 23       	and	r24, r24
    48a0:	39 f4       	brne	.+14     	; 0x48b0 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    48a2:	8f ef       	ldi	r24, 0xFF	; 255
    48a4:	9f ef       	ldi	r25, 0xFF	; 255
    48a6:	90 93 ad 07 	sts	0x07AD, r25
    48aa:	80 93 ac 07 	sts	0x07AC, r24
    48ae:	0d c0       	rjmp	.+26     	; 0x48ca <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    48b0:	e0 91 e7 07 	lds	r30, 0x07E7
    48b4:	f0 91 e8 07 	lds	r31, 0x07E8
    48b8:	05 80       	ldd	r0, Z+5	; 0x05
    48ba:	f6 81       	ldd	r31, Z+6	; 0x06
    48bc:	e0 2d       	mov	r30, r0
    48be:	80 81       	ld	r24, Z
    48c0:	91 81       	ldd	r25, Z+1	; 0x01
    48c2:	90 93 ad 07 	sts	0x07AD, r25
    48c6:	80 93 ac 07 	sts	0x07AC, r24
    }
}
    48ca:	cf 91       	pop	r28
    48cc:	df 91       	pop	r29
    48ce:	08 95       	ret

000048d0 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    48d0:	df 93       	push	r29
    48d2:	cf 93       	push	r28
    48d4:	00 d0       	rcall	.+0      	; 0x48d6 <uxTaskResetEventItemValue+0x6>
    48d6:	cd b7       	in	r28, 0x3d	; 61
    48d8:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    48da:	e0 91 a0 07 	lds	r30, 0x07A0
    48de:	f0 91 a1 07 	lds	r31, 0x07A1
    48e2:	84 85       	ldd	r24, Z+12	; 0x0c
    48e4:	95 85       	ldd	r25, Z+13	; 0x0d
    48e6:	9a 83       	std	Y+2, r25	; 0x02
    48e8:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    48ea:	a0 91 a0 07 	lds	r26, 0x07A0
    48ee:	b0 91 a1 07 	lds	r27, 0x07A1
    48f2:	e0 91 a0 07 	lds	r30, 0x07A0
    48f6:	f0 91 a1 07 	lds	r31, 0x07A1
    48fa:	86 89       	ldd	r24, Z+22	; 0x16
    48fc:	28 2f       	mov	r18, r24
    48fe:	30 e0       	ldi	r19, 0x00	; 0
    4900:	84 e0       	ldi	r24, 0x04	; 4
    4902:	90 e0       	ldi	r25, 0x00	; 0
    4904:	82 1b       	sub	r24, r18
    4906:	93 0b       	sbc	r25, r19
    4908:	1d 96       	adiw	r26, 0x0d	; 13
    490a:	9c 93       	st	X, r25
    490c:	8e 93       	st	-X, r24
    490e:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    4910:	89 81       	ldd	r24, Y+1	; 0x01
    4912:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4914:	0f 90       	pop	r0
    4916:	0f 90       	pop	r0
    4918:	cf 91       	pop	r28
    491a:	df 91       	pop	r29
    491c:	08 95       	ret

0000491e <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    491e:	df 93       	push	r29
    4920:	cf 93       	push	r28
    4922:	cd b7       	in	r28, 0x3d	; 61
    4924:	de b7       	in	r29, 0x3e	; 62
    4926:	28 97       	sbiw	r28, 0x08	; 8
    4928:	0f b6       	in	r0, 0x3f	; 63
    492a:	f8 94       	cli
    492c:	de bf       	out	0x3e, r29	; 62
    492e:	0f be       	out	0x3f, r0	; 63
    4930:	cd bf       	out	0x3d, r28	; 61
    4932:	8d 83       	std	Y+5, r24	; 0x05
    4934:	6e 83       	std	Y+6, r22	; 0x06
    4936:	58 87       	std	Y+8, r21	; 0x08
    4938:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    493a:	0f b6       	in	r0, 0x3f	; 63
    493c:	f8 94       	cli
    493e:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    4940:	20 91 a0 07 	lds	r18, 0x07A0
    4944:	30 91 a1 07 	lds	r19, 0x07A1
    4948:	8d 81       	ldd	r24, Y+5	; 0x05
    494a:	88 2f       	mov	r24, r24
    494c:	90 e0       	ldi	r25, 0x00	; 0
    494e:	88 0f       	add	r24, r24
    4950:	99 1f       	adc	r25, r25
    4952:	88 0f       	add	r24, r24
    4954:	99 1f       	adc	r25, r25
    4956:	82 0f       	add	r24, r18
    4958:	93 1f       	adc	r25, r19
    495a:	fc 01       	movw	r30, r24
    495c:	b7 96       	adiw	r30, 0x27	; 39
    495e:	80 81       	ld	r24, Z
    4960:	91 81       	ldd	r25, Z+1	; 0x01
    4962:	a2 81       	ldd	r26, Z+2	; 0x02
    4964:	b3 81       	ldd	r27, Z+3	; 0x03
    4966:	00 97       	sbiw	r24, 0x00	; 0
    4968:	a1 05       	cpc	r26, r1
    496a:	b1 05       	cpc	r27, r1
    496c:	c1 f4       	brne	.+48     	; 0x499e <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    496e:	20 91 a0 07 	lds	r18, 0x07A0
    4972:	30 91 a1 07 	lds	r19, 0x07A1
    4976:	8d 81       	ldd	r24, Y+5	; 0x05
    4978:	88 2f       	mov	r24, r24
    497a:	90 e0       	ldi	r25, 0x00	; 0
    497c:	82 0f       	add	r24, r18
    497e:	93 1f       	adc	r25, r19
    4980:	fc 01       	movw	r30, r24
    4982:	bb 96       	adiw	r30, 0x2b	; 43
    4984:	81 e0       	ldi	r24, 0x01	; 1
    4986:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4988:	8f 81       	ldd	r24, Y+7	; 0x07
    498a:	98 85       	ldd	r25, Y+8	; 0x08
    498c:	00 97       	sbiw	r24, 0x00	; 0
    498e:	39 f0       	breq	.+14     	; 0x499e <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4990:	8f 81       	ldd	r24, Y+7	; 0x07
    4992:	98 85       	ldd	r25, Y+8	; 0x08
    4994:	61 e0       	ldi	r22, 0x01	; 1
    4996:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    499a:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    499e:	0f 90       	pop	r0
    49a0:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    49a2:	0f b6       	in	r0, 0x3f	; 63
    49a4:	f8 94       	cli
    49a6:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    49a8:	20 91 a0 07 	lds	r18, 0x07A0
    49ac:	30 91 a1 07 	lds	r19, 0x07A1
    49b0:	8d 81       	ldd	r24, Y+5	; 0x05
    49b2:	88 2f       	mov	r24, r24
    49b4:	90 e0       	ldi	r25, 0x00	; 0
    49b6:	88 0f       	add	r24, r24
    49b8:	99 1f       	adc	r25, r25
    49ba:	88 0f       	add	r24, r24
    49bc:	99 1f       	adc	r25, r25
    49be:	82 0f       	add	r24, r18
    49c0:	93 1f       	adc	r25, r19
    49c2:	fc 01       	movw	r30, r24
    49c4:	b7 96       	adiw	r30, 0x27	; 39
    49c6:	80 81       	ld	r24, Z
    49c8:	91 81       	ldd	r25, Z+1	; 0x01
    49ca:	a2 81       	ldd	r26, Z+2	; 0x02
    49cc:	b3 81       	ldd	r27, Z+3	; 0x03
    49ce:	89 83       	std	Y+1, r24	; 0x01
    49d0:	9a 83       	std	Y+2, r25	; 0x02
    49d2:	ab 83       	std	Y+3, r26	; 0x03
    49d4:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    49d6:	89 81       	ldd	r24, Y+1	; 0x01
    49d8:	9a 81       	ldd	r25, Y+2	; 0x02
    49da:	ab 81       	ldd	r26, Y+3	; 0x03
    49dc:	bc 81       	ldd	r27, Y+4	; 0x04
    49de:	00 97       	sbiw	r24, 0x00	; 0
    49e0:	a1 05       	cpc	r26, r1
    49e2:	b1 05       	cpc	r27, r1
    49e4:	a9 f1       	breq	.+106    	; 0x4a50 <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    49e6:	8e 81       	ldd	r24, Y+6	; 0x06
    49e8:	88 23       	and	r24, r24
    49ea:	a1 f0       	breq	.+40     	; 0x4a14 <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    49ec:	20 91 a0 07 	lds	r18, 0x07A0
    49f0:	30 91 a1 07 	lds	r19, 0x07A1
    49f4:	8d 81       	ldd	r24, Y+5	; 0x05
    49f6:	88 2f       	mov	r24, r24
    49f8:	90 e0       	ldi	r25, 0x00	; 0
    49fa:	88 0f       	add	r24, r24
    49fc:	99 1f       	adc	r25, r25
    49fe:	88 0f       	add	r24, r24
    4a00:	99 1f       	adc	r25, r25
    4a02:	82 0f       	add	r24, r18
    4a04:	93 1f       	adc	r25, r19
    4a06:	fc 01       	movw	r30, r24
    4a08:	b7 96       	adiw	r30, 0x27	; 39
    4a0a:	10 82       	st	Z, r1
    4a0c:	11 82       	std	Z+1, r1	; 0x01
    4a0e:	12 82       	std	Z+2, r1	; 0x02
    4a10:	13 82       	std	Z+3, r1	; 0x03
    4a12:	1e c0       	rjmp	.+60     	; 0x4a50 <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    4a14:	e0 91 a0 07 	lds	r30, 0x07A0
    4a18:	f0 91 a1 07 	lds	r31, 0x07A1
    4a1c:	8d 81       	ldd	r24, Y+5	; 0x05
    4a1e:	68 2f       	mov	r22, r24
    4a20:	70 e0       	ldi	r23, 0x00	; 0
    4a22:	89 81       	ldd	r24, Y+1	; 0x01
    4a24:	9a 81       	ldd	r25, Y+2	; 0x02
    4a26:	ab 81       	ldd	r26, Y+3	; 0x03
    4a28:	bc 81       	ldd	r27, Y+4	; 0x04
    4a2a:	9c 01       	movw	r18, r24
    4a2c:	ad 01       	movw	r20, r26
    4a2e:	21 50       	subi	r18, 0x01	; 1
    4a30:	30 40       	sbci	r19, 0x00	; 0
    4a32:	40 40       	sbci	r20, 0x00	; 0
    4a34:	50 40       	sbci	r21, 0x00	; 0
    4a36:	cb 01       	movw	r24, r22
    4a38:	88 0f       	add	r24, r24
    4a3a:	99 1f       	adc	r25, r25
    4a3c:	88 0f       	add	r24, r24
    4a3e:	99 1f       	adc	r25, r25
    4a40:	8e 0f       	add	r24, r30
    4a42:	9f 1f       	adc	r25, r31
    4a44:	fc 01       	movw	r30, r24
    4a46:	b7 96       	adiw	r30, 0x27	; 39
    4a48:	20 83       	st	Z, r18
    4a4a:	31 83       	std	Z+1, r19	; 0x01
    4a4c:	42 83       	std	Z+2, r20	; 0x02
    4a4e:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4a50:	20 91 a0 07 	lds	r18, 0x07A0
    4a54:	30 91 a1 07 	lds	r19, 0x07A1
    4a58:	8d 81       	ldd	r24, Y+5	; 0x05
    4a5a:	88 2f       	mov	r24, r24
    4a5c:	90 e0       	ldi	r25, 0x00	; 0
    4a5e:	82 0f       	add	r24, r18
    4a60:	93 1f       	adc	r25, r19
    4a62:	fc 01       	movw	r30, r24
    4a64:	bb 96       	adiw	r30, 0x2b	; 43
    4a66:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4a68:	0f 90       	pop	r0
    4a6a:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    4a6c:	89 81       	ldd	r24, Y+1	; 0x01
    4a6e:	9a 81       	ldd	r25, Y+2	; 0x02
    4a70:	ab 81       	ldd	r26, Y+3	; 0x03
    4a72:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    4a74:	bc 01       	movw	r22, r24
    4a76:	cd 01       	movw	r24, r26
    4a78:	28 96       	adiw	r28, 0x08	; 8
    4a7a:	0f b6       	in	r0, 0x3f	; 63
    4a7c:	f8 94       	cli
    4a7e:	de bf       	out	0x3e, r29	; 62
    4a80:	0f be       	out	0x3f, r0	; 63
    4a82:	cd bf       	out	0x3d, r28	; 61
    4a84:	cf 91       	pop	r28
    4a86:	df 91       	pop	r29
    4a88:	08 95       	ret

00004a8a <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    4a8a:	cf 92       	push	r12
    4a8c:	df 92       	push	r13
    4a8e:	ef 92       	push	r14
    4a90:	ff 92       	push	r15
    4a92:	0f 93       	push	r16
    4a94:	1f 93       	push	r17
    4a96:	df 93       	push	r29
    4a98:	cf 93       	push	r28
    4a9a:	cd b7       	in	r28, 0x3d	; 61
    4a9c:	de b7       	in	r29, 0x3e	; 62
    4a9e:	2e 97       	sbiw	r28, 0x0e	; 14
    4aa0:	0f b6       	in	r0, 0x3f	; 63
    4aa2:	f8 94       	cli
    4aa4:	de bf       	out	0x3e, r29	; 62
    4aa6:	0f be       	out	0x3f, r0	; 63
    4aa8:	cd bf       	out	0x3d, r28	; 61
    4aaa:	8a 83       	std	Y+2, r24	; 0x02
    4aac:	4b 83       	std	Y+3, r20	; 0x03
    4aae:	5c 83       	std	Y+4, r21	; 0x04
    4ab0:	6d 83       	std	Y+5, r22	; 0x05
    4ab2:	7e 83       	std	Y+6, r23	; 0x06
    4ab4:	0f 83       	std	Y+7, r16	; 0x07
    4ab6:	18 87       	std	Y+8, r17	; 0x08
    4ab8:	29 87       	std	Y+9, r18	; 0x09
    4aba:	3a 87       	std	Y+10, r19	; 0x0a
    4abc:	fc 86       	std	Y+12, r15	; 0x0c
    4abe:	eb 86       	std	Y+11, r14	; 0x0b
    4ac0:	de 86       	std	Y+14, r13	; 0x0e
    4ac2:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4ac4:	0f b6       	in	r0, 0x3f	; 63
    4ac6:	f8 94       	cli
    4ac8:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4aca:	20 91 a0 07 	lds	r18, 0x07A0
    4ace:	30 91 a1 07 	lds	r19, 0x07A1
    4ad2:	8a 81       	ldd	r24, Y+2	; 0x02
    4ad4:	88 2f       	mov	r24, r24
    4ad6:	90 e0       	ldi	r25, 0x00	; 0
    4ad8:	82 0f       	add	r24, r18
    4ada:	93 1f       	adc	r25, r19
    4adc:	fc 01       	movw	r30, r24
    4ade:	bb 96       	adiw	r30, 0x2b	; 43
    4ae0:	80 81       	ld	r24, Z
    4ae2:	82 30       	cpi	r24, 0x02	; 2
    4ae4:	09 f4       	brne	.+2      	; 0x4ae8 <xTaskGenericNotifyWait+0x5e>
    4ae6:	47 c0       	rjmp	.+142    	; 0x4b76 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    4ae8:	60 91 a0 07 	lds	r22, 0x07A0
    4aec:	70 91 a1 07 	lds	r23, 0x07A1
    4af0:	8a 81       	ldd	r24, Y+2	; 0x02
    4af2:	08 2f       	mov	r16, r24
    4af4:	10 e0       	ldi	r17, 0x00	; 0
    4af6:	8a 81       	ldd	r24, Y+2	; 0x02
    4af8:	88 2f       	mov	r24, r24
    4afa:	90 e0       	ldi	r25, 0x00	; 0
    4afc:	88 0f       	add	r24, r24
    4afe:	99 1f       	adc	r25, r25
    4b00:	88 0f       	add	r24, r24
    4b02:	99 1f       	adc	r25, r25
    4b04:	86 0f       	add	r24, r22
    4b06:	97 1f       	adc	r25, r23
    4b08:	fc 01       	movw	r30, r24
    4b0a:	b7 96       	adiw	r30, 0x27	; 39
    4b0c:	20 81       	ld	r18, Z
    4b0e:	31 81       	ldd	r19, Z+1	; 0x01
    4b10:	42 81       	ldd	r20, Z+2	; 0x02
    4b12:	53 81       	ldd	r21, Z+3	; 0x03
    4b14:	8b 81       	ldd	r24, Y+3	; 0x03
    4b16:	9c 81       	ldd	r25, Y+4	; 0x04
    4b18:	ad 81       	ldd	r26, Y+5	; 0x05
    4b1a:	be 81       	ldd	r27, Y+6	; 0x06
    4b1c:	80 95       	com	r24
    4b1e:	90 95       	com	r25
    4b20:	a0 95       	com	r26
    4b22:	b0 95       	com	r27
    4b24:	28 23       	and	r18, r24
    4b26:	39 23       	and	r19, r25
    4b28:	4a 23       	and	r20, r26
    4b2a:	5b 23       	and	r21, r27
    4b2c:	c8 01       	movw	r24, r16
    4b2e:	88 0f       	add	r24, r24
    4b30:	99 1f       	adc	r25, r25
    4b32:	88 0f       	add	r24, r24
    4b34:	99 1f       	adc	r25, r25
    4b36:	86 0f       	add	r24, r22
    4b38:	97 1f       	adc	r25, r23
    4b3a:	fc 01       	movw	r30, r24
    4b3c:	b7 96       	adiw	r30, 0x27	; 39
    4b3e:	20 83       	st	Z, r18
    4b40:	31 83       	std	Z+1, r19	; 0x01
    4b42:	42 83       	std	Z+2, r20	; 0x02
    4b44:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4b46:	20 91 a0 07 	lds	r18, 0x07A0
    4b4a:	30 91 a1 07 	lds	r19, 0x07A1
    4b4e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b50:	88 2f       	mov	r24, r24
    4b52:	90 e0       	ldi	r25, 0x00	; 0
    4b54:	82 0f       	add	r24, r18
    4b56:	93 1f       	adc	r25, r19
    4b58:	fc 01       	movw	r30, r24
    4b5a:	bb 96       	adiw	r30, 0x2b	; 43
    4b5c:	81 e0       	ldi	r24, 0x01	; 1
    4b5e:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4b60:	8d 85       	ldd	r24, Y+13	; 0x0d
    4b62:	9e 85       	ldd	r25, Y+14	; 0x0e
    4b64:	00 97       	sbiw	r24, 0x00	; 0
    4b66:	39 f0       	breq	.+14     	; 0x4b76 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4b68:	8d 85       	ldd	r24, Y+13	; 0x0d
    4b6a:	9e 85       	ldd	r25, Y+14	; 0x0e
    4b6c:	61 e0       	ldi	r22, 0x01	; 1
    4b6e:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4b72:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4b76:	0f 90       	pop	r0
    4b78:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4b7a:	0f b6       	in	r0, 0x3f	; 63
    4b7c:	f8 94       	cli
    4b7e:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    4b80:	8b 85       	ldd	r24, Y+11	; 0x0b
    4b82:	9c 85       	ldd	r25, Y+12	; 0x0c
    4b84:	00 97       	sbiw	r24, 0x00	; 0
    4b86:	c9 f0       	breq	.+50     	; 0x4bba <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4b88:	20 91 a0 07 	lds	r18, 0x07A0
    4b8c:	30 91 a1 07 	lds	r19, 0x07A1
    4b90:	8a 81       	ldd	r24, Y+2	; 0x02
    4b92:	88 2f       	mov	r24, r24
    4b94:	90 e0       	ldi	r25, 0x00	; 0
    4b96:	88 0f       	add	r24, r24
    4b98:	99 1f       	adc	r25, r25
    4b9a:	88 0f       	add	r24, r24
    4b9c:	99 1f       	adc	r25, r25
    4b9e:	82 0f       	add	r24, r18
    4ba0:	93 1f       	adc	r25, r19
    4ba2:	fc 01       	movw	r30, r24
    4ba4:	b7 96       	adiw	r30, 0x27	; 39
    4ba6:	80 81       	ld	r24, Z
    4ba8:	91 81       	ldd	r25, Z+1	; 0x01
    4baa:	a2 81       	ldd	r26, Z+2	; 0x02
    4bac:	b3 81       	ldd	r27, Z+3	; 0x03
    4bae:	eb 85       	ldd	r30, Y+11	; 0x0b
    4bb0:	fc 85       	ldd	r31, Y+12	; 0x0c
    4bb2:	80 83       	st	Z, r24
    4bb4:	91 83       	std	Z+1, r25	; 0x01
    4bb6:	a2 83       	std	Z+2, r26	; 0x02
    4bb8:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4bba:	20 91 a0 07 	lds	r18, 0x07A0
    4bbe:	30 91 a1 07 	lds	r19, 0x07A1
    4bc2:	8a 81       	ldd	r24, Y+2	; 0x02
    4bc4:	88 2f       	mov	r24, r24
    4bc6:	90 e0       	ldi	r25, 0x00	; 0
    4bc8:	82 0f       	add	r24, r18
    4bca:	93 1f       	adc	r25, r19
    4bcc:	fc 01       	movw	r30, r24
    4bce:	bb 96       	adiw	r30, 0x2b	; 43
    4bd0:	80 81       	ld	r24, Z
    4bd2:	82 30       	cpi	r24, 0x02	; 2
    4bd4:	11 f0       	breq	.+4      	; 0x4bda <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    4bd6:	19 82       	std	Y+1, r1	; 0x01
    4bd8:	31 c0       	rjmp	.+98     	; 0x4c3c <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    4bda:	60 91 a0 07 	lds	r22, 0x07A0
    4bde:	70 91 a1 07 	lds	r23, 0x07A1
    4be2:	8a 81       	ldd	r24, Y+2	; 0x02
    4be4:	08 2f       	mov	r16, r24
    4be6:	10 e0       	ldi	r17, 0x00	; 0
    4be8:	8a 81       	ldd	r24, Y+2	; 0x02
    4bea:	88 2f       	mov	r24, r24
    4bec:	90 e0       	ldi	r25, 0x00	; 0
    4bee:	88 0f       	add	r24, r24
    4bf0:	99 1f       	adc	r25, r25
    4bf2:	88 0f       	add	r24, r24
    4bf4:	99 1f       	adc	r25, r25
    4bf6:	86 0f       	add	r24, r22
    4bf8:	97 1f       	adc	r25, r23
    4bfa:	fc 01       	movw	r30, r24
    4bfc:	b7 96       	adiw	r30, 0x27	; 39
    4bfe:	20 81       	ld	r18, Z
    4c00:	31 81       	ldd	r19, Z+1	; 0x01
    4c02:	42 81       	ldd	r20, Z+2	; 0x02
    4c04:	53 81       	ldd	r21, Z+3	; 0x03
    4c06:	8f 81       	ldd	r24, Y+7	; 0x07
    4c08:	98 85       	ldd	r25, Y+8	; 0x08
    4c0a:	a9 85       	ldd	r26, Y+9	; 0x09
    4c0c:	ba 85       	ldd	r27, Y+10	; 0x0a
    4c0e:	80 95       	com	r24
    4c10:	90 95       	com	r25
    4c12:	a0 95       	com	r26
    4c14:	b0 95       	com	r27
    4c16:	28 23       	and	r18, r24
    4c18:	39 23       	and	r19, r25
    4c1a:	4a 23       	and	r20, r26
    4c1c:	5b 23       	and	r21, r27
    4c1e:	c8 01       	movw	r24, r16
    4c20:	88 0f       	add	r24, r24
    4c22:	99 1f       	adc	r25, r25
    4c24:	88 0f       	add	r24, r24
    4c26:	99 1f       	adc	r25, r25
    4c28:	86 0f       	add	r24, r22
    4c2a:	97 1f       	adc	r25, r23
    4c2c:	fc 01       	movw	r30, r24
    4c2e:	b7 96       	adiw	r30, 0x27	; 39
    4c30:	20 83       	st	Z, r18
    4c32:	31 83       	std	Z+1, r19	; 0x01
    4c34:	42 83       	std	Z+2, r20	; 0x02
    4c36:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    4c38:	81 e0       	ldi	r24, 0x01	; 1
    4c3a:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4c3c:	20 91 a0 07 	lds	r18, 0x07A0
    4c40:	30 91 a1 07 	lds	r19, 0x07A1
    4c44:	8a 81       	ldd	r24, Y+2	; 0x02
    4c46:	88 2f       	mov	r24, r24
    4c48:	90 e0       	ldi	r25, 0x00	; 0
    4c4a:	82 0f       	add	r24, r18
    4c4c:	93 1f       	adc	r25, r19
    4c4e:	fc 01       	movw	r30, r24
    4c50:	bb 96       	adiw	r30, 0x2b	; 43
    4c52:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4c54:	0f 90       	pop	r0
    4c56:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4c58:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4c5a:	2e 96       	adiw	r28, 0x0e	; 14
    4c5c:	0f b6       	in	r0, 0x3f	; 63
    4c5e:	f8 94       	cli
    4c60:	de bf       	out	0x3e, r29	; 62
    4c62:	0f be       	out	0x3f, r0	; 63
    4c64:	cd bf       	out	0x3d, r28	; 61
    4c66:	cf 91       	pop	r28
    4c68:	df 91       	pop	r29
    4c6a:	1f 91       	pop	r17
    4c6c:	0f 91       	pop	r16
    4c6e:	ff 90       	pop	r15
    4c70:	ef 90       	pop	r14
    4c72:	df 90       	pop	r13
    4c74:	cf 90       	pop	r12
    4c76:	08 95       	ret

00004c78 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    4c78:	ef 92       	push	r14
    4c7a:	ff 92       	push	r15
    4c7c:	0f 93       	push	r16
    4c7e:	1f 93       	push	r17
    4c80:	df 93       	push	r29
    4c82:	cf 93       	push	r28
    4c84:	cd b7       	in	r28, 0x3d	; 61
    4c86:	de b7       	in	r29, 0x3e	; 62
    4c88:	60 97       	sbiw	r28, 0x10	; 16
    4c8a:	0f b6       	in	r0, 0x3f	; 63
    4c8c:	f8 94       	cli
    4c8e:	de bf       	out	0x3e, r29	; 62
    4c90:	0f be       	out	0x3f, r0	; 63
    4c92:	cd bf       	out	0x3d, r28	; 61
    4c94:	9e 83       	std	Y+6, r25	; 0x06
    4c96:	8d 83       	std	Y+5, r24	; 0x05
    4c98:	6f 83       	std	Y+7, r22	; 0x07
    4c9a:	28 87       	std	Y+8, r18	; 0x08
    4c9c:	39 87       	std	Y+9, r19	; 0x09
    4c9e:	4a 87       	std	Y+10, r20	; 0x0a
    4ca0:	5b 87       	std	Y+11, r21	; 0x0b
    4ca2:	0c 87       	std	Y+12, r16	; 0x0c
    4ca4:	fe 86       	std	Y+14, r15	; 0x0e
    4ca6:	ed 86       	std	Y+13, r14	; 0x0d
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    4ca8:	81 e0       	ldi	r24, 0x01	; 1
    4caa:	8a 83       	std	Y+2, r24	; 0x02
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    4cac:	8d 81       	ldd	r24, Y+5	; 0x05
    4cae:	9e 81       	ldd	r25, Y+6	; 0x06
    4cb0:	9c 83       	std	Y+4, r25	; 0x04
    4cb2:	8b 83       	std	Y+3, r24	; 0x03

        taskENTER_CRITICAL();
    4cb4:	0f b6       	in	r0, 0x3f	; 63
    4cb6:	f8 94       	cli
    4cb8:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    4cba:	8d 85       	ldd	r24, Y+13	; 0x0d
    4cbc:	9e 85       	ldd	r25, Y+14	; 0x0e
    4cbe:	00 97       	sbiw	r24, 0x00	; 0
    4cc0:	b9 f0       	breq	.+46     	; 0x4cf0 <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4cc2:	8f 81       	ldd	r24, Y+7	; 0x07
    4cc4:	88 2f       	mov	r24, r24
    4cc6:	90 e0       	ldi	r25, 0x00	; 0
    4cc8:	2b 81       	ldd	r18, Y+3	; 0x03
    4cca:	3c 81       	ldd	r19, Y+4	; 0x04
    4ccc:	88 0f       	add	r24, r24
    4cce:	99 1f       	adc	r25, r25
    4cd0:	88 0f       	add	r24, r24
    4cd2:	99 1f       	adc	r25, r25
    4cd4:	82 0f       	add	r24, r18
    4cd6:	93 1f       	adc	r25, r19
    4cd8:	fc 01       	movw	r30, r24
    4cda:	b7 96       	adiw	r30, 0x27	; 39
    4cdc:	80 81       	ld	r24, Z
    4cde:	91 81       	ldd	r25, Z+1	; 0x01
    4ce0:	a2 81       	ldd	r26, Z+2	; 0x02
    4ce2:	b3 81       	ldd	r27, Z+3	; 0x03
    4ce4:	ed 85       	ldd	r30, Y+13	; 0x0d
    4ce6:	fe 85       	ldd	r31, Y+14	; 0x0e
    4ce8:	80 83       	st	Z, r24
    4cea:	91 83       	std	Z+1, r25	; 0x01
    4cec:	a2 83       	std	Z+2, r26	; 0x02
    4cee:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4cf0:	8f 81       	ldd	r24, Y+7	; 0x07
    4cf2:	28 2f       	mov	r18, r24
    4cf4:	30 e0       	ldi	r19, 0x00	; 0
    4cf6:	8b 81       	ldd	r24, Y+3	; 0x03
    4cf8:	9c 81       	ldd	r25, Y+4	; 0x04
    4cfa:	82 0f       	add	r24, r18
    4cfc:	93 1f       	adc	r25, r19
    4cfe:	fc 01       	movw	r30, r24
    4d00:	bb 96       	adiw	r30, 0x2b	; 43
    4d02:	80 81       	ld	r24, Z
    4d04:	89 83       	std	Y+1, r24	; 0x01

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4d06:	8f 81       	ldd	r24, Y+7	; 0x07
    4d08:	28 2f       	mov	r18, r24
    4d0a:	30 e0       	ldi	r19, 0x00	; 0
    4d0c:	8b 81       	ldd	r24, Y+3	; 0x03
    4d0e:	9c 81       	ldd	r25, Y+4	; 0x04
    4d10:	82 0f       	add	r24, r18
    4d12:	93 1f       	adc	r25, r19
    4d14:	fc 01       	movw	r30, r24
    4d16:	bb 96       	adiw	r30, 0x2b	; 43
    4d18:	82 e0       	ldi	r24, 0x02	; 2
    4d1a:	80 83       	st	Z, r24

            switch( eAction )
    4d1c:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d1e:	28 2f       	mov	r18, r24
    4d20:	30 e0       	ldi	r19, 0x00	; 0
    4d22:	38 8b       	std	Y+16, r19	; 0x10
    4d24:	2f 87       	std	Y+15, r18	; 0x0f
    4d26:	8f 85       	ldd	r24, Y+15	; 0x0f
    4d28:	98 89       	ldd	r25, Y+16	; 0x10
    4d2a:	82 30       	cpi	r24, 0x02	; 2
    4d2c:	91 05       	cpc	r25, r1
    4d2e:	09 f4       	brne	.+2      	; 0x4d32 <xTaskGenericNotify+0xba>
    4d30:	46 c0       	rjmp	.+140    	; 0x4dbe <xTaskGenericNotify+0x146>
    4d32:	2f 85       	ldd	r18, Y+15	; 0x0f
    4d34:	38 89       	ldd	r19, Y+16	; 0x10
    4d36:	23 30       	cpi	r18, 0x03	; 3
    4d38:	31 05       	cpc	r19, r1
    4d3a:	34 f4       	brge	.+12     	; 0x4d48 <xTaskGenericNotify+0xd0>
    4d3c:	8f 85       	ldd	r24, Y+15	; 0x0f
    4d3e:	98 89       	ldd	r25, Y+16	; 0x10
    4d40:	81 30       	cpi	r24, 0x01	; 1
    4d42:	91 05       	cpc	r25, r1
    4d44:	71 f0       	breq	.+28     	; 0x4d62 <xTaskGenericNotify+0xea>
    4d46:	93 c0       	rjmp	.+294    	; 0x4e6e <xTaskGenericNotify+0x1f6>
    4d48:	2f 85       	ldd	r18, Y+15	; 0x0f
    4d4a:	38 89       	ldd	r19, Y+16	; 0x10
    4d4c:	23 30       	cpi	r18, 0x03	; 3
    4d4e:	31 05       	cpc	r19, r1
    4d50:	09 f4       	brne	.+2      	; 0x4d54 <xTaskGenericNotify+0xdc>
    4d52:	5d c0       	rjmp	.+186    	; 0x4e0e <xTaskGenericNotify+0x196>
    4d54:	8f 85       	ldd	r24, Y+15	; 0x0f
    4d56:	98 89       	ldd	r25, Y+16	; 0x10
    4d58:	84 30       	cpi	r24, 0x04	; 4
    4d5a:	91 05       	cpc	r25, r1
    4d5c:	09 f4       	brne	.+2      	; 0x4d60 <xTaskGenericNotify+0xe8>
    4d5e:	6d c0       	rjmp	.+218    	; 0x4e3a <xTaskGenericNotify+0x1c2>
    4d60:	86 c0       	rjmp	.+268    	; 0x4e6e <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    4d62:	8f 81       	ldd	r24, Y+7	; 0x07
    4d64:	08 2f       	mov	r16, r24
    4d66:	10 e0       	ldi	r17, 0x00	; 0
    4d68:	8f 81       	ldd	r24, Y+7	; 0x07
    4d6a:	88 2f       	mov	r24, r24
    4d6c:	90 e0       	ldi	r25, 0x00	; 0
    4d6e:	2b 81       	ldd	r18, Y+3	; 0x03
    4d70:	3c 81       	ldd	r19, Y+4	; 0x04
    4d72:	88 0f       	add	r24, r24
    4d74:	99 1f       	adc	r25, r25
    4d76:	88 0f       	add	r24, r24
    4d78:	99 1f       	adc	r25, r25
    4d7a:	82 0f       	add	r24, r18
    4d7c:	93 1f       	adc	r25, r19
    4d7e:	fc 01       	movw	r30, r24
    4d80:	b7 96       	adiw	r30, 0x27	; 39
    4d82:	20 81       	ld	r18, Z
    4d84:	31 81       	ldd	r19, Z+1	; 0x01
    4d86:	42 81       	ldd	r20, Z+2	; 0x02
    4d88:	53 81       	ldd	r21, Z+3	; 0x03
    4d8a:	88 85       	ldd	r24, Y+8	; 0x08
    4d8c:	99 85       	ldd	r25, Y+9	; 0x09
    4d8e:	aa 85       	ldd	r26, Y+10	; 0x0a
    4d90:	bb 85       	ldd	r27, Y+11	; 0x0b
    4d92:	ba 01       	movw	r22, r20
    4d94:	a9 01       	movw	r20, r18
    4d96:	48 2b       	or	r20, r24
    4d98:	59 2b       	or	r21, r25
    4d9a:	6a 2b       	or	r22, r26
    4d9c:	7b 2b       	or	r23, r27
    4d9e:	2b 81       	ldd	r18, Y+3	; 0x03
    4da0:	3c 81       	ldd	r19, Y+4	; 0x04
    4da2:	c8 01       	movw	r24, r16
    4da4:	88 0f       	add	r24, r24
    4da6:	99 1f       	adc	r25, r25
    4da8:	88 0f       	add	r24, r24
    4daa:	99 1f       	adc	r25, r25
    4dac:	82 0f       	add	r24, r18
    4dae:	93 1f       	adc	r25, r19
    4db0:	fc 01       	movw	r30, r24
    4db2:	b7 96       	adiw	r30, 0x27	; 39
    4db4:	40 83       	st	Z, r20
    4db6:	51 83       	std	Z+1, r21	; 0x01
    4db8:	62 83       	std	Z+2, r22	; 0x02
    4dba:	73 83       	std	Z+3, r23	; 0x03
    4dbc:	58 c0       	rjmp	.+176    	; 0x4e6e <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4dbe:	8f 81       	ldd	r24, Y+7	; 0x07
    4dc0:	08 2f       	mov	r16, r24
    4dc2:	10 e0       	ldi	r17, 0x00	; 0
    4dc4:	2b 81       	ldd	r18, Y+3	; 0x03
    4dc6:	3c 81       	ldd	r19, Y+4	; 0x04
    4dc8:	c8 01       	movw	r24, r16
    4dca:	88 0f       	add	r24, r24
    4dcc:	99 1f       	adc	r25, r25
    4dce:	88 0f       	add	r24, r24
    4dd0:	99 1f       	adc	r25, r25
    4dd2:	82 0f       	add	r24, r18
    4dd4:	93 1f       	adc	r25, r19
    4dd6:	fc 01       	movw	r30, r24
    4dd8:	b7 96       	adiw	r30, 0x27	; 39
    4dda:	80 81       	ld	r24, Z
    4ddc:	91 81       	ldd	r25, Z+1	; 0x01
    4dde:	a2 81       	ldd	r26, Z+2	; 0x02
    4de0:	b3 81       	ldd	r27, Z+3	; 0x03
    4de2:	ac 01       	movw	r20, r24
    4de4:	bd 01       	movw	r22, r26
    4de6:	4f 5f       	subi	r20, 0xFF	; 255
    4de8:	5f 4f       	sbci	r21, 0xFF	; 255
    4dea:	6f 4f       	sbci	r22, 0xFF	; 255
    4dec:	7f 4f       	sbci	r23, 0xFF	; 255
    4dee:	2b 81       	ldd	r18, Y+3	; 0x03
    4df0:	3c 81       	ldd	r19, Y+4	; 0x04
    4df2:	c8 01       	movw	r24, r16
    4df4:	88 0f       	add	r24, r24
    4df6:	99 1f       	adc	r25, r25
    4df8:	88 0f       	add	r24, r24
    4dfa:	99 1f       	adc	r25, r25
    4dfc:	82 0f       	add	r24, r18
    4dfe:	93 1f       	adc	r25, r19
    4e00:	fc 01       	movw	r30, r24
    4e02:	b7 96       	adiw	r30, 0x27	; 39
    4e04:	40 83       	st	Z, r20
    4e06:	51 83       	std	Z+1, r21	; 0x01
    4e08:	62 83       	std	Z+2, r22	; 0x02
    4e0a:	73 83       	std	Z+3, r23	; 0x03
    4e0c:	30 c0       	rjmp	.+96     	; 0x4e6e <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4e0e:	8f 81       	ldd	r24, Y+7	; 0x07
    4e10:	88 2f       	mov	r24, r24
    4e12:	90 e0       	ldi	r25, 0x00	; 0
    4e14:	2b 81       	ldd	r18, Y+3	; 0x03
    4e16:	3c 81       	ldd	r19, Y+4	; 0x04
    4e18:	88 0f       	add	r24, r24
    4e1a:	99 1f       	adc	r25, r25
    4e1c:	88 0f       	add	r24, r24
    4e1e:	99 1f       	adc	r25, r25
    4e20:	82 0f       	add	r24, r18
    4e22:	93 1f       	adc	r25, r19
    4e24:	fc 01       	movw	r30, r24
    4e26:	b7 96       	adiw	r30, 0x27	; 39
    4e28:	88 85       	ldd	r24, Y+8	; 0x08
    4e2a:	99 85       	ldd	r25, Y+9	; 0x09
    4e2c:	aa 85       	ldd	r26, Y+10	; 0x0a
    4e2e:	bb 85       	ldd	r27, Y+11	; 0x0b
    4e30:	80 83       	st	Z, r24
    4e32:	91 83       	std	Z+1, r25	; 0x01
    4e34:	a2 83       	std	Z+2, r26	; 0x02
    4e36:	b3 83       	std	Z+3, r27	; 0x03
    4e38:	1a c0       	rjmp	.+52     	; 0x4e6e <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4e3a:	89 81       	ldd	r24, Y+1	; 0x01
    4e3c:	82 30       	cpi	r24, 0x02	; 2
    4e3e:	b1 f0       	breq	.+44     	; 0x4e6c <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4e40:	8f 81       	ldd	r24, Y+7	; 0x07
    4e42:	88 2f       	mov	r24, r24
    4e44:	90 e0       	ldi	r25, 0x00	; 0
    4e46:	2b 81       	ldd	r18, Y+3	; 0x03
    4e48:	3c 81       	ldd	r19, Y+4	; 0x04
    4e4a:	88 0f       	add	r24, r24
    4e4c:	99 1f       	adc	r25, r25
    4e4e:	88 0f       	add	r24, r24
    4e50:	99 1f       	adc	r25, r25
    4e52:	82 0f       	add	r24, r18
    4e54:	93 1f       	adc	r25, r19
    4e56:	fc 01       	movw	r30, r24
    4e58:	b7 96       	adiw	r30, 0x27	; 39
    4e5a:	88 85       	ldd	r24, Y+8	; 0x08
    4e5c:	99 85       	ldd	r25, Y+9	; 0x09
    4e5e:	aa 85       	ldd	r26, Y+10	; 0x0a
    4e60:	bb 85       	ldd	r27, Y+11	; 0x0b
    4e62:	80 83       	st	Z, r24
    4e64:	91 83       	std	Z+1, r25	; 0x01
    4e66:	a2 83       	std	Z+2, r26	; 0x02
    4e68:	b3 83       	std	Z+3, r27	; 0x03
    4e6a:	01 c0       	rjmp	.+2      	; 0x4e6e <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    4e6c:	1a 82       	std	Y+2, r1	; 0x02

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4e6e:	89 81       	ldd	r24, Y+1	; 0x01
    4e70:	81 30       	cpi	r24, 0x01	; 1
    4e72:	b9 f5       	brne	.+110    	; 0x4ee2 <xTaskGenericNotify+0x26a>
            {
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4e74:	8b 81       	ldd	r24, Y+3	; 0x03
    4e76:	9c 81       	ldd	r25, Y+4	; 0x04
    4e78:	02 96       	adiw	r24, 0x02	; 2
    4e7a:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
                prvAddTaskToReadyList( pxTCB );
    4e7e:	eb 81       	ldd	r30, Y+3	; 0x03
    4e80:	fc 81       	ldd	r31, Y+4	; 0x04
    4e82:	96 89       	ldd	r25, Z+22	; 0x16
    4e84:	80 91 a5 07 	lds	r24, 0x07A5
    4e88:	89 17       	cp	r24, r25
    4e8a:	28 f4       	brcc	.+10     	; 0x4e96 <xTaskGenericNotify+0x21e>
    4e8c:	eb 81       	ldd	r30, Y+3	; 0x03
    4e8e:	fc 81       	ldd	r31, Y+4	; 0x04
    4e90:	86 89       	ldd	r24, Z+22	; 0x16
    4e92:	80 93 a5 07 	sts	0x07A5, r24
    4e96:	eb 81       	ldd	r30, Y+3	; 0x03
    4e98:	fc 81       	ldd	r31, Y+4	; 0x04
    4e9a:	86 89       	ldd	r24, Z+22	; 0x16
    4e9c:	28 2f       	mov	r18, r24
    4e9e:	30 e0       	ldi	r19, 0x00	; 0
    4ea0:	c9 01       	movw	r24, r18
    4ea2:	88 0f       	add	r24, r24
    4ea4:	99 1f       	adc	r25, r25
    4ea6:	88 0f       	add	r24, r24
    4ea8:	99 1f       	adc	r25, r25
    4eaa:	88 0f       	add	r24, r24
    4eac:	99 1f       	adc	r25, r25
    4eae:	82 0f       	add	r24, r18
    4eb0:	93 1f       	adc	r25, r19
    4eb2:	ac 01       	movw	r20, r24
    4eb4:	4f 54       	subi	r20, 0x4F	; 79
    4eb6:	58 4f       	sbci	r21, 0xF8	; 248
    4eb8:	8b 81       	ldd	r24, Y+3	; 0x03
    4eba:	9c 81       	ldd	r25, Y+4	; 0x04
    4ebc:	9c 01       	movw	r18, r24
    4ebe:	2e 5f       	subi	r18, 0xFE	; 254
    4ec0:	3f 4f       	sbci	r19, 0xFF	; 255
    4ec2:	ca 01       	movw	r24, r20
    4ec4:	b9 01       	movw	r22, r18
    4ec6:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4eca:	eb 81       	ldd	r30, Y+3	; 0x03
    4ecc:	fc 81       	ldd	r31, Y+4	; 0x04
    4ece:	96 89       	ldd	r25, Z+22	; 0x16
    4ed0:	e0 91 a0 07 	lds	r30, 0x07A0
    4ed4:	f0 91 a1 07 	lds	r31, 0x07A1
    4ed8:	86 89       	ldd	r24, Z+22	; 0x16
    4eda:	89 17       	cp	r24, r25
    4edc:	10 f4       	brcc	.+4      	; 0x4ee2 <xTaskGenericNotify+0x26a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    4ede:	0e 94 1e 0c 	call	0x183c	; 0x183c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4ee2:	0f 90       	pop	r0
    4ee4:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4ee6:	8a 81       	ldd	r24, Y+2	; 0x02
    }
    4ee8:	60 96       	adiw	r28, 0x10	; 16
    4eea:	0f b6       	in	r0, 0x3f	; 63
    4eec:	f8 94       	cli
    4eee:	de bf       	out	0x3e, r29	; 62
    4ef0:	0f be       	out	0x3f, r0	; 63
    4ef2:	cd bf       	out	0x3d, r28	; 61
    4ef4:	cf 91       	pop	r28
    4ef6:	df 91       	pop	r29
    4ef8:	1f 91       	pop	r17
    4efa:	0f 91       	pop	r16
    4efc:	ff 90       	pop	r15
    4efe:	ef 90       	pop	r14
    4f00:	08 95       	ret

00004f02 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    4f02:	cf 92       	push	r12
    4f04:	df 92       	push	r13
    4f06:	ef 92       	push	r14
    4f08:	ff 92       	push	r15
    4f0a:	0f 93       	push	r16
    4f0c:	1f 93       	push	r17
    4f0e:	df 93       	push	r29
    4f10:	cf 93       	push	r28
    4f12:	cd b7       	in	r28, 0x3d	; 61
    4f14:	de b7       	in	r29, 0x3e	; 62
    4f16:	63 97       	sbiw	r28, 0x13	; 19
    4f18:	0f b6       	in	r0, 0x3f	; 63
    4f1a:	f8 94       	cli
    4f1c:	de bf       	out	0x3e, r29	; 62
    4f1e:	0f be       	out	0x3f, r0	; 63
    4f20:	cd bf       	out	0x3d, r28	; 61
    4f22:	9f 83       	std	Y+7, r25	; 0x07
    4f24:	8e 83       	std	Y+6, r24	; 0x06
    4f26:	68 87       	std	Y+8, r22	; 0x08
    4f28:	29 87       	std	Y+9, r18	; 0x09
    4f2a:	3a 87       	std	Y+10, r19	; 0x0a
    4f2c:	4b 87       	std	Y+11, r20	; 0x0b
    4f2e:	5c 87       	std	Y+12, r21	; 0x0c
    4f30:	0d 87       	std	Y+13, r16	; 0x0d
    4f32:	ff 86       	std	Y+15, r15	; 0x0f
    4f34:	ee 86       	std	Y+14, r14	; 0x0e
    4f36:	d9 8a       	std	Y+17, r13	; 0x11
    4f38:	c8 8a       	std	Y+16, r12	; 0x10
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    4f3a:	81 e0       	ldi	r24, 0x01	; 1
    4f3c:	8a 83       	std	Y+2, r24	; 0x02
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    4f3e:	8e 81       	ldd	r24, Y+6	; 0x06
    4f40:	9f 81       	ldd	r25, Y+7	; 0x07
    4f42:	9d 83       	std	Y+5, r25	; 0x05
    4f44:	8c 83       	std	Y+4, r24	; 0x04

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4f46:	19 82       	std	Y+1, r1	; 0x01
        {
            if( pulPreviousNotificationValue != NULL )
    4f48:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f4a:	9f 85       	ldd	r25, Y+15	; 0x0f
    4f4c:	00 97       	sbiw	r24, 0x00	; 0
    4f4e:	b9 f0       	breq	.+46     	; 0x4f7e <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4f50:	88 85       	ldd	r24, Y+8	; 0x08
    4f52:	88 2f       	mov	r24, r24
    4f54:	90 e0       	ldi	r25, 0x00	; 0
    4f56:	2c 81       	ldd	r18, Y+4	; 0x04
    4f58:	3d 81       	ldd	r19, Y+5	; 0x05
    4f5a:	88 0f       	add	r24, r24
    4f5c:	99 1f       	adc	r25, r25
    4f5e:	88 0f       	add	r24, r24
    4f60:	99 1f       	adc	r25, r25
    4f62:	82 0f       	add	r24, r18
    4f64:	93 1f       	adc	r25, r19
    4f66:	fc 01       	movw	r30, r24
    4f68:	b7 96       	adiw	r30, 0x27	; 39
    4f6a:	80 81       	ld	r24, Z
    4f6c:	91 81       	ldd	r25, Z+1	; 0x01
    4f6e:	a2 81       	ldd	r26, Z+2	; 0x02
    4f70:	b3 81       	ldd	r27, Z+3	; 0x03
    4f72:	ee 85       	ldd	r30, Y+14	; 0x0e
    4f74:	ff 85       	ldd	r31, Y+15	; 0x0f
    4f76:	80 83       	st	Z, r24
    4f78:	91 83       	std	Z+1, r25	; 0x01
    4f7a:	a2 83       	std	Z+2, r26	; 0x02
    4f7c:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4f7e:	88 85       	ldd	r24, Y+8	; 0x08
    4f80:	28 2f       	mov	r18, r24
    4f82:	30 e0       	ldi	r19, 0x00	; 0
    4f84:	8c 81       	ldd	r24, Y+4	; 0x04
    4f86:	9d 81       	ldd	r25, Y+5	; 0x05
    4f88:	82 0f       	add	r24, r18
    4f8a:	93 1f       	adc	r25, r19
    4f8c:	fc 01       	movw	r30, r24
    4f8e:	bb 96       	adiw	r30, 0x2b	; 43
    4f90:	80 81       	ld	r24, Z
    4f92:	8b 83       	std	Y+3, r24	; 0x03
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4f94:	88 85       	ldd	r24, Y+8	; 0x08
    4f96:	28 2f       	mov	r18, r24
    4f98:	30 e0       	ldi	r19, 0x00	; 0
    4f9a:	8c 81       	ldd	r24, Y+4	; 0x04
    4f9c:	9d 81       	ldd	r25, Y+5	; 0x05
    4f9e:	82 0f       	add	r24, r18
    4fa0:	93 1f       	adc	r25, r19
    4fa2:	fc 01       	movw	r30, r24
    4fa4:	bb 96       	adiw	r30, 0x2b	; 43
    4fa6:	82 e0       	ldi	r24, 0x02	; 2
    4fa8:	80 83       	st	Z, r24

            switch( eAction )
    4faa:	8d 85       	ldd	r24, Y+13	; 0x0d
    4fac:	28 2f       	mov	r18, r24
    4fae:	30 e0       	ldi	r19, 0x00	; 0
    4fb0:	3b 8b       	std	Y+19, r19	; 0x13
    4fb2:	2a 8b       	std	Y+18, r18	; 0x12
    4fb4:	8a 89       	ldd	r24, Y+18	; 0x12
    4fb6:	9b 89       	ldd	r25, Y+19	; 0x13
    4fb8:	82 30       	cpi	r24, 0x02	; 2
    4fba:	91 05       	cpc	r25, r1
    4fbc:	09 f4       	brne	.+2      	; 0x4fc0 <xTaskGenericNotifyFromISR+0xbe>
    4fbe:	46 c0       	rjmp	.+140    	; 0x504c <xTaskGenericNotifyFromISR+0x14a>
    4fc0:	2a 89       	ldd	r18, Y+18	; 0x12
    4fc2:	3b 89       	ldd	r19, Y+19	; 0x13
    4fc4:	23 30       	cpi	r18, 0x03	; 3
    4fc6:	31 05       	cpc	r19, r1
    4fc8:	34 f4       	brge	.+12     	; 0x4fd6 <xTaskGenericNotifyFromISR+0xd4>
    4fca:	8a 89       	ldd	r24, Y+18	; 0x12
    4fcc:	9b 89       	ldd	r25, Y+19	; 0x13
    4fce:	81 30       	cpi	r24, 0x01	; 1
    4fd0:	91 05       	cpc	r25, r1
    4fd2:	71 f0       	breq	.+28     	; 0x4ff0 <xTaskGenericNotifyFromISR+0xee>
    4fd4:	93 c0       	rjmp	.+294    	; 0x50fc <xTaskGenericNotifyFromISR+0x1fa>
    4fd6:	2a 89       	ldd	r18, Y+18	; 0x12
    4fd8:	3b 89       	ldd	r19, Y+19	; 0x13
    4fda:	23 30       	cpi	r18, 0x03	; 3
    4fdc:	31 05       	cpc	r19, r1
    4fde:	09 f4       	brne	.+2      	; 0x4fe2 <xTaskGenericNotifyFromISR+0xe0>
    4fe0:	5d c0       	rjmp	.+186    	; 0x509c <xTaskGenericNotifyFromISR+0x19a>
    4fe2:	8a 89       	ldd	r24, Y+18	; 0x12
    4fe4:	9b 89       	ldd	r25, Y+19	; 0x13
    4fe6:	84 30       	cpi	r24, 0x04	; 4
    4fe8:	91 05       	cpc	r25, r1
    4fea:	09 f4       	brne	.+2      	; 0x4fee <xTaskGenericNotifyFromISR+0xec>
    4fec:	6d c0       	rjmp	.+218    	; 0x50c8 <xTaskGenericNotifyFromISR+0x1c6>
    4fee:	86 c0       	rjmp	.+268    	; 0x50fc <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    4ff0:	88 85       	ldd	r24, Y+8	; 0x08
    4ff2:	08 2f       	mov	r16, r24
    4ff4:	10 e0       	ldi	r17, 0x00	; 0
    4ff6:	88 85       	ldd	r24, Y+8	; 0x08
    4ff8:	88 2f       	mov	r24, r24
    4ffa:	90 e0       	ldi	r25, 0x00	; 0
    4ffc:	2c 81       	ldd	r18, Y+4	; 0x04
    4ffe:	3d 81       	ldd	r19, Y+5	; 0x05
    5000:	88 0f       	add	r24, r24
    5002:	99 1f       	adc	r25, r25
    5004:	88 0f       	add	r24, r24
    5006:	99 1f       	adc	r25, r25
    5008:	82 0f       	add	r24, r18
    500a:	93 1f       	adc	r25, r19
    500c:	fc 01       	movw	r30, r24
    500e:	b7 96       	adiw	r30, 0x27	; 39
    5010:	20 81       	ld	r18, Z
    5012:	31 81       	ldd	r19, Z+1	; 0x01
    5014:	42 81       	ldd	r20, Z+2	; 0x02
    5016:	53 81       	ldd	r21, Z+3	; 0x03
    5018:	89 85       	ldd	r24, Y+9	; 0x09
    501a:	9a 85       	ldd	r25, Y+10	; 0x0a
    501c:	ab 85       	ldd	r26, Y+11	; 0x0b
    501e:	bc 85       	ldd	r27, Y+12	; 0x0c
    5020:	ba 01       	movw	r22, r20
    5022:	a9 01       	movw	r20, r18
    5024:	48 2b       	or	r20, r24
    5026:	59 2b       	or	r21, r25
    5028:	6a 2b       	or	r22, r26
    502a:	7b 2b       	or	r23, r27
    502c:	2c 81       	ldd	r18, Y+4	; 0x04
    502e:	3d 81       	ldd	r19, Y+5	; 0x05
    5030:	c8 01       	movw	r24, r16
    5032:	88 0f       	add	r24, r24
    5034:	99 1f       	adc	r25, r25
    5036:	88 0f       	add	r24, r24
    5038:	99 1f       	adc	r25, r25
    503a:	82 0f       	add	r24, r18
    503c:	93 1f       	adc	r25, r19
    503e:	fc 01       	movw	r30, r24
    5040:	b7 96       	adiw	r30, 0x27	; 39
    5042:	40 83       	st	Z, r20
    5044:	51 83       	std	Z+1, r21	; 0x01
    5046:	62 83       	std	Z+2, r22	; 0x02
    5048:	73 83       	std	Z+3, r23	; 0x03
    504a:	58 c0       	rjmp	.+176    	; 0x50fc <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    504c:	88 85       	ldd	r24, Y+8	; 0x08
    504e:	08 2f       	mov	r16, r24
    5050:	10 e0       	ldi	r17, 0x00	; 0
    5052:	2c 81       	ldd	r18, Y+4	; 0x04
    5054:	3d 81       	ldd	r19, Y+5	; 0x05
    5056:	c8 01       	movw	r24, r16
    5058:	88 0f       	add	r24, r24
    505a:	99 1f       	adc	r25, r25
    505c:	88 0f       	add	r24, r24
    505e:	99 1f       	adc	r25, r25
    5060:	82 0f       	add	r24, r18
    5062:	93 1f       	adc	r25, r19
    5064:	fc 01       	movw	r30, r24
    5066:	b7 96       	adiw	r30, 0x27	; 39
    5068:	80 81       	ld	r24, Z
    506a:	91 81       	ldd	r25, Z+1	; 0x01
    506c:	a2 81       	ldd	r26, Z+2	; 0x02
    506e:	b3 81       	ldd	r27, Z+3	; 0x03
    5070:	ac 01       	movw	r20, r24
    5072:	bd 01       	movw	r22, r26
    5074:	4f 5f       	subi	r20, 0xFF	; 255
    5076:	5f 4f       	sbci	r21, 0xFF	; 255
    5078:	6f 4f       	sbci	r22, 0xFF	; 255
    507a:	7f 4f       	sbci	r23, 0xFF	; 255
    507c:	2c 81       	ldd	r18, Y+4	; 0x04
    507e:	3d 81       	ldd	r19, Y+5	; 0x05
    5080:	c8 01       	movw	r24, r16
    5082:	88 0f       	add	r24, r24
    5084:	99 1f       	adc	r25, r25
    5086:	88 0f       	add	r24, r24
    5088:	99 1f       	adc	r25, r25
    508a:	82 0f       	add	r24, r18
    508c:	93 1f       	adc	r25, r19
    508e:	fc 01       	movw	r30, r24
    5090:	b7 96       	adiw	r30, 0x27	; 39
    5092:	40 83       	st	Z, r20
    5094:	51 83       	std	Z+1, r21	; 0x01
    5096:	62 83       	std	Z+2, r22	; 0x02
    5098:	73 83       	std	Z+3, r23	; 0x03
    509a:	30 c0       	rjmp	.+96     	; 0x50fc <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    509c:	88 85       	ldd	r24, Y+8	; 0x08
    509e:	88 2f       	mov	r24, r24
    50a0:	90 e0       	ldi	r25, 0x00	; 0
    50a2:	2c 81       	ldd	r18, Y+4	; 0x04
    50a4:	3d 81       	ldd	r19, Y+5	; 0x05
    50a6:	88 0f       	add	r24, r24
    50a8:	99 1f       	adc	r25, r25
    50aa:	88 0f       	add	r24, r24
    50ac:	99 1f       	adc	r25, r25
    50ae:	82 0f       	add	r24, r18
    50b0:	93 1f       	adc	r25, r19
    50b2:	fc 01       	movw	r30, r24
    50b4:	b7 96       	adiw	r30, 0x27	; 39
    50b6:	89 85       	ldd	r24, Y+9	; 0x09
    50b8:	9a 85       	ldd	r25, Y+10	; 0x0a
    50ba:	ab 85       	ldd	r26, Y+11	; 0x0b
    50bc:	bc 85       	ldd	r27, Y+12	; 0x0c
    50be:	80 83       	st	Z, r24
    50c0:	91 83       	std	Z+1, r25	; 0x01
    50c2:	a2 83       	std	Z+2, r26	; 0x02
    50c4:	b3 83       	std	Z+3, r27	; 0x03
    50c6:	1a c0       	rjmp	.+52     	; 0x50fc <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    50c8:	8b 81       	ldd	r24, Y+3	; 0x03
    50ca:	82 30       	cpi	r24, 0x02	; 2
    50cc:	b1 f0       	breq	.+44     	; 0x50fa <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    50ce:	88 85       	ldd	r24, Y+8	; 0x08
    50d0:	88 2f       	mov	r24, r24
    50d2:	90 e0       	ldi	r25, 0x00	; 0
    50d4:	2c 81       	ldd	r18, Y+4	; 0x04
    50d6:	3d 81       	ldd	r19, Y+5	; 0x05
    50d8:	88 0f       	add	r24, r24
    50da:	99 1f       	adc	r25, r25
    50dc:	88 0f       	add	r24, r24
    50de:	99 1f       	adc	r25, r25
    50e0:	82 0f       	add	r24, r18
    50e2:	93 1f       	adc	r25, r19
    50e4:	fc 01       	movw	r30, r24
    50e6:	b7 96       	adiw	r30, 0x27	; 39
    50e8:	89 85       	ldd	r24, Y+9	; 0x09
    50ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    50ec:	ab 85       	ldd	r26, Y+11	; 0x0b
    50ee:	bc 85       	ldd	r27, Y+12	; 0x0c
    50f0:	80 83       	st	Z, r24
    50f2:	91 83       	std	Z+1, r25	; 0x01
    50f4:	a2 83       	std	Z+2, r26	; 0x02
    50f6:	b3 83       	std	Z+3, r27	; 0x03
    50f8:	01 c0       	rjmp	.+2      	; 0x50fc <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    50fa:	1a 82       	std	Y+2, r1	; 0x02

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    50fc:	8b 81       	ldd	r24, Y+3	; 0x03
    50fe:	81 30       	cpi	r24, 0x01	; 1
    5100:	09 f0       	breq	.+2      	; 0x5104 <xTaskGenericNotifyFromISR+0x202>
    5102:	4f c0       	rjmp	.+158    	; 0x51a2 <xTaskGenericNotifyFromISR+0x2a0>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5104:	80 91 b0 07 	lds	r24, 0x07B0
    5108:	88 23       	and	r24, r24
    510a:	61 f5       	brne	.+88     	; 0x5164 <xTaskGenericNotifyFromISR+0x262>
                {
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    510c:	8c 81       	ldd	r24, Y+4	; 0x04
    510e:	9d 81       	ldd	r25, Y+5	; 0x05
    5110:	02 96       	adiw	r24, 0x02	; 2
    5112:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    5116:	ec 81       	ldd	r30, Y+4	; 0x04
    5118:	fd 81       	ldd	r31, Y+5	; 0x05
    511a:	96 89       	ldd	r25, Z+22	; 0x16
    511c:	80 91 a5 07 	lds	r24, 0x07A5
    5120:	89 17       	cp	r24, r25
    5122:	28 f4       	brcc	.+10     	; 0x512e <xTaskGenericNotifyFromISR+0x22c>
    5124:	ec 81       	ldd	r30, Y+4	; 0x04
    5126:	fd 81       	ldd	r31, Y+5	; 0x05
    5128:	86 89       	ldd	r24, Z+22	; 0x16
    512a:	80 93 a5 07 	sts	0x07A5, r24
    512e:	ec 81       	ldd	r30, Y+4	; 0x04
    5130:	fd 81       	ldd	r31, Y+5	; 0x05
    5132:	86 89       	ldd	r24, Z+22	; 0x16
    5134:	28 2f       	mov	r18, r24
    5136:	30 e0       	ldi	r19, 0x00	; 0
    5138:	c9 01       	movw	r24, r18
    513a:	88 0f       	add	r24, r24
    513c:	99 1f       	adc	r25, r25
    513e:	88 0f       	add	r24, r24
    5140:	99 1f       	adc	r25, r25
    5142:	88 0f       	add	r24, r24
    5144:	99 1f       	adc	r25, r25
    5146:	82 0f       	add	r24, r18
    5148:	93 1f       	adc	r25, r19
    514a:	ac 01       	movw	r20, r24
    514c:	4f 54       	subi	r20, 0x4F	; 79
    514e:	58 4f       	sbci	r21, 0xF8	; 248
    5150:	8c 81       	ldd	r24, Y+4	; 0x04
    5152:	9d 81       	ldd	r25, Y+5	; 0x05
    5154:	9c 01       	movw	r18, r24
    5156:	2e 5f       	subi	r18, 0xFE	; 254
    5158:	3f 4f       	sbci	r19, 0xFF	; 255
    515a:	ca 01       	movw	r24, r20
    515c:	b9 01       	movw	r22, r18
    515e:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
    5162:	0a c0       	rjmp	.+20     	; 0x5178 <xTaskGenericNotifyFromISR+0x276>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5164:	8c 81       	ldd	r24, Y+4	; 0x04
    5166:	9d 81       	ldd	r25, Y+5	; 0x05
    5168:	9c 01       	movw	r18, r24
    516a:	24 5f       	subi	r18, 0xF4	; 244
    516c:	3f 4f       	sbci	r19, 0xFF	; 255
    516e:	8b ee       	ldi	r24, 0xEB	; 235
    5170:	97 e0       	ldi	r25, 0x07	; 7
    5172:	b9 01       	movw	r22, r18
    5174:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5178:	ec 81       	ldd	r30, Y+4	; 0x04
    517a:	fd 81       	ldd	r31, Y+5	; 0x05
    517c:	96 89       	ldd	r25, Z+22	; 0x16
    517e:	e0 91 a0 07 	lds	r30, 0x07A0
    5182:	f0 91 a1 07 	lds	r31, 0x07A1
    5186:	86 89       	ldd	r24, Z+22	; 0x16
    5188:	89 17       	cp	r24, r25
    518a:	58 f4       	brcc	.+22     	; 0x51a2 <xTaskGenericNotifyFromISR+0x2a0>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    518c:	88 89       	ldd	r24, Y+16	; 0x10
    518e:	99 89       	ldd	r25, Y+17	; 0x11
    5190:	00 97       	sbiw	r24, 0x00	; 0
    5192:	21 f0       	breq	.+8      	; 0x519c <xTaskGenericNotifyFromISR+0x29a>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5194:	e8 89       	ldd	r30, Y+16	; 0x10
    5196:	f9 89       	ldd	r31, Y+17	; 0x11
    5198:	81 e0       	ldi	r24, 0x01	; 1
    519a:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    519c:	81 e0       	ldi	r24, 0x01	; 1
    519e:	80 93 a9 07 	sts	0x07A9, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    51a2:	8a 81       	ldd	r24, Y+2	; 0x02
    }
    51a4:	63 96       	adiw	r28, 0x13	; 19
    51a6:	0f b6       	in	r0, 0x3f	; 63
    51a8:	f8 94       	cli
    51aa:	de bf       	out	0x3e, r29	; 62
    51ac:	0f be       	out	0x3f, r0	; 63
    51ae:	cd bf       	out	0x3d, r28	; 61
    51b0:	cf 91       	pop	r28
    51b2:	df 91       	pop	r29
    51b4:	1f 91       	pop	r17
    51b6:	0f 91       	pop	r16
    51b8:	ff 90       	pop	r15
    51ba:	ef 90       	pop	r14
    51bc:	df 90       	pop	r13
    51be:	cf 90       	pop	r12
    51c0:	08 95       	ret

000051c2 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    51c2:	0f 93       	push	r16
    51c4:	1f 93       	push	r17
    51c6:	df 93       	push	r29
    51c8:	cf 93       	push	r28
    51ca:	cd b7       	in	r28, 0x3d	; 61
    51cc:	de b7       	in	r29, 0x3e	; 62
    51ce:	29 97       	sbiw	r28, 0x09	; 9
    51d0:	0f b6       	in	r0, 0x3f	; 63
    51d2:	f8 94       	cli
    51d4:	de bf       	out	0x3e, r29	; 62
    51d6:	0f be       	out	0x3f, r0	; 63
    51d8:	cd bf       	out	0x3d, r28	; 61
    51da:	9e 83       	std	Y+6, r25	; 0x06
    51dc:	8d 83       	std	Y+5, r24	; 0x05
    51de:	6f 83       	std	Y+7, r22	; 0x07
    51e0:	59 87       	std	Y+9, r21	; 0x09
    51e2:	48 87       	std	Y+8, r20	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    51e4:	8d 81       	ldd	r24, Y+5	; 0x05
    51e6:	9e 81       	ldd	r25, Y+6	; 0x06
    51e8:	9c 83       	std	Y+4, r25	; 0x04
    51ea:	8b 83       	std	Y+3, r24	; 0x03

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    51ec:	19 82       	std	Y+1, r1	; 0x01
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    51ee:	8f 81       	ldd	r24, Y+7	; 0x07
    51f0:	28 2f       	mov	r18, r24
    51f2:	30 e0       	ldi	r19, 0x00	; 0
    51f4:	8b 81       	ldd	r24, Y+3	; 0x03
    51f6:	9c 81       	ldd	r25, Y+4	; 0x04
    51f8:	82 0f       	add	r24, r18
    51fa:	93 1f       	adc	r25, r19
    51fc:	fc 01       	movw	r30, r24
    51fe:	bb 96       	adiw	r30, 0x2b	; 43
    5200:	80 81       	ld	r24, Z
    5202:	8a 83       	std	Y+2, r24	; 0x02
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5204:	8f 81       	ldd	r24, Y+7	; 0x07
    5206:	28 2f       	mov	r18, r24
    5208:	30 e0       	ldi	r19, 0x00	; 0
    520a:	8b 81       	ldd	r24, Y+3	; 0x03
    520c:	9c 81       	ldd	r25, Y+4	; 0x04
    520e:	82 0f       	add	r24, r18
    5210:	93 1f       	adc	r25, r19
    5212:	fc 01       	movw	r30, r24
    5214:	bb 96       	adiw	r30, 0x2b	; 43
    5216:	82 e0       	ldi	r24, 0x02	; 2
    5218:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    521a:	8f 81       	ldd	r24, Y+7	; 0x07
    521c:	08 2f       	mov	r16, r24
    521e:	10 e0       	ldi	r17, 0x00	; 0
    5220:	2b 81       	ldd	r18, Y+3	; 0x03
    5222:	3c 81       	ldd	r19, Y+4	; 0x04
    5224:	c8 01       	movw	r24, r16
    5226:	88 0f       	add	r24, r24
    5228:	99 1f       	adc	r25, r25
    522a:	88 0f       	add	r24, r24
    522c:	99 1f       	adc	r25, r25
    522e:	82 0f       	add	r24, r18
    5230:	93 1f       	adc	r25, r19
    5232:	fc 01       	movw	r30, r24
    5234:	b7 96       	adiw	r30, 0x27	; 39
    5236:	80 81       	ld	r24, Z
    5238:	91 81       	ldd	r25, Z+1	; 0x01
    523a:	a2 81       	ldd	r26, Z+2	; 0x02
    523c:	b3 81       	ldd	r27, Z+3	; 0x03
    523e:	ac 01       	movw	r20, r24
    5240:	bd 01       	movw	r22, r26
    5242:	4f 5f       	subi	r20, 0xFF	; 255
    5244:	5f 4f       	sbci	r21, 0xFF	; 255
    5246:	6f 4f       	sbci	r22, 0xFF	; 255
    5248:	7f 4f       	sbci	r23, 0xFF	; 255
    524a:	2b 81       	ldd	r18, Y+3	; 0x03
    524c:	3c 81       	ldd	r19, Y+4	; 0x04
    524e:	c8 01       	movw	r24, r16
    5250:	88 0f       	add	r24, r24
    5252:	99 1f       	adc	r25, r25
    5254:	88 0f       	add	r24, r24
    5256:	99 1f       	adc	r25, r25
    5258:	82 0f       	add	r24, r18
    525a:	93 1f       	adc	r25, r19
    525c:	fc 01       	movw	r30, r24
    525e:	b7 96       	adiw	r30, 0x27	; 39
    5260:	40 83       	st	Z, r20
    5262:	51 83       	std	Z+1, r21	; 0x01
    5264:	62 83       	std	Z+2, r22	; 0x02
    5266:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5268:	8a 81       	ldd	r24, Y+2	; 0x02
    526a:	81 30       	cpi	r24, 0x01	; 1
    526c:	09 f0       	breq	.+2      	; 0x5270 <vTaskGenericNotifyGiveFromISR+0xae>
    526e:	4f c0       	rjmp	.+158    	; 0x530e <vTaskGenericNotifyGiveFromISR+0x14c>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5270:	80 91 b0 07 	lds	r24, 0x07B0
    5274:	88 23       	and	r24, r24
    5276:	61 f5       	brne	.+88     	; 0x52d0 <vTaskGenericNotifyGiveFromISR+0x10e>
                {
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5278:	8b 81       	ldd	r24, Y+3	; 0x03
    527a:	9c 81       	ldd	r25, Y+4	; 0x04
    527c:	02 96       	adiw	r24, 0x02	; 2
    527e:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    5282:	eb 81       	ldd	r30, Y+3	; 0x03
    5284:	fc 81       	ldd	r31, Y+4	; 0x04
    5286:	96 89       	ldd	r25, Z+22	; 0x16
    5288:	80 91 a5 07 	lds	r24, 0x07A5
    528c:	89 17       	cp	r24, r25
    528e:	28 f4       	brcc	.+10     	; 0x529a <vTaskGenericNotifyGiveFromISR+0xd8>
    5290:	eb 81       	ldd	r30, Y+3	; 0x03
    5292:	fc 81       	ldd	r31, Y+4	; 0x04
    5294:	86 89       	ldd	r24, Z+22	; 0x16
    5296:	80 93 a5 07 	sts	0x07A5, r24
    529a:	eb 81       	ldd	r30, Y+3	; 0x03
    529c:	fc 81       	ldd	r31, Y+4	; 0x04
    529e:	86 89       	ldd	r24, Z+22	; 0x16
    52a0:	28 2f       	mov	r18, r24
    52a2:	30 e0       	ldi	r19, 0x00	; 0
    52a4:	c9 01       	movw	r24, r18
    52a6:	88 0f       	add	r24, r24
    52a8:	99 1f       	adc	r25, r25
    52aa:	88 0f       	add	r24, r24
    52ac:	99 1f       	adc	r25, r25
    52ae:	88 0f       	add	r24, r24
    52b0:	99 1f       	adc	r25, r25
    52b2:	82 0f       	add	r24, r18
    52b4:	93 1f       	adc	r25, r19
    52b6:	ac 01       	movw	r20, r24
    52b8:	4f 54       	subi	r20, 0x4F	; 79
    52ba:	58 4f       	sbci	r21, 0xF8	; 248
    52bc:	8b 81       	ldd	r24, Y+3	; 0x03
    52be:	9c 81       	ldd	r25, Y+4	; 0x04
    52c0:	9c 01       	movw	r18, r24
    52c2:	2e 5f       	subi	r18, 0xFE	; 254
    52c4:	3f 4f       	sbci	r19, 0xFF	; 255
    52c6:	ca 01       	movw	r24, r20
    52c8:	b9 01       	movw	r22, r18
    52ca:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
    52ce:	0a c0       	rjmp	.+20     	; 0x52e4 <vTaskGenericNotifyGiveFromISR+0x122>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    52d0:	8b 81       	ldd	r24, Y+3	; 0x03
    52d2:	9c 81       	ldd	r25, Y+4	; 0x04
    52d4:	9c 01       	movw	r18, r24
    52d6:	24 5f       	subi	r18, 0xF4	; 244
    52d8:	3f 4f       	sbci	r19, 0xFF	; 255
    52da:	8b ee       	ldi	r24, 0xEB	; 235
    52dc:	97 e0       	ldi	r25, 0x07	; 7
    52de:	b9 01       	movw	r22, r18
    52e0:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    52e4:	eb 81       	ldd	r30, Y+3	; 0x03
    52e6:	fc 81       	ldd	r31, Y+4	; 0x04
    52e8:	96 89       	ldd	r25, Z+22	; 0x16
    52ea:	e0 91 a0 07 	lds	r30, 0x07A0
    52ee:	f0 91 a1 07 	lds	r31, 0x07A1
    52f2:	86 89       	ldd	r24, Z+22	; 0x16
    52f4:	89 17       	cp	r24, r25
    52f6:	58 f4       	brcc	.+22     	; 0x530e <vTaskGenericNotifyGiveFromISR+0x14c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    52f8:	88 85       	ldd	r24, Y+8	; 0x08
    52fa:	99 85       	ldd	r25, Y+9	; 0x09
    52fc:	00 97       	sbiw	r24, 0x00	; 0
    52fe:	21 f0       	breq	.+8      	; 0x5308 <vTaskGenericNotifyGiveFromISR+0x146>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5300:	e8 85       	ldd	r30, Y+8	; 0x08
    5302:	f9 85       	ldd	r31, Y+9	; 0x09
    5304:	81 e0       	ldi	r24, 0x01	; 1
    5306:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5308:	81 e0       	ldi	r24, 0x01	; 1
    530a:	80 93 a9 07 	sts	0x07A9, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    530e:	29 96       	adiw	r28, 0x09	; 9
    5310:	0f b6       	in	r0, 0x3f	; 63
    5312:	f8 94       	cli
    5314:	de bf       	out	0x3e, r29	; 62
    5316:	0f be       	out	0x3f, r0	; 63
    5318:	cd bf       	out	0x3d, r28	; 61
    531a:	cf 91       	pop	r28
    531c:	df 91       	pop	r29
    531e:	1f 91       	pop	r17
    5320:	0f 91       	pop	r16
    5322:	08 95       	ret

00005324 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    5324:	df 93       	push	r29
    5326:	cf 93       	push	r28
    5328:	cd b7       	in	r28, 0x3d	; 61
    532a:	de b7       	in	r29, 0x3e	; 62
    532c:	28 97       	sbiw	r28, 0x08	; 8
    532e:	0f b6       	in	r0, 0x3f	; 63
    5330:	f8 94       	cli
    5332:	de bf       	out	0x3e, r29	; 62
    5334:	0f be       	out	0x3f, r0	; 63
    5336:	cd bf       	out	0x3d, r28	; 61
    5338:	9d 83       	std	Y+5, r25	; 0x05
    533a:	8c 83       	std	Y+4, r24	; 0x04
    533c:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    533e:	8c 81       	ldd	r24, Y+4	; 0x04
    5340:	9d 81       	ldd	r25, Y+5	; 0x05
    5342:	00 97       	sbiw	r24, 0x00	; 0
    5344:	39 f4       	brne	.+14     	; 0x5354 <xTaskGenericNotifyStateClear+0x30>
    5346:	80 91 a0 07 	lds	r24, 0x07A0
    534a:	90 91 a1 07 	lds	r25, 0x07A1
    534e:	98 87       	std	Y+8, r25	; 0x08
    5350:	8f 83       	std	Y+7, r24	; 0x07
    5352:	04 c0       	rjmp	.+8      	; 0x535c <xTaskGenericNotifyStateClear+0x38>
    5354:	8c 81       	ldd	r24, Y+4	; 0x04
    5356:	9d 81       	ldd	r25, Y+5	; 0x05
    5358:	98 87       	std	Y+8, r25	; 0x08
    535a:	8f 83       	std	Y+7, r24	; 0x07
    535c:	8f 81       	ldd	r24, Y+7	; 0x07
    535e:	98 85       	ldd	r25, Y+8	; 0x08
    5360:	9b 83       	std	Y+3, r25	; 0x03
    5362:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    5364:	0f b6       	in	r0, 0x3f	; 63
    5366:	f8 94       	cli
    5368:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    536a:	8e 81       	ldd	r24, Y+6	; 0x06
    536c:	28 2f       	mov	r18, r24
    536e:	30 e0       	ldi	r19, 0x00	; 0
    5370:	8a 81       	ldd	r24, Y+2	; 0x02
    5372:	9b 81       	ldd	r25, Y+3	; 0x03
    5374:	82 0f       	add	r24, r18
    5376:	93 1f       	adc	r25, r19
    5378:	fc 01       	movw	r30, r24
    537a:	bb 96       	adiw	r30, 0x2b	; 43
    537c:	80 81       	ld	r24, Z
    537e:	82 30       	cpi	r24, 0x02	; 2
    5380:	69 f4       	brne	.+26     	; 0x539c <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    5382:	8e 81       	ldd	r24, Y+6	; 0x06
    5384:	28 2f       	mov	r18, r24
    5386:	30 e0       	ldi	r19, 0x00	; 0
    5388:	8a 81       	ldd	r24, Y+2	; 0x02
    538a:	9b 81       	ldd	r25, Y+3	; 0x03
    538c:	82 0f       	add	r24, r18
    538e:	93 1f       	adc	r25, r19
    5390:	fc 01       	movw	r30, r24
    5392:	bb 96       	adiw	r30, 0x2b	; 43
    5394:	10 82       	st	Z, r1
                xReturn = pdPASS;
    5396:	81 e0       	ldi	r24, 0x01	; 1
    5398:	89 83       	std	Y+1, r24	; 0x01
    539a:	01 c0       	rjmp	.+2      	; 0x539e <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    539c:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    539e:	0f 90       	pop	r0
    53a0:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    53a2:	89 81       	ldd	r24, Y+1	; 0x01
    }
    53a4:	28 96       	adiw	r28, 0x08	; 8
    53a6:	0f b6       	in	r0, 0x3f	; 63
    53a8:	f8 94       	cli
    53aa:	de bf       	out	0x3e, r29	; 62
    53ac:	0f be       	out	0x3f, r0	; 63
    53ae:	cd bf       	out	0x3d, r28	; 61
    53b0:	cf 91       	pop	r28
    53b2:	df 91       	pop	r29
    53b4:	08 95       	ret

000053b6 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    53b6:	0f 93       	push	r16
    53b8:	1f 93       	push	r17
    53ba:	df 93       	push	r29
    53bc:	cf 93       	push	r28
    53be:	cd b7       	in	r28, 0x3d	; 61
    53c0:	de b7       	in	r29, 0x3e	; 62
    53c2:	2f 97       	sbiw	r28, 0x0f	; 15
    53c4:	0f b6       	in	r0, 0x3f	; 63
    53c6:	f8 94       	cli
    53c8:	de bf       	out	0x3e, r29	; 62
    53ca:	0f be       	out	0x3f, r0	; 63
    53cc:	cd bf       	out	0x3d, r28	; 61
    53ce:	98 87       	std	Y+8, r25	; 0x08
    53d0:	8f 83       	std	Y+7, r24	; 0x07
    53d2:	69 87       	std	Y+9, r22	; 0x09
    53d4:	2a 87       	std	Y+10, r18	; 0x0a
    53d6:	3b 87       	std	Y+11, r19	; 0x0b
    53d8:	4c 87       	std	Y+12, r20	; 0x0c
    53da:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    53dc:	8f 81       	ldd	r24, Y+7	; 0x07
    53de:	98 85       	ldd	r25, Y+8	; 0x08
    53e0:	00 97       	sbiw	r24, 0x00	; 0
    53e2:	39 f4       	brne	.+14     	; 0x53f2 <ulTaskGenericNotifyValueClear+0x3c>
    53e4:	80 91 a0 07 	lds	r24, 0x07A0
    53e8:	90 91 a1 07 	lds	r25, 0x07A1
    53ec:	9f 87       	std	Y+15, r25	; 0x0f
    53ee:	8e 87       	std	Y+14, r24	; 0x0e
    53f0:	04 c0       	rjmp	.+8      	; 0x53fa <ulTaskGenericNotifyValueClear+0x44>
    53f2:	8f 81       	ldd	r24, Y+7	; 0x07
    53f4:	98 85       	ldd	r25, Y+8	; 0x08
    53f6:	9f 87       	std	Y+15, r25	; 0x0f
    53f8:	8e 87       	std	Y+14, r24	; 0x0e
    53fa:	8e 85       	ldd	r24, Y+14	; 0x0e
    53fc:	9f 85       	ldd	r25, Y+15	; 0x0f
    53fe:	9e 83       	std	Y+6, r25	; 0x06
    5400:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    5402:	0f b6       	in	r0, 0x3f	; 63
    5404:	f8 94       	cli
    5406:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    5408:	89 85       	ldd	r24, Y+9	; 0x09
    540a:	88 2f       	mov	r24, r24
    540c:	90 e0       	ldi	r25, 0x00	; 0
    540e:	2d 81       	ldd	r18, Y+5	; 0x05
    5410:	3e 81       	ldd	r19, Y+6	; 0x06
    5412:	88 0f       	add	r24, r24
    5414:	99 1f       	adc	r25, r25
    5416:	88 0f       	add	r24, r24
    5418:	99 1f       	adc	r25, r25
    541a:	82 0f       	add	r24, r18
    541c:	93 1f       	adc	r25, r19
    541e:	fc 01       	movw	r30, r24
    5420:	b7 96       	adiw	r30, 0x27	; 39
    5422:	80 81       	ld	r24, Z
    5424:	91 81       	ldd	r25, Z+1	; 0x01
    5426:	a2 81       	ldd	r26, Z+2	; 0x02
    5428:	b3 81       	ldd	r27, Z+3	; 0x03
    542a:	89 83       	std	Y+1, r24	; 0x01
    542c:	9a 83       	std	Y+2, r25	; 0x02
    542e:	ab 83       	std	Y+3, r26	; 0x03
    5430:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    5432:	89 85       	ldd	r24, Y+9	; 0x09
    5434:	08 2f       	mov	r16, r24
    5436:	10 e0       	ldi	r17, 0x00	; 0
    5438:	89 85       	ldd	r24, Y+9	; 0x09
    543a:	88 2f       	mov	r24, r24
    543c:	90 e0       	ldi	r25, 0x00	; 0
    543e:	2d 81       	ldd	r18, Y+5	; 0x05
    5440:	3e 81       	ldd	r19, Y+6	; 0x06
    5442:	88 0f       	add	r24, r24
    5444:	99 1f       	adc	r25, r25
    5446:	88 0f       	add	r24, r24
    5448:	99 1f       	adc	r25, r25
    544a:	82 0f       	add	r24, r18
    544c:	93 1f       	adc	r25, r19
    544e:	fc 01       	movw	r30, r24
    5450:	b7 96       	adiw	r30, 0x27	; 39
    5452:	20 81       	ld	r18, Z
    5454:	31 81       	ldd	r19, Z+1	; 0x01
    5456:	42 81       	ldd	r20, Z+2	; 0x02
    5458:	53 81       	ldd	r21, Z+3	; 0x03
    545a:	8a 85       	ldd	r24, Y+10	; 0x0a
    545c:	9b 85       	ldd	r25, Y+11	; 0x0b
    545e:	ac 85       	ldd	r26, Y+12	; 0x0c
    5460:	bd 85       	ldd	r27, Y+13	; 0x0d
    5462:	80 95       	com	r24
    5464:	90 95       	com	r25
    5466:	a0 95       	com	r26
    5468:	b0 95       	com	r27
    546a:	ba 01       	movw	r22, r20
    546c:	a9 01       	movw	r20, r18
    546e:	48 23       	and	r20, r24
    5470:	59 23       	and	r21, r25
    5472:	6a 23       	and	r22, r26
    5474:	7b 23       	and	r23, r27
    5476:	2d 81       	ldd	r18, Y+5	; 0x05
    5478:	3e 81       	ldd	r19, Y+6	; 0x06
    547a:	c8 01       	movw	r24, r16
    547c:	88 0f       	add	r24, r24
    547e:	99 1f       	adc	r25, r25
    5480:	88 0f       	add	r24, r24
    5482:	99 1f       	adc	r25, r25
    5484:	82 0f       	add	r24, r18
    5486:	93 1f       	adc	r25, r19
    5488:	fc 01       	movw	r30, r24
    548a:	b7 96       	adiw	r30, 0x27	; 39
    548c:	40 83       	st	Z, r20
    548e:	51 83       	std	Z+1, r21	; 0x01
    5490:	62 83       	std	Z+2, r22	; 0x02
    5492:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    5494:	0f 90       	pop	r0
    5496:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    5498:	89 81       	ldd	r24, Y+1	; 0x01
    549a:	9a 81       	ldd	r25, Y+2	; 0x02
    549c:	ab 81       	ldd	r26, Y+3	; 0x03
    549e:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    54a0:	bc 01       	movw	r22, r24
    54a2:	cd 01       	movw	r24, r26
    54a4:	2f 96       	adiw	r28, 0x0f	; 15
    54a6:	0f b6       	in	r0, 0x3f	; 63
    54a8:	f8 94       	cli
    54aa:	de bf       	out	0x3e, r29	; 62
    54ac:	0f be       	out	0x3f, r0	; 63
    54ae:	cd bf       	out	0x3d, r28	; 61
    54b0:	cf 91       	pop	r28
    54b2:	df 91       	pop	r29
    54b4:	1f 91       	pop	r17
    54b6:	0f 91       	pop	r16
    54b8:	08 95       	ret

000054ba <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    54ba:	df 93       	push	r29
    54bc:	cf 93       	push	r28
    54be:	cd b7       	in	r28, 0x3d	; 61
    54c0:	de b7       	in	r29, 0x3e	; 62
    54c2:	27 97       	sbiw	r28, 0x07	; 7
    54c4:	0f b6       	in	r0, 0x3f	; 63
    54c6:	f8 94       	cli
    54c8:	de bf       	out	0x3e, r29	; 62
    54ca:	0f be       	out	0x3f, r0	; 63
    54cc:	cd bf       	out	0x3d, r28	; 61
    54ce:	9e 83       	std	Y+6, r25	; 0x06
    54d0:	8d 83       	std	Y+5, r24	; 0x05
    54d2:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    54d4:	80 91 a3 07 	lds	r24, 0x07A3
    54d8:	90 91 a4 07 	lds	r25, 0x07A4
    54dc:	9a 83       	std	Y+2, r25	; 0x02
    54de:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    54e0:	80 91 a0 07 	lds	r24, 0x07A0
    54e4:	90 91 a1 07 	lds	r25, 0x07A1
    54e8:	02 96       	adiw	r24, 0x02	; 2
    54ea:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    54ee:	8d 81       	ldd	r24, Y+5	; 0x05
    54f0:	9e 81       	ldd	r25, Y+6	; 0x06
    54f2:	2f ef       	ldi	r18, 0xFF	; 255
    54f4:	8f 3f       	cpi	r24, 0xFF	; 255
    54f6:	92 07       	cpc	r25, r18
    54f8:	81 f4       	brne	.+32     	; 0x551a <prvAddCurrentTaskToDelayedList+0x60>
    54fa:	8f 81       	ldd	r24, Y+7	; 0x07
    54fc:	88 23       	and	r24, r24
    54fe:	69 f0       	breq	.+26     	; 0x551a <prvAddCurrentTaskToDelayedList+0x60>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5500:	80 91 a0 07 	lds	r24, 0x07A0
    5504:	90 91 a1 07 	lds	r25, 0x07A1
    5508:	9c 01       	movw	r18, r24
    550a:	2e 5f       	subi	r18, 0xFE	; 254
    550c:	3f 4f       	sbci	r19, 0xFF	; 255
    550e:	84 ef       	ldi	r24, 0xF4	; 244
    5510:	97 e0       	ldi	r25, 0x07	; 7
    5512:	b9 01       	movw	r22, r18
    5514:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
    5518:	43 c0       	rjmp	.+134    	; 0x55a0 <prvAddCurrentTaskToDelayedList+0xe6>
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
    551a:	29 81       	ldd	r18, Y+1	; 0x01
    551c:	3a 81       	ldd	r19, Y+2	; 0x02
    551e:	8d 81       	ldd	r24, Y+5	; 0x05
    5520:	9e 81       	ldd	r25, Y+6	; 0x06
    5522:	82 0f       	add	r24, r18
    5524:	93 1f       	adc	r25, r19
    5526:	9c 83       	std	Y+4, r25	; 0x04
    5528:	8b 83       	std	Y+3, r24	; 0x03

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    552a:	e0 91 a0 07 	lds	r30, 0x07A0
    552e:	f0 91 a1 07 	lds	r31, 0x07A1
    5532:	8b 81       	ldd	r24, Y+3	; 0x03
    5534:	9c 81       	ldd	r25, Y+4	; 0x04
    5536:	93 83       	std	Z+3, r25	; 0x03
    5538:	82 83       	std	Z+2, r24	; 0x02

                if( xTimeToWake < xConstTickCount )
    553a:	2b 81       	ldd	r18, Y+3	; 0x03
    553c:	3c 81       	ldd	r19, Y+4	; 0x04
    553e:	89 81       	ldd	r24, Y+1	; 0x01
    5540:	9a 81       	ldd	r25, Y+2	; 0x02
    5542:	28 17       	cp	r18, r24
    5544:	39 07       	cpc	r19, r25
    5546:	70 f4       	brcc	.+28     	; 0x5564 <prvAddCurrentTaskToDelayedList+0xaa>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5548:	80 91 e9 07 	lds	r24, 0x07E9
    554c:	90 91 ea 07 	lds	r25, 0x07EA
    5550:	20 91 a0 07 	lds	r18, 0x07A0
    5554:	30 91 a1 07 	lds	r19, 0x07A1
    5558:	2e 5f       	subi	r18, 0xFE	; 254
    555a:	3f 4f       	sbci	r19, 0xFF	; 255
    555c:	b9 01       	movw	r22, r18
    555e:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>
    5562:	1e c0       	rjmp	.+60     	; 0x55a0 <prvAddCurrentTaskToDelayedList+0xe6>
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5564:	40 91 e7 07 	lds	r20, 0x07E7
    5568:	50 91 e8 07 	lds	r21, 0x07E8
    556c:	80 91 a0 07 	lds	r24, 0x07A0
    5570:	90 91 a1 07 	lds	r25, 0x07A1
    5574:	9c 01       	movw	r18, r24
    5576:	2e 5f       	subi	r18, 0xFE	; 254
    5578:	3f 4f       	sbci	r19, 0xFF	; 255
    557a:	ca 01       	movw	r24, r20
    557c:	b9 01       	movw	r22, r18
    557e:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
    5582:	20 91 ac 07 	lds	r18, 0x07AC
    5586:	30 91 ad 07 	lds	r19, 0x07AD
    558a:	8b 81       	ldd	r24, Y+3	; 0x03
    558c:	9c 81       	ldd	r25, Y+4	; 0x04
    558e:	82 17       	cp	r24, r18
    5590:	93 07       	cpc	r25, r19
    5592:	30 f4       	brcc	.+12     	; 0x55a0 <prvAddCurrentTaskToDelayedList+0xe6>
                    {
                        xNextTaskUnblockTime = xTimeToWake;
    5594:	8b 81       	ldd	r24, Y+3	; 0x03
    5596:	9c 81       	ldd	r25, Y+4	; 0x04
    5598:	90 93 ad 07 	sts	0x07AD, r25
    559c:	80 93 ac 07 	sts	0x07AC, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    55a0:	27 96       	adiw	r28, 0x07	; 7
    55a2:	0f b6       	in	r0, 0x3f	; 63
    55a4:	f8 94       	cli
    55a6:	de bf       	out	0x3e, r29	; 62
    55a8:	0f be       	out	0x3f, r0	; 63
    55aa:	cd bf       	out	0x3d, r28	; 61
    55ac:	cf 91       	pop	r28
    55ae:	df 91       	pop	r29
    55b0:	08 95       	ret

000055b2 <ADC_init>:
/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/

void ADC_init(const ADC_ConfigType * Config_Ptr)
{
    55b2:	df 93       	push	r29
    55b4:	cf 93       	push	r28
    55b6:	00 d0       	rcall	.+0      	; 0x55b8 <ADC_init+0x6>
    55b8:	cd b7       	in	r28, 0x3d	; 61
    55ba:	de b7       	in	r29, 0x3e	; 62
    55bc:	9a 83       	std	Y+2, r25	; 0x02
    55be:	89 83       	std	Y+1, r24	; 0x01
	/* ADMUX Register Bits Description:
	 * ADLAR   = 0 right adjusted
	 * MUX4:0  = 00000 to choose channel 0 as initialization
	 * REF1:0  = 00 Clear these two bits before setup the required reference voltage value
	 */
	ADMUX = 0;
    55c0:	e7 e2       	ldi	r30, 0x27	; 39
    55c2:	f0 e0       	ldi	r31, 0x00	; 0
    55c4:	10 82       	st	Z, r1

	/* Setup the reference voltage value inside the REFS1 and REFS0 bits*/
	ADMUX |= (Config_Ptr->ref_volt << 6);
    55c6:	a7 e2       	ldi	r26, 0x27	; 39
    55c8:	b0 e0       	ldi	r27, 0x00	; 0
    55ca:	e7 e2       	ldi	r30, 0x27	; 39
    55cc:	f0 e0       	ldi	r31, 0x00	; 0
    55ce:	80 81       	ld	r24, Z
    55d0:	28 2f       	mov	r18, r24
    55d2:	e9 81       	ldd	r30, Y+1	; 0x01
    55d4:	fa 81       	ldd	r31, Y+2	; 0x02
    55d6:	80 81       	ld	r24, Z
    55d8:	88 2f       	mov	r24, r24
    55da:	90 e0       	ldi	r25, 0x00	; 0
    55dc:	00 24       	eor	r0, r0
    55de:	96 95       	lsr	r25
    55e0:	87 95       	ror	r24
    55e2:	07 94       	ror	r0
    55e4:	96 95       	lsr	r25
    55e6:	87 95       	ror	r24
    55e8:	07 94       	ror	r0
    55ea:	98 2f       	mov	r25, r24
    55ec:	80 2d       	mov	r24, r0
    55ee:	82 2b       	or	r24, r18
    55f0:	8c 93       	st	X, r24
	 * ADEN    = 1 Enable ADC
	 * ADIE    = 0 Disable ADC Interrupt
	 * ADATE   = 0 Disable the AUTO trigger
	 * ADPS2:0 = 000 Clear these three bits before setup the required prescaler value
	 */
	ADCSRA = (1<<ADEN);
    55f2:	e6 e2       	ldi	r30, 0x26	; 38
    55f4:	f0 e0       	ldi	r31, 0x00	; 0
    55f6:	80 e8       	ldi	r24, 0x80	; 128
    55f8:	80 83       	st	Z, r24

	/* Setup the prescaler value inside the ADPS2, ADPS1 and ADPS0 bits*/
	ADCSRA |= Config_Ptr->prescaler;
    55fa:	a6 e2       	ldi	r26, 0x26	; 38
    55fc:	b0 e0       	ldi	r27, 0x00	; 0
    55fe:	e6 e2       	ldi	r30, 0x26	; 38
    5600:	f0 e0       	ldi	r31, 0x00	; 0
    5602:	90 81       	ld	r25, Z
    5604:	e9 81       	ldd	r30, Y+1	; 0x01
    5606:	fa 81       	ldd	r31, Y+2	; 0x02
    5608:	81 81       	ldd	r24, Z+1	; 0x01
    560a:	89 2b       	or	r24, r25
    560c:	8c 93       	st	X, r24
}
    560e:	0f 90       	pop	r0
    5610:	0f 90       	pop	r0
    5612:	cf 91       	pop	r28
    5614:	df 91       	pop	r29
    5616:	08 95       	ret

00005618 <ADC_readChannel>:

uint16 ADC_readChannel(uint8 channel_num)
{
    5618:	df 93       	push	r29
    561a:	cf 93       	push	r28
    561c:	0f 92       	push	r0
    561e:	cd b7       	in	r28, 0x3d	; 61
    5620:	de b7       	in	r29, 0x3e	; 62
    5622:	89 83       	std	Y+1, r24	; 0x01
	channel_num &= 0x07; /* Input channel number must be from 0 --> 7 */
    5624:	89 81       	ldd	r24, Y+1	; 0x01
    5626:	87 70       	andi	r24, 0x07	; 7
    5628:	89 83       	std	Y+1, r24	; 0x01
	ADMUX &= 0xE0; /* Clear first 5 bits in the ADMUX (channel number MUX4:0 bits) before set the required channel */
    562a:	a7 e2       	ldi	r26, 0x27	; 39
    562c:	b0 e0       	ldi	r27, 0x00	; 0
    562e:	e7 e2       	ldi	r30, 0x27	; 39
    5630:	f0 e0       	ldi	r31, 0x00	; 0
    5632:	80 81       	ld	r24, Z
    5634:	80 7e       	andi	r24, 0xE0	; 224
    5636:	8c 93       	st	X, r24
	ADMUX = ADMUX | channel_num; /* Choose the correct channel by setting the channel number in MUX4:0 bits */
    5638:	a7 e2       	ldi	r26, 0x27	; 39
    563a:	b0 e0       	ldi	r27, 0x00	; 0
    563c:	e7 e2       	ldi	r30, 0x27	; 39
    563e:	f0 e0       	ldi	r31, 0x00	; 0
    5640:	90 81       	ld	r25, Z
    5642:	89 81       	ldd	r24, Y+1	; 0x01
    5644:	89 2b       	or	r24, r25
    5646:	8c 93       	st	X, r24
	SET_BIT(ADCSRA,ADSC); /* Start conversion write '1' to ADSC */
    5648:	a6 e2       	ldi	r26, 0x26	; 38
    564a:	b0 e0       	ldi	r27, 0x00	; 0
    564c:	e6 e2       	ldi	r30, 0x26	; 38
    564e:	f0 e0       	ldi	r31, 0x00	; 0
    5650:	80 81       	ld	r24, Z
    5652:	80 64       	ori	r24, 0x40	; 64
    5654:	8c 93       	st	X, r24
	while(BIT_IS_CLEAR(ADCSRA,ADIF)); /* Wait for conversion to complete, ADIF becomes '1' */
    5656:	e6 e2       	ldi	r30, 0x26	; 38
    5658:	f0 e0       	ldi	r31, 0x00	; 0
    565a:	80 81       	ld	r24, Z
    565c:	88 2f       	mov	r24, r24
    565e:	90 e0       	ldi	r25, 0x00	; 0
    5660:	80 71       	andi	r24, 0x10	; 16
    5662:	90 70       	andi	r25, 0x00	; 0
    5664:	00 97       	sbiw	r24, 0x00	; 0
    5666:	b9 f3       	breq	.-18     	; 0x5656 <ADC_readChannel+0x3e>
	SET_BIT(ADCSRA,ADIF); /* Clear ADIF by write '1' to it :) */
    5668:	a6 e2       	ldi	r26, 0x26	; 38
    566a:	b0 e0       	ldi	r27, 0x00	; 0
    566c:	e6 e2       	ldi	r30, 0x26	; 38
    566e:	f0 e0       	ldi	r31, 0x00	; 0
    5670:	80 81       	ld	r24, Z
    5672:	80 61       	ori	r24, 0x10	; 16
    5674:	8c 93       	st	X, r24
	return ADC; /* Read the digital value from the data register */
    5676:	e4 e2       	ldi	r30, 0x24	; 36
    5678:	f0 e0       	ldi	r31, 0x00	; 0
    567a:	80 81       	ld	r24, Z
    567c:	91 81       	ldd	r25, Z+1	; 0x01
}
    567e:	0f 90       	pop	r0
    5680:	cf 91       	pop	r28
    5682:	df 91       	pop	r29
    5684:	08 95       	ret

00005686 <DcMotor_Init>:
 * Initialize the DC Motor by:
 * 1. Setup the direction of the two motor pins as output by send the request to GPIO driver.
 * 2. Stop the motor at the beginning
 */
void DcMotor_Init(void)
{
    5686:	df 93       	push	r29
    5688:	cf 93       	push	r28
    568a:	cd b7       	in	r28, 0x3d	; 61
    568c:	de b7       	in	r29, 0x3e	; 62
	/* Setup the two motor pins as output pins */
	GPIO_setupPinDirection(DC_MOTOR_PORT1_ID,DC_MOTOR_PIN1_ID,PIN_OUTPUT);
    568e:	81 e0       	ldi	r24, 0x01	; 1
    5690:	60 e0       	ldi	r22, 0x00	; 0
    5692:	41 e0       	ldi	r20, 0x01	; 1
    5694:	0e 94 9c 2b 	call	0x5738	; 0x5738 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(DC_MOTOR_PORT2_ID,DC_MOTOR_PIN2_ID,PIN_OUTPUT);
    5698:	81 e0       	ldi	r24, 0x01	; 1
    569a:	61 e0       	ldi	r22, 0x01	; 1
    569c:	41 e0       	ldi	r20, 0x01	; 1
    569e:	0e 94 9c 2b 	call	0x5738	; 0x5738 <GPIO_setupPinDirection>

	/* Motor is stopped at the beginning */
	GPIO_writePin(DC_MOTOR_PORT1_ID,DC_MOTOR_PIN1_ID,LOGIC_LOW);
    56a2:	81 e0       	ldi	r24, 0x01	; 1
    56a4:	60 e0       	ldi	r22, 0x00	; 0
    56a6:	40 e0       	ldi	r20, 0x00	; 0
    56a8:	0e 94 87 2c 	call	0x590e	; 0x590e <GPIO_writePin>
	GPIO_writePin(DC_MOTOR_PORT2_ID,DC_MOTOR_PIN2_ID,LOGIC_LOW);
    56ac:	81 e0       	ldi	r24, 0x01	; 1
    56ae:	61 e0       	ldi	r22, 0x01	; 1
    56b0:	40 e0       	ldi	r20, 0x00	; 0
    56b2:	0e 94 87 2c 	call	0x590e	; 0x590e <GPIO_writePin>
}
    56b6:	cf 91       	pop	r28
    56b8:	df 91       	pop	r29
    56ba:	08 95       	ret

000056bc <DcMotor_Rotate>:
 * Description :
 * 1. Rotate  or Stop the motor according to the state input variable.
 * 2. Control the motor speed 0 --> 100% from its maximum speed by sending to PWM driver.
 */
void DcMotor_Rotate(DcMotor_State state,uint8 speed)
{
    56bc:	df 93       	push	r29
    56be:	cf 93       	push	r28
    56c0:	00 d0       	rcall	.+0      	; 0x56c2 <DcMotor_Rotate+0x6>
    56c2:	cd b7       	in	r28, 0x3d	; 61
    56c4:	de b7       	in	r29, 0x3e	; 62
    56c6:	89 83       	std	Y+1, r24	; 0x01
    56c8:	6a 83       	std	Y+2, r22	; 0x02
	if(state == DC_MOTOR_CW)
    56ca:	89 81       	ldd	r24, Y+1	; 0x01
    56cc:	81 30       	cpi	r24, 0x01	; 1
    56ce:	71 f4       	brne	.+28     	; 0x56ec <DcMotor_Rotate+0x30>
	{
		/* Rotates the Motor CW */
		GPIO_writePin(DC_MOTOR_PORT1_ID,DC_MOTOR_PIN1_ID,LOGIC_LOW);
    56d0:	81 e0       	ldi	r24, 0x01	; 1
    56d2:	60 e0       	ldi	r22, 0x00	; 0
    56d4:	40 e0       	ldi	r20, 0x00	; 0
    56d6:	0e 94 87 2c 	call	0x590e	; 0x590e <GPIO_writePin>
		GPIO_writePin(DC_MOTOR_PORT2_ID,DC_MOTOR_PIN2_ID,LOGIC_HIGH);
    56da:	81 e0       	ldi	r24, 0x01	; 1
    56dc:	61 e0       	ldi	r22, 0x01	; 1
    56de:	41 e0       	ldi	r20, 0x01	; 1
    56e0:	0e 94 87 2c 	call	0x590e	; 0x590e <GPIO_writePin>

		PWM_Timer0_Start(speed);
    56e4:	8a 81       	ldd	r24, Y+2	; 0x02
    56e6:	0e 94 1b 35 	call	0x6a36	; 0x6a36 <PWM_Timer0_Start>
    56ea:	21 c0       	rjmp	.+66     	; 0x572e <DcMotor_Rotate+0x72>
	}
	else if(state == DC_MOTOR_ACW)
    56ec:	89 81       	ldd	r24, Y+1	; 0x01
    56ee:	82 30       	cpi	r24, 0x02	; 2
    56f0:	71 f4       	brne	.+28     	; 0x570e <DcMotor_Rotate+0x52>
	{
		/* Rotates the Motor A-CW */
		GPIO_writePin(DC_MOTOR_PORT1_ID,DC_MOTOR_PIN1_ID,LOGIC_HIGH);
    56f2:	81 e0       	ldi	r24, 0x01	; 1
    56f4:	60 e0       	ldi	r22, 0x00	; 0
    56f6:	41 e0       	ldi	r20, 0x01	; 1
    56f8:	0e 94 87 2c 	call	0x590e	; 0x590e <GPIO_writePin>
		GPIO_writePin(DC_MOTOR_PORT2_ID,DC_MOTOR_PIN2_ID,LOGIC_LOW);
    56fc:	81 e0       	ldi	r24, 0x01	; 1
    56fe:	61 e0       	ldi	r22, 0x01	; 1
    5700:	40 e0       	ldi	r20, 0x00	; 0
    5702:	0e 94 87 2c 	call	0x590e	; 0x590e <GPIO_writePin>

		PWM_Timer0_Start(speed);
    5706:	8a 81       	ldd	r24, Y+2	; 0x02
    5708:	0e 94 1b 35 	call	0x6a36	; 0x6a36 <PWM_Timer0_Start>
    570c:	10 c0       	rjmp	.+32     	; 0x572e <DcMotor_Rotate+0x72>
	}
	else if(state == DC_MOTOR_STOP)
    570e:	89 81       	ldd	r24, Y+1	; 0x01
    5710:	88 23       	and	r24, r24
    5712:	69 f4       	brne	.+26     	; 0x572e <DcMotor_Rotate+0x72>
	{
		/* Stop the Motor */
		GPIO_writePin(DC_MOTOR_PORT1_ID,DC_MOTOR_PIN1_ID,LOGIC_LOW);
    5714:	81 e0       	ldi	r24, 0x01	; 1
    5716:	60 e0       	ldi	r22, 0x00	; 0
    5718:	40 e0       	ldi	r20, 0x00	; 0
    571a:	0e 94 87 2c 	call	0x590e	; 0x590e <GPIO_writePin>
		GPIO_writePin(DC_MOTOR_PORT2_ID,DC_MOTOR_PIN2_ID,LOGIC_LOW);
    571e:	81 e0       	ldi	r24, 0x01	; 1
    5720:	61 e0       	ldi	r22, 0x01	; 1
    5722:	40 e0       	ldi	r20, 0x00	; 0
    5724:	0e 94 87 2c 	call	0x590e	; 0x590e <GPIO_writePin>

		PWM_Timer0_Start(speed);
    5728:	8a 81       	ldd	r24, Y+2	; 0x02
    572a:	0e 94 1b 35 	call	0x6a36	; 0x6a36 <PWM_Timer0_Start>
	}
	else
	{
		/* Invalid Input State - Do Nothing */
	}
}
    572e:	0f 90       	pop	r0
    5730:	0f 90       	pop	r0
    5732:	cf 91       	pop	r28
    5734:	df 91       	pop	r29
    5736:	08 95       	ret

00005738 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
    5738:	df 93       	push	r29
    573a:	cf 93       	push	r28
    573c:	00 d0       	rcall	.+0      	; 0x573e <GPIO_setupPinDirection+0x6>
    573e:	00 d0       	rcall	.+0      	; 0x5740 <GPIO_setupPinDirection+0x8>
    5740:	0f 92       	push	r0
    5742:	cd b7       	in	r28, 0x3d	; 61
    5744:	de b7       	in	r29, 0x3e	; 62
    5746:	89 83       	std	Y+1, r24	; 0x01
    5748:	6a 83       	std	Y+2, r22	; 0x02
    574a:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    574c:	8a 81       	ldd	r24, Y+2	; 0x02
    574e:	88 30       	cpi	r24, 0x08	; 8
    5750:	08 f0       	brcs	.+2      	; 0x5754 <GPIO_setupPinDirection+0x1c>
    5752:	d5 c0       	rjmp	.+426    	; 0x58fe <GPIO_setupPinDirection+0x1c6>
    5754:	89 81       	ldd	r24, Y+1	; 0x01
    5756:	84 30       	cpi	r24, 0x04	; 4
    5758:	08 f0       	brcs	.+2      	; 0x575c <GPIO_setupPinDirection+0x24>
    575a:	d1 c0       	rjmp	.+418    	; 0x58fe <GPIO_setupPinDirection+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
    575c:	89 81       	ldd	r24, Y+1	; 0x01
    575e:	28 2f       	mov	r18, r24
    5760:	30 e0       	ldi	r19, 0x00	; 0
    5762:	3d 83       	std	Y+5, r19	; 0x05
    5764:	2c 83       	std	Y+4, r18	; 0x04
    5766:	8c 81       	ldd	r24, Y+4	; 0x04
    5768:	9d 81       	ldd	r25, Y+5	; 0x05
    576a:	81 30       	cpi	r24, 0x01	; 1
    576c:	91 05       	cpc	r25, r1
    576e:	09 f4       	brne	.+2      	; 0x5772 <GPIO_setupPinDirection+0x3a>
    5770:	43 c0       	rjmp	.+134    	; 0x57f8 <GPIO_setupPinDirection+0xc0>
    5772:	2c 81       	ldd	r18, Y+4	; 0x04
    5774:	3d 81       	ldd	r19, Y+5	; 0x05
    5776:	22 30       	cpi	r18, 0x02	; 2
    5778:	31 05       	cpc	r19, r1
    577a:	2c f4       	brge	.+10     	; 0x5786 <GPIO_setupPinDirection+0x4e>
    577c:	8c 81       	ldd	r24, Y+4	; 0x04
    577e:	9d 81       	ldd	r25, Y+5	; 0x05
    5780:	00 97       	sbiw	r24, 0x00	; 0
    5782:	71 f0       	breq	.+28     	; 0x57a0 <GPIO_setupPinDirection+0x68>
    5784:	bc c0       	rjmp	.+376    	; 0x58fe <GPIO_setupPinDirection+0x1c6>
    5786:	2c 81       	ldd	r18, Y+4	; 0x04
    5788:	3d 81       	ldd	r19, Y+5	; 0x05
    578a:	22 30       	cpi	r18, 0x02	; 2
    578c:	31 05       	cpc	r19, r1
    578e:	09 f4       	brne	.+2      	; 0x5792 <GPIO_setupPinDirection+0x5a>
    5790:	5f c0       	rjmp	.+190    	; 0x5850 <GPIO_setupPinDirection+0x118>
    5792:	8c 81       	ldd	r24, Y+4	; 0x04
    5794:	9d 81       	ldd	r25, Y+5	; 0x05
    5796:	83 30       	cpi	r24, 0x03	; 3
    5798:	91 05       	cpc	r25, r1
    579a:	09 f4       	brne	.+2      	; 0x579e <GPIO_setupPinDirection+0x66>
    579c:	85 c0       	rjmp	.+266    	; 0x58a8 <GPIO_setupPinDirection+0x170>
    579e:	af c0       	rjmp	.+350    	; 0x58fe <GPIO_setupPinDirection+0x1c6>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
    57a0:	8b 81       	ldd	r24, Y+3	; 0x03
    57a2:	81 30       	cpi	r24, 0x01	; 1
    57a4:	a1 f4       	brne	.+40     	; 0x57ce <GPIO_setupPinDirection+0x96>
			{
				SET_BIT(DDRA,pin_num);
    57a6:	aa e3       	ldi	r26, 0x3A	; 58
    57a8:	b0 e0       	ldi	r27, 0x00	; 0
    57aa:	ea e3       	ldi	r30, 0x3A	; 58
    57ac:	f0 e0       	ldi	r31, 0x00	; 0
    57ae:	80 81       	ld	r24, Z
    57b0:	48 2f       	mov	r20, r24
    57b2:	8a 81       	ldd	r24, Y+2	; 0x02
    57b4:	28 2f       	mov	r18, r24
    57b6:	30 e0       	ldi	r19, 0x00	; 0
    57b8:	81 e0       	ldi	r24, 0x01	; 1
    57ba:	90 e0       	ldi	r25, 0x00	; 0
    57bc:	02 2e       	mov	r0, r18
    57be:	02 c0       	rjmp	.+4      	; 0x57c4 <GPIO_setupPinDirection+0x8c>
    57c0:	88 0f       	add	r24, r24
    57c2:	99 1f       	adc	r25, r25
    57c4:	0a 94       	dec	r0
    57c6:	e2 f7       	brpl	.-8      	; 0x57c0 <GPIO_setupPinDirection+0x88>
    57c8:	84 2b       	or	r24, r20
    57ca:	8c 93       	st	X, r24
    57cc:	98 c0       	rjmp	.+304    	; 0x58fe <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
    57ce:	aa e3       	ldi	r26, 0x3A	; 58
    57d0:	b0 e0       	ldi	r27, 0x00	; 0
    57d2:	ea e3       	ldi	r30, 0x3A	; 58
    57d4:	f0 e0       	ldi	r31, 0x00	; 0
    57d6:	80 81       	ld	r24, Z
    57d8:	48 2f       	mov	r20, r24
    57da:	8a 81       	ldd	r24, Y+2	; 0x02
    57dc:	28 2f       	mov	r18, r24
    57de:	30 e0       	ldi	r19, 0x00	; 0
    57e0:	81 e0       	ldi	r24, 0x01	; 1
    57e2:	90 e0       	ldi	r25, 0x00	; 0
    57e4:	02 2e       	mov	r0, r18
    57e6:	02 c0       	rjmp	.+4      	; 0x57ec <GPIO_setupPinDirection+0xb4>
    57e8:	88 0f       	add	r24, r24
    57ea:	99 1f       	adc	r25, r25
    57ec:	0a 94       	dec	r0
    57ee:	e2 f7       	brpl	.-8      	; 0x57e8 <GPIO_setupPinDirection+0xb0>
    57f0:	80 95       	com	r24
    57f2:	84 23       	and	r24, r20
    57f4:	8c 93       	st	X, r24
    57f6:	83 c0       	rjmp	.+262    	; 0x58fe <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
    57f8:	8b 81       	ldd	r24, Y+3	; 0x03
    57fa:	81 30       	cpi	r24, 0x01	; 1
    57fc:	a1 f4       	brne	.+40     	; 0x5826 <GPIO_setupPinDirection+0xee>
			{
				SET_BIT(DDRB,pin_num);
    57fe:	a7 e3       	ldi	r26, 0x37	; 55
    5800:	b0 e0       	ldi	r27, 0x00	; 0
    5802:	e7 e3       	ldi	r30, 0x37	; 55
    5804:	f0 e0       	ldi	r31, 0x00	; 0
    5806:	80 81       	ld	r24, Z
    5808:	48 2f       	mov	r20, r24
    580a:	8a 81       	ldd	r24, Y+2	; 0x02
    580c:	28 2f       	mov	r18, r24
    580e:	30 e0       	ldi	r19, 0x00	; 0
    5810:	81 e0       	ldi	r24, 0x01	; 1
    5812:	90 e0       	ldi	r25, 0x00	; 0
    5814:	02 2e       	mov	r0, r18
    5816:	02 c0       	rjmp	.+4      	; 0x581c <GPIO_setupPinDirection+0xe4>
    5818:	88 0f       	add	r24, r24
    581a:	99 1f       	adc	r25, r25
    581c:	0a 94       	dec	r0
    581e:	e2 f7       	brpl	.-8      	; 0x5818 <GPIO_setupPinDirection+0xe0>
    5820:	84 2b       	or	r24, r20
    5822:	8c 93       	st	X, r24
    5824:	6c c0       	rjmp	.+216    	; 0x58fe <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
    5826:	a7 e3       	ldi	r26, 0x37	; 55
    5828:	b0 e0       	ldi	r27, 0x00	; 0
    582a:	e7 e3       	ldi	r30, 0x37	; 55
    582c:	f0 e0       	ldi	r31, 0x00	; 0
    582e:	80 81       	ld	r24, Z
    5830:	48 2f       	mov	r20, r24
    5832:	8a 81       	ldd	r24, Y+2	; 0x02
    5834:	28 2f       	mov	r18, r24
    5836:	30 e0       	ldi	r19, 0x00	; 0
    5838:	81 e0       	ldi	r24, 0x01	; 1
    583a:	90 e0       	ldi	r25, 0x00	; 0
    583c:	02 2e       	mov	r0, r18
    583e:	02 c0       	rjmp	.+4      	; 0x5844 <GPIO_setupPinDirection+0x10c>
    5840:	88 0f       	add	r24, r24
    5842:	99 1f       	adc	r25, r25
    5844:	0a 94       	dec	r0
    5846:	e2 f7       	brpl	.-8      	; 0x5840 <GPIO_setupPinDirection+0x108>
    5848:	80 95       	com	r24
    584a:	84 23       	and	r24, r20
    584c:	8c 93       	st	X, r24
    584e:	57 c0       	rjmp	.+174    	; 0x58fe <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
    5850:	8b 81       	ldd	r24, Y+3	; 0x03
    5852:	81 30       	cpi	r24, 0x01	; 1
    5854:	a1 f4       	brne	.+40     	; 0x587e <GPIO_setupPinDirection+0x146>
			{
				SET_BIT(DDRC,pin_num);
    5856:	a4 e3       	ldi	r26, 0x34	; 52
    5858:	b0 e0       	ldi	r27, 0x00	; 0
    585a:	e4 e3       	ldi	r30, 0x34	; 52
    585c:	f0 e0       	ldi	r31, 0x00	; 0
    585e:	80 81       	ld	r24, Z
    5860:	48 2f       	mov	r20, r24
    5862:	8a 81       	ldd	r24, Y+2	; 0x02
    5864:	28 2f       	mov	r18, r24
    5866:	30 e0       	ldi	r19, 0x00	; 0
    5868:	81 e0       	ldi	r24, 0x01	; 1
    586a:	90 e0       	ldi	r25, 0x00	; 0
    586c:	02 2e       	mov	r0, r18
    586e:	02 c0       	rjmp	.+4      	; 0x5874 <GPIO_setupPinDirection+0x13c>
    5870:	88 0f       	add	r24, r24
    5872:	99 1f       	adc	r25, r25
    5874:	0a 94       	dec	r0
    5876:	e2 f7       	brpl	.-8      	; 0x5870 <GPIO_setupPinDirection+0x138>
    5878:	84 2b       	or	r24, r20
    587a:	8c 93       	st	X, r24
    587c:	40 c0       	rjmp	.+128    	; 0x58fe <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
    587e:	a4 e3       	ldi	r26, 0x34	; 52
    5880:	b0 e0       	ldi	r27, 0x00	; 0
    5882:	e4 e3       	ldi	r30, 0x34	; 52
    5884:	f0 e0       	ldi	r31, 0x00	; 0
    5886:	80 81       	ld	r24, Z
    5888:	48 2f       	mov	r20, r24
    588a:	8a 81       	ldd	r24, Y+2	; 0x02
    588c:	28 2f       	mov	r18, r24
    588e:	30 e0       	ldi	r19, 0x00	; 0
    5890:	81 e0       	ldi	r24, 0x01	; 1
    5892:	90 e0       	ldi	r25, 0x00	; 0
    5894:	02 2e       	mov	r0, r18
    5896:	02 c0       	rjmp	.+4      	; 0x589c <GPIO_setupPinDirection+0x164>
    5898:	88 0f       	add	r24, r24
    589a:	99 1f       	adc	r25, r25
    589c:	0a 94       	dec	r0
    589e:	e2 f7       	brpl	.-8      	; 0x5898 <GPIO_setupPinDirection+0x160>
    58a0:	80 95       	com	r24
    58a2:	84 23       	and	r24, r20
    58a4:	8c 93       	st	X, r24
    58a6:	2b c0       	rjmp	.+86     	; 0x58fe <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
    58a8:	8b 81       	ldd	r24, Y+3	; 0x03
    58aa:	81 30       	cpi	r24, 0x01	; 1
    58ac:	a1 f4       	brne	.+40     	; 0x58d6 <GPIO_setupPinDirection+0x19e>
			{
				SET_BIT(DDRD,pin_num);
    58ae:	a1 e3       	ldi	r26, 0x31	; 49
    58b0:	b0 e0       	ldi	r27, 0x00	; 0
    58b2:	e1 e3       	ldi	r30, 0x31	; 49
    58b4:	f0 e0       	ldi	r31, 0x00	; 0
    58b6:	80 81       	ld	r24, Z
    58b8:	48 2f       	mov	r20, r24
    58ba:	8a 81       	ldd	r24, Y+2	; 0x02
    58bc:	28 2f       	mov	r18, r24
    58be:	30 e0       	ldi	r19, 0x00	; 0
    58c0:	81 e0       	ldi	r24, 0x01	; 1
    58c2:	90 e0       	ldi	r25, 0x00	; 0
    58c4:	02 2e       	mov	r0, r18
    58c6:	02 c0       	rjmp	.+4      	; 0x58cc <GPIO_setupPinDirection+0x194>
    58c8:	88 0f       	add	r24, r24
    58ca:	99 1f       	adc	r25, r25
    58cc:	0a 94       	dec	r0
    58ce:	e2 f7       	brpl	.-8      	; 0x58c8 <GPIO_setupPinDirection+0x190>
    58d0:	84 2b       	or	r24, r20
    58d2:	8c 93       	st	X, r24
    58d4:	14 c0       	rjmp	.+40     	; 0x58fe <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
    58d6:	a1 e3       	ldi	r26, 0x31	; 49
    58d8:	b0 e0       	ldi	r27, 0x00	; 0
    58da:	e1 e3       	ldi	r30, 0x31	; 49
    58dc:	f0 e0       	ldi	r31, 0x00	; 0
    58de:	80 81       	ld	r24, Z
    58e0:	48 2f       	mov	r20, r24
    58e2:	8a 81       	ldd	r24, Y+2	; 0x02
    58e4:	28 2f       	mov	r18, r24
    58e6:	30 e0       	ldi	r19, 0x00	; 0
    58e8:	81 e0       	ldi	r24, 0x01	; 1
    58ea:	90 e0       	ldi	r25, 0x00	; 0
    58ec:	02 2e       	mov	r0, r18
    58ee:	02 c0       	rjmp	.+4      	; 0x58f4 <GPIO_setupPinDirection+0x1bc>
    58f0:	88 0f       	add	r24, r24
    58f2:	99 1f       	adc	r25, r25
    58f4:	0a 94       	dec	r0
    58f6:	e2 f7       	brpl	.-8      	; 0x58f0 <GPIO_setupPinDirection+0x1b8>
    58f8:	80 95       	com	r24
    58fa:	84 23       	and	r24, r20
    58fc:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    58fe:	0f 90       	pop	r0
    5900:	0f 90       	pop	r0
    5902:	0f 90       	pop	r0
    5904:	0f 90       	pop	r0
    5906:	0f 90       	pop	r0
    5908:	cf 91       	pop	r28
    590a:	df 91       	pop	r29
    590c:	08 95       	ret

0000590e <GPIO_writePin>:
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value)
{
    590e:	df 93       	push	r29
    5910:	cf 93       	push	r28
    5912:	00 d0       	rcall	.+0      	; 0x5914 <GPIO_writePin+0x6>
    5914:	00 d0       	rcall	.+0      	; 0x5916 <GPIO_writePin+0x8>
    5916:	0f 92       	push	r0
    5918:	cd b7       	in	r28, 0x3d	; 61
    591a:	de b7       	in	r29, 0x3e	; 62
    591c:	89 83       	std	Y+1, r24	; 0x01
    591e:	6a 83       	std	Y+2, r22	; 0x02
    5920:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    5922:	8a 81       	ldd	r24, Y+2	; 0x02
    5924:	88 30       	cpi	r24, 0x08	; 8
    5926:	08 f0       	brcs	.+2      	; 0x592a <GPIO_writePin+0x1c>
    5928:	d5 c0       	rjmp	.+426    	; 0x5ad4 <GPIO_writePin+0x1c6>
    592a:	89 81       	ldd	r24, Y+1	; 0x01
    592c:	84 30       	cpi	r24, 0x04	; 4
    592e:	08 f0       	brcs	.+2      	; 0x5932 <GPIO_writePin+0x24>
    5930:	d1 c0       	rjmp	.+418    	; 0x5ad4 <GPIO_writePin+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
    5932:	89 81       	ldd	r24, Y+1	; 0x01
    5934:	28 2f       	mov	r18, r24
    5936:	30 e0       	ldi	r19, 0x00	; 0
    5938:	3d 83       	std	Y+5, r19	; 0x05
    593a:	2c 83       	std	Y+4, r18	; 0x04
    593c:	8c 81       	ldd	r24, Y+4	; 0x04
    593e:	9d 81       	ldd	r25, Y+5	; 0x05
    5940:	81 30       	cpi	r24, 0x01	; 1
    5942:	91 05       	cpc	r25, r1
    5944:	09 f4       	brne	.+2      	; 0x5948 <GPIO_writePin+0x3a>
    5946:	43 c0       	rjmp	.+134    	; 0x59ce <GPIO_writePin+0xc0>
    5948:	2c 81       	ldd	r18, Y+4	; 0x04
    594a:	3d 81       	ldd	r19, Y+5	; 0x05
    594c:	22 30       	cpi	r18, 0x02	; 2
    594e:	31 05       	cpc	r19, r1
    5950:	2c f4       	brge	.+10     	; 0x595c <GPIO_writePin+0x4e>
    5952:	8c 81       	ldd	r24, Y+4	; 0x04
    5954:	9d 81       	ldd	r25, Y+5	; 0x05
    5956:	00 97       	sbiw	r24, 0x00	; 0
    5958:	71 f0       	breq	.+28     	; 0x5976 <GPIO_writePin+0x68>
    595a:	bc c0       	rjmp	.+376    	; 0x5ad4 <GPIO_writePin+0x1c6>
    595c:	2c 81       	ldd	r18, Y+4	; 0x04
    595e:	3d 81       	ldd	r19, Y+5	; 0x05
    5960:	22 30       	cpi	r18, 0x02	; 2
    5962:	31 05       	cpc	r19, r1
    5964:	09 f4       	brne	.+2      	; 0x5968 <GPIO_writePin+0x5a>
    5966:	5f c0       	rjmp	.+190    	; 0x5a26 <GPIO_writePin+0x118>
    5968:	8c 81       	ldd	r24, Y+4	; 0x04
    596a:	9d 81       	ldd	r25, Y+5	; 0x05
    596c:	83 30       	cpi	r24, 0x03	; 3
    596e:	91 05       	cpc	r25, r1
    5970:	09 f4       	brne	.+2      	; 0x5974 <GPIO_writePin+0x66>
    5972:	85 c0       	rjmp	.+266    	; 0x5a7e <GPIO_writePin+0x170>
    5974:	af c0       	rjmp	.+350    	; 0x5ad4 <GPIO_writePin+0x1c6>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH)
    5976:	8b 81       	ldd	r24, Y+3	; 0x03
    5978:	81 30       	cpi	r24, 0x01	; 1
    597a:	a1 f4       	brne	.+40     	; 0x59a4 <GPIO_writePin+0x96>
			{
				SET_BIT(PORTA,pin_num);
    597c:	ab e3       	ldi	r26, 0x3B	; 59
    597e:	b0 e0       	ldi	r27, 0x00	; 0
    5980:	eb e3       	ldi	r30, 0x3B	; 59
    5982:	f0 e0       	ldi	r31, 0x00	; 0
    5984:	80 81       	ld	r24, Z
    5986:	48 2f       	mov	r20, r24
    5988:	8a 81       	ldd	r24, Y+2	; 0x02
    598a:	28 2f       	mov	r18, r24
    598c:	30 e0       	ldi	r19, 0x00	; 0
    598e:	81 e0       	ldi	r24, 0x01	; 1
    5990:	90 e0       	ldi	r25, 0x00	; 0
    5992:	02 2e       	mov	r0, r18
    5994:	02 c0       	rjmp	.+4      	; 0x599a <GPIO_writePin+0x8c>
    5996:	88 0f       	add	r24, r24
    5998:	99 1f       	adc	r25, r25
    599a:	0a 94       	dec	r0
    599c:	e2 f7       	brpl	.-8      	; 0x5996 <GPIO_writePin+0x88>
    599e:	84 2b       	or	r24, r20
    59a0:	8c 93       	st	X, r24
    59a2:	98 c0       	rjmp	.+304    	; 0x5ad4 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTA,pin_num);
    59a4:	ab e3       	ldi	r26, 0x3B	; 59
    59a6:	b0 e0       	ldi	r27, 0x00	; 0
    59a8:	eb e3       	ldi	r30, 0x3B	; 59
    59aa:	f0 e0       	ldi	r31, 0x00	; 0
    59ac:	80 81       	ld	r24, Z
    59ae:	48 2f       	mov	r20, r24
    59b0:	8a 81       	ldd	r24, Y+2	; 0x02
    59b2:	28 2f       	mov	r18, r24
    59b4:	30 e0       	ldi	r19, 0x00	; 0
    59b6:	81 e0       	ldi	r24, 0x01	; 1
    59b8:	90 e0       	ldi	r25, 0x00	; 0
    59ba:	02 2e       	mov	r0, r18
    59bc:	02 c0       	rjmp	.+4      	; 0x59c2 <GPIO_writePin+0xb4>
    59be:	88 0f       	add	r24, r24
    59c0:	99 1f       	adc	r25, r25
    59c2:	0a 94       	dec	r0
    59c4:	e2 f7       	brpl	.-8      	; 0x59be <GPIO_writePin+0xb0>
    59c6:	80 95       	com	r24
    59c8:	84 23       	and	r24, r20
    59ca:	8c 93       	st	X, r24
    59cc:	83 c0       	rjmp	.+262    	; 0x5ad4 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTB_ID:
			if(value == LOGIC_HIGH)
    59ce:	8b 81       	ldd	r24, Y+3	; 0x03
    59d0:	81 30       	cpi	r24, 0x01	; 1
    59d2:	a1 f4       	brne	.+40     	; 0x59fc <GPIO_writePin+0xee>
			{
				SET_BIT(PORTB,pin_num);
    59d4:	a8 e3       	ldi	r26, 0x38	; 56
    59d6:	b0 e0       	ldi	r27, 0x00	; 0
    59d8:	e8 e3       	ldi	r30, 0x38	; 56
    59da:	f0 e0       	ldi	r31, 0x00	; 0
    59dc:	80 81       	ld	r24, Z
    59de:	48 2f       	mov	r20, r24
    59e0:	8a 81       	ldd	r24, Y+2	; 0x02
    59e2:	28 2f       	mov	r18, r24
    59e4:	30 e0       	ldi	r19, 0x00	; 0
    59e6:	81 e0       	ldi	r24, 0x01	; 1
    59e8:	90 e0       	ldi	r25, 0x00	; 0
    59ea:	02 2e       	mov	r0, r18
    59ec:	02 c0       	rjmp	.+4      	; 0x59f2 <GPIO_writePin+0xe4>
    59ee:	88 0f       	add	r24, r24
    59f0:	99 1f       	adc	r25, r25
    59f2:	0a 94       	dec	r0
    59f4:	e2 f7       	brpl	.-8      	; 0x59ee <GPIO_writePin+0xe0>
    59f6:	84 2b       	or	r24, r20
    59f8:	8c 93       	st	X, r24
    59fa:	6c c0       	rjmp	.+216    	; 0x5ad4 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTB,pin_num);
    59fc:	a8 e3       	ldi	r26, 0x38	; 56
    59fe:	b0 e0       	ldi	r27, 0x00	; 0
    5a00:	e8 e3       	ldi	r30, 0x38	; 56
    5a02:	f0 e0       	ldi	r31, 0x00	; 0
    5a04:	80 81       	ld	r24, Z
    5a06:	48 2f       	mov	r20, r24
    5a08:	8a 81       	ldd	r24, Y+2	; 0x02
    5a0a:	28 2f       	mov	r18, r24
    5a0c:	30 e0       	ldi	r19, 0x00	; 0
    5a0e:	81 e0       	ldi	r24, 0x01	; 1
    5a10:	90 e0       	ldi	r25, 0x00	; 0
    5a12:	02 2e       	mov	r0, r18
    5a14:	02 c0       	rjmp	.+4      	; 0x5a1a <GPIO_writePin+0x10c>
    5a16:	88 0f       	add	r24, r24
    5a18:	99 1f       	adc	r25, r25
    5a1a:	0a 94       	dec	r0
    5a1c:	e2 f7       	brpl	.-8      	; 0x5a16 <GPIO_writePin+0x108>
    5a1e:	80 95       	com	r24
    5a20:	84 23       	and	r24, r20
    5a22:	8c 93       	st	X, r24
    5a24:	57 c0       	rjmp	.+174    	; 0x5ad4 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH)
    5a26:	8b 81       	ldd	r24, Y+3	; 0x03
    5a28:	81 30       	cpi	r24, 0x01	; 1
    5a2a:	a1 f4       	brne	.+40     	; 0x5a54 <GPIO_writePin+0x146>
			{
				SET_BIT(PORTC,pin_num);
    5a2c:	a5 e3       	ldi	r26, 0x35	; 53
    5a2e:	b0 e0       	ldi	r27, 0x00	; 0
    5a30:	e5 e3       	ldi	r30, 0x35	; 53
    5a32:	f0 e0       	ldi	r31, 0x00	; 0
    5a34:	80 81       	ld	r24, Z
    5a36:	48 2f       	mov	r20, r24
    5a38:	8a 81       	ldd	r24, Y+2	; 0x02
    5a3a:	28 2f       	mov	r18, r24
    5a3c:	30 e0       	ldi	r19, 0x00	; 0
    5a3e:	81 e0       	ldi	r24, 0x01	; 1
    5a40:	90 e0       	ldi	r25, 0x00	; 0
    5a42:	02 2e       	mov	r0, r18
    5a44:	02 c0       	rjmp	.+4      	; 0x5a4a <GPIO_writePin+0x13c>
    5a46:	88 0f       	add	r24, r24
    5a48:	99 1f       	adc	r25, r25
    5a4a:	0a 94       	dec	r0
    5a4c:	e2 f7       	brpl	.-8      	; 0x5a46 <GPIO_writePin+0x138>
    5a4e:	84 2b       	or	r24, r20
    5a50:	8c 93       	st	X, r24
    5a52:	40 c0       	rjmp	.+128    	; 0x5ad4 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTC,pin_num);
    5a54:	a5 e3       	ldi	r26, 0x35	; 53
    5a56:	b0 e0       	ldi	r27, 0x00	; 0
    5a58:	e5 e3       	ldi	r30, 0x35	; 53
    5a5a:	f0 e0       	ldi	r31, 0x00	; 0
    5a5c:	80 81       	ld	r24, Z
    5a5e:	48 2f       	mov	r20, r24
    5a60:	8a 81       	ldd	r24, Y+2	; 0x02
    5a62:	28 2f       	mov	r18, r24
    5a64:	30 e0       	ldi	r19, 0x00	; 0
    5a66:	81 e0       	ldi	r24, 0x01	; 1
    5a68:	90 e0       	ldi	r25, 0x00	; 0
    5a6a:	02 2e       	mov	r0, r18
    5a6c:	02 c0       	rjmp	.+4      	; 0x5a72 <GPIO_writePin+0x164>
    5a6e:	88 0f       	add	r24, r24
    5a70:	99 1f       	adc	r25, r25
    5a72:	0a 94       	dec	r0
    5a74:	e2 f7       	brpl	.-8      	; 0x5a6e <GPIO_writePin+0x160>
    5a76:	80 95       	com	r24
    5a78:	84 23       	and	r24, r20
    5a7a:	8c 93       	st	X, r24
    5a7c:	2b c0       	rjmp	.+86     	; 0x5ad4 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH)
    5a7e:	8b 81       	ldd	r24, Y+3	; 0x03
    5a80:	81 30       	cpi	r24, 0x01	; 1
    5a82:	a1 f4       	brne	.+40     	; 0x5aac <GPIO_writePin+0x19e>
			{
				SET_BIT(PORTD,pin_num);
    5a84:	a2 e3       	ldi	r26, 0x32	; 50
    5a86:	b0 e0       	ldi	r27, 0x00	; 0
    5a88:	e2 e3       	ldi	r30, 0x32	; 50
    5a8a:	f0 e0       	ldi	r31, 0x00	; 0
    5a8c:	80 81       	ld	r24, Z
    5a8e:	48 2f       	mov	r20, r24
    5a90:	8a 81       	ldd	r24, Y+2	; 0x02
    5a92:	28 2f       	mov	r18, r24
    5a94:	30 e0       	ldi	r19, 0x00	; 0
    5a96:	81 e0       	ldi	r24, 0x01	; 1
    5a98:	90 e0       	ldi	r25, 0x00	; 0
    5a9a:	02 2e       	mov	r0, r18
    5a9c:	02 c0       	rjmp	.+4      	; 0x5aa2 <GPIO_writePin+0x194>
    5a9e:	88 0f       	add	r24, r24
    5aa0:	99 1f       	adc	r25, r25
    5aa2:	0a 94       	dec	r0
    5aa4:	e2 f7       	brpl	.-8      	; 0x5a9e <GPIO_writePin+0x190>
    5aa6:	84 2b       	or	r24, r20
    5aa8:	8c 93       	st	X, r24
    5aaa:	14 c0       	rjmp	.+40     	; 0x5ad4 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTD,pin_num);
    5aac:	a2 e3       	ldi	r26, 0x32	; 50
    5aae:	b0 e0       	ldi	r27, 0x00	; 0
    5ab0:	e2 e3       	ldi	r30, 0x32	; 50
    5ab2:	f0 e0       	ldi	r31, 0x00	; 0
    5ab4:	80 81       	ld	r24, Z
    5ab6:	48 2f       	mov	r20, r24
    5ab8:	8a 81       	ldd	r24, Y+2	; 0x02
    5aba:	28 2f       	mov	r18, r24
    5abc:	30 e0       	ldi	r19, 0x00	; 0
    5abe:	81 e0       	ldi	r24, 0x01	; 1
    5ac0:	90 e0       	ldi	r25, 0x00	; 0
    5ac2:	02 2e       	mov	r0, r18
    5ac4:	02 c0       	rjmp	.+4      	; 0x5aca <GPIO_writePin+0x1bc>
    5ac6:	88 0f       	add	r24, r24
    5ac8:	99 1f       	adc	r25, r25
    5aca:	0a 94       	dec	r0
    5acc:	e2 f7       	brpl	.-8      	; 0x5ac6 <GPIO_writePin+0x1b8>
    5ace:	80 95       	com	r24
    5ad0:	84 23       	and	r24, r20
    5ad2:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    5ad4:	0f 90       	pop	r0
    5ad6:	0f 90       	pop	r0
    5ad8:	0f 90       	pop	r0
    5ada:	0f 90       	pop	r0
    5adc:	0f 90       	pop	r0
    5ade:	cf 91       	pop	r28
    5ae0:	df 91       	pop	r29
    5ae2:	08 95       	ret

00005ae4 <GPIO_readPin>:
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num)
{
    5ae4:	df 93       	push	r29
    5ae6:	cf 93       	push	r28
    5ae8:	00 d0       	rcall	.+0      	; 0x5aea <GPIO_readPin+0x6>
    5aea:	00 d0       	rcall	.+0      	; 0x5aec <GPIO_readPin+0x8>
    5aec:	0f 92       	push	r0
    5aee:	cd b7       	in	r28, 0x3d	; 61
    5af0:	de b7       	in	r29, 0x3e	; 62
    5af2:	8a 83       	std	Y+2, r24	; 0x02
    5af4:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    5af6:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    5af8:	8b 81       	ldd	r24, Y+3	; 0x03
    5afa:	88 30       	cpi	r24, 0x08	; 8
    5afc:	08 f0       	brcs	.+2      	; 0x5b00 <GPIO_readPin+0x1c>
    5afe:	84 c0       	rjmp	.+264    	; 0x5c08 <GPIO_readPin+0x124>
    5b00:	8a 81       	ldd	r24, Y+2	; 0x02
    5b02:	84 30       	cpi	r24, 0x04	; 4
    5b04:	08 f0       	brcs	.+2      	; 0x5b08 <GPIO_readPin+0x24>
    5b06:	80 c0       	rjmp	.+256    	; 0x5c08 <GPIO_readPin+0x124>
		/* Do Nothing */
	}
	else
	{
		/* Read the pin value as required */
		switch(port_num)
    5b08:	8a 81       	ldd	r24, Y+2	; 0x02
    5b0a:	28 2f       	mov	r18, r24
    5b0c:	30 e0       	ldi	r19, 0x00	; 0
    5b0e:	3d 83       	std	Y+5, r19	; 0x05
    5b10:	2c 83       	std	Y+4, r18	; 0x04
    5b12:	4c 81       	ldd	r20, Y+4	; 0x04
    5b14:	5d 81       	ldd	r21, Y+5	; 0x05
    5b16:	41 30       	cpi	r20, 0x01	; 1
    5b18:	51 05       	cpc	r21, r1
    5b1a:	79 f1       	breq	.+94     	; 0x5b7a <GPIO_readPin+0x96>
    5b1c:	8c 81       	ldd	r24, Y+4	; 0x04
    5b1e:	9d 81       	ldd	r25, Y+5	; 0x05
    5b20:	82 30       	cpi	r24, 0x02	; 2
    5b22:	91 05       	cpc	r25, r1
    5b24:	34 f4       	brge	.+12     	; 0x5b32 <GPIO_readPin+0x4e>
    5b26:	2c 81       	ldd	r18, Y+4	; 0x04
    5b28:	3d 81       	ldd	r19, Y+5	; 0x05
    5b2a:	21 15       	cp	r18, r1
    5b2c:	31 05       	cpc	r19, r1
    5b2e:	69 f0       	breq	.+26     	; 0x5b4a <GPIO_readPin+0x66>
    5b30:	6b c0       	rjmp	.+214    	; 0x5c08 <GPIO_readPin+0x124>
    5b32:	4c 81       	ldd	r20, Y+4	; 0x04
    5b34:	5d 81       	ldd	r21, Y+5	; 0x05
    5b36:	42 30       	cpi	r20, 0x02	; 2
    5b38:	51 05       	cpc	r21, r1
    5b3a:	b9 f1       	breq	.+110    	; 0x5baa <GPIO_readPin+0xc6>
    5b3c:	8c 81       	ldd	r24, Y+4	; 0x04
    5b3e:	9d 81       	ldd	r25, Y+5	; 0x05
    5b40:	83 30       	cpi	r24, 0x03	; 3
    5b42:	91 05       	cpc	r25, r1
    5b44:	09 f4       	brne	.+2      	; 0x5b48 <GPIO_readPin+0x64>
    5b46:	49 c0       	rjmp	.+146    	; 0x5bda <GPIO_readPin+0xf6>
    5b48:	5f c0       	rjmp	.+190    	; 0x5c08 <GPIO_readPin+0x124>
		{
		case PORTA_ID:
			if(BIT_IS_SET(PINA,pin_num))
    5b4a:	e9 e3       	ldi	r30, 0x39	; 57
    5b4c:	f0 e0       	ldi	r31, 0x00	; 0
    5b4e:	80 81       	ld	r24, Z
    5b50:	28 2f       	mov	r18, r24
    5b52:	30 e0       	ldi	r19, 0x00	; 0
    5b54:	8b 81       	ldd	r24, Y+3	; 0x03
    5b56:	88 2f       	mov	r24, r24
    5b58:	90 e0       	ldi	r25, 0x00	; 0
    5b5a:	a9 01       	movw	r20, r18
    5b5c:	02 c0       	rjmp	.+4      	; 0x5b62 <GPIO_readPin+0x7e>
    5b5e:	55 95       	asr	r21
    5b60:	47 95       	ror	r20
    5b62:	8a 95       	dec	r24
    5b64:	e2 f7       	brpl	.-8      	; 0x5b5e <GPIO_readPin+0x7a>
    5b66:	ca 01       	movw	r24, r20
    5b68:	81 70       	andi	r24, 0x01	; 1
    5b6a:	90 70       	andi	r25, 0x00	; 0
    5b6c:	88 23       	and	r24, r24
    5b6e:	19 f0       	breq	.+6      	; 0x5b76 <GPIO_readPin+0x92>
			{
				pin_value = LOGIC_HIGH;
    5b70:	81 e0       	ldi	r24, 0x01	; 1
    5b72:	89 83       	std	Y+1, r24	; 0x01
    5b74:	49 c0       	rjmp	.+146    	; 0x5c08 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    5b76:	19 82       	std	Y+1, r1	; 0x01
    5b78:	47 c0       	rjmp	.+142    	; 0x5c08 <GPIO_readPin+0x124>
			}
			break;
		case PORTB_ID:
			if(BIT_IS_SET(PINB,pin_num))
    5b7a:	e6 e3       	ldi	r30, 0x36	; 54
    5b7c:	f0 e0       	ldi	r31, 0x00	; 0
    5b7e:	80 81       	ld	r24, Z
    5b80:	28 2f       	mov	r18, r24
    5b82:	30 e0       	ldi	r19, 0x00	; 0
    5b84:	8b 81       	ldd	r24, Y+3	; 0x03
    5b86:	88 2f       	mov	r24, r24
    5b88:	90 e0       	ldi	r25, 0x00	; 0
    5b8a:	a9 01       	movw	r20, r18
    5b8c:	02 c0       	rjmp	.+4      	; 0x5b92 <GPIO_readPin+0xae>
    5b8e:	55 95       	asr	r21
    5b90:	47 95       	ror	r20
    5b92:	8a 95       	dec	r24
    5b94:	e2 f7       	brpl	.-8      	; 0x5b8e <GPIO_readPin+0xaa>
    5b96:	ca 01       	movw	r24, r20
    5b98:	81 70       	andi	r24, 0x01	; 1
    5b9a:	90 70       	andi	r25, 0x00	; 0
    5b9c:	88 23       	and	r24, r24
    5b9e:	19 f0       	breq	.+6      	; 0x5ba6 <GPIO_readPin+0xc2>
			{
				pin_value = LOGIC_HIGH;
    5ba0:	81 e0       	ldi	r24, 0x01	; 1
    5ba2:	89 83       	std	Y+1, r24	; 0x01
    5ba4:	31 c0       	rjmp	.+98     	; 0x5c08 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    5ba6:	19 82       	std	Y+1, r1	; 0x01
    5ba8:	2f c0       	rjmp	.+94     	; 0x5c08 <GPIO_readPin+0x124>
			}
			break;
		case PORTC_ID:
			if(BIT_IS_SET(PINC,pin_num))
    5baa:	e3 e3       	ldi	r30, 0x33	; 51
    5bac:	f0 e0       	ldi	r31, 0x00	; 0
    5bae:	80 81       	ld	r24, Z
    5bb0:	28 2f       	mov	r18, r24
    5bb2:	30 e0       	ldi	r19, 0x00	; 0
    5bb4:	8b 81       	ldd	r24, Y+3	; 0x03
    5bb6:	88 2f       	mov	r24, r24
    5bb8:	90 e0       	ldi	r25, 0x00	; 0
    5bba:	a9 01       	movw	r20, r18
    5bbc:	02 c0       	rjmp	.+4      	; 0x5bc2 <GPIO_readPin+0xde>
    5bbe:	55 95       	asr	r21
    5bc0:	47 95       	ror	r20
    5bc2:	8a 95       	dec	r24
    5bc4:	e2 f7       	brpl	.-8      	; 0x5bbe <GPIO_readPin+0xda>
    5bc6:	ca 01       	movw	r24, r20
    5bc8:	81 70       	andi	r24, 0x01	; 1
    5bca:	90 70       	andi	r25, 0x00	; 0
    5bcc:	88 23       	and	r24, r24
    5bce:	19 f0       	breq	.+6      	; 0x5bd6 <GPIO_readPin+0xf2>
			{
				pin_value = LOGIC_HIGH;
    5bd0:	81 e0       	ldi	r24, 0x01	; 1
    5bd2:	89 83       	std	Y+1, r24	; 0x01
    5bd4:	19 c0       	rjmp	.+50     	; 0x5c08 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    5bd6:	19 82       	std	Y+1, r1	; 0x01
    5bd8:	17 c0       	rjmp	.+46     	; 0x5c08 <GPIO_readPin+0x124>
			}
			break;
		case PORTD_ID:
			if(BIT_IS_SET(PIND,pin_num))
    5bda:	e0 e3       	ldi	r30, 0x30	; 48
    5bdc:	f0 e0       	ldi	r31, 0x00	; 0
    5bde:	80 81       	ld	r24, Z
    5be0:	28 2f       	mov	r18, r24
    5be2:	30 e0       	ldi	r19, 0x00	; 0
    5be4:	8b 81       	ldd	r24, Y+3	; 0x03
    5be6:	88 2f       	mov	r24, r24
    5be8:	90 e0       	ldi	r25, 0x00	; 0
    5bea:	a9 01       	movw	r20, r18
    5bec:	02 c0       	rjmp	.+4      	; 0x5bf2 <GPIO_readPin+0x10e>
    5bee:	55 95       	asr	r21
    5bf0:	47 95       	ror	r20
    5bf2:	8a 95       	dec	r24
    5bf4:	e2 f7       	brpl	.-8      	; 0x5bee <GPIO_readPin+0x10a>
    5bf6:	ca 01       	movw	r24, r20
    5bf8:	81 70       	andi	r24, 0x01	; 1
    5bfa:	90 70       	andi	r25, 0x00	; 0
    5bfc:	88 23       	and	r24, r24
    5bfe:	19 f0       	breq	.+6      	; 0x5c06 <GPIO_readPin+0x122>
			{
				pin_value = LOGIC_HIGH;
    5c00:	81 e0       	ldi	r24, 0x01	; 1
    5c02:	89 83       	std	Y+1, r24	; 0x01
    5c04:	01 c0       	rjmp	.+2      	; 0x5c08 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    5c06:	19 82       	std	Y+1, r1	; 0x01
			}
			break;
		}
	}

	return pin_value;
    5c08:	89 81       	ldd	r24, Y+1	; 0x01
}
    5c0a:	0f 90       	pop	r0
    5c0c:	0f 90       	pop	r0
    5c0e:	0f 90       	pop	r0
    5c10:	0f 90       	pop	r0
    5c12:	0f 90       	pop	r0
    5c14:	cf 91       	pop	r28
    5c16:	df 91       	pop	r29
    5c18:	08 95       	ret

00005c1a <GPIO_setupPortDirection>:
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction)
{
    5c1a:	df 93       	push	r29
    5c1c:	cf 93       	push	r28
    5c1e:	00 d0       	rcall	.+0      	; 0x5c20 <GPIO_setupPortDirection+0x6>
    5c20:	00 d0       	rcall	.+0      	; 0x5c22 <GPIO_setupPortDirection+0x8>
    5c22:	cd b7       	in	r28, 0x3d	; 61
    5c24:	de b7       	in	r29, 0x3e	; 62
    5c26:	89 83       	std	Y+1, r24	; 0x01
    5c28:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    5c2a:	89 81       	ldd	r24, Y+1	; 0x01
    5c2c:	84 30       	cpi	r24, 0x04	; 4
    5c2e:	90 f5       	brcc	.+100    	; 0x5c94 <GPIO_setupPortDirection+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Setup the port direction as required */
		switch(port_num)
    5c30:	89 81       	ldd	r24, Y+1	; 0x01
    5c32:	28 2f       	mov	r18, r24
    5c34:	30 e0       	ldi	r19, 0x00	; 0
    5c36:	3c 83       	std	Y+4, r19	; 0x04
    5c38:	2b 83       	std	Y+3, r18	; 0x03
    5c3a:	8b 81       	ldd	r24, Y+3	; 0x03
    5c3c:	9c 81       	ldd	r25, Y+4	; 0x04
    5c3e:	81 30       	cpi	r24, 0x01	; 1
    5c40:	91 05       	cpc	r25, r1
    5c42:	d1 f0       	breq	.+52     	; 0x5c78 <GPIO_setupPortDirection+0x5e>
    5c44:	2b 81       	ldd	r18, Y+3	; 0x03
    5c46:	3c 81       	ldd	r19, Y+4	; 0x04
    5c48:	22 30       	cpi	r18, 0x02	; 2
    5c4a:	31 05       	cpc	r19, r1
    5c4c:	2c f4       	brge	.+10     	; 0x5c58 <GPIO_setupPortDirection+0x3e>
    5c4e:	8b 81       	ldd	r24, Y+3	; 0x03
    5c50:	9c 81       	ldd	r25, Y+4	; 0x04
    5c52:	00 97       	sbiw	r24, 0x00	; 0
    5c54:	61 f0       	breq	.+24     	; 0x5c6e <GPIO_setupPortDirection+0x54>
    5c56:	1e c0       	rjmp	.+60     	; 0x5c94 <GPIO_setupPortDirection+0x7a>
    5c58:	2b 81       	ldd	r18, Y+3	; 0x03
    5c5a:	3c 81       	ldd	r19, Y+4	; 0x04
    5c5c:	22 30       	cpi	r18, 0x02	; 2
    5c5e:	31 05       	cpc	r19, r1
    5c60:	81 f0       	breq	.+32     	; 0x5c82 <GPIO_setupPortDirection+0x68>
    5c62:	8b 81       	ldd	r24, Y+3	; 0x03
    5c64:	9c 81       	ldd	r25, Y+4	; 0x04
    5c66:	83 30       	cpi	r24, 0x03	; 3
    5c68:	91 05       	cpc	r25, r1
    5c6a:	81 f0       	breq	.+32     	; 0x5c8c <GPIO_setupPortDirection+0x72>
    5c6c:	13 c0       	rjmp	.+38     	; 0x5c94 <GPIO_setupPortDirection+0x7a>
		{
		case PORTA_ID:
			DDRA = direction;
    5c6e:	ea e3       	ldi	r30, 0x3A	; 58
    5c70:	f0 e0       	ldi	r31, 0x00	; 0
    5c72:	8a 81       	ldd	r24, Y+2	; 0x02
    5c74:	80 83       	st	Z, r24
    5c76:	0e c0       	rjmp	.+28     	; 0x5c94 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
    5c78:	e7 e3       	ldi	r30, 0x37	; 55
    5c7a:	f0 e0       	ldi	r31, 0x00	; 0
    5c7c:	8a 81       	ldd	r24, Y+2	; 0x02
    5c7e:	80 83       	st	Z, r24
    5c80:	09 c0       	rjmp	.+18     	; 0x5c94 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    5c82:	e4 e3       	ldi	r30, 0x34	; 52
    5c84:	f0 e0       	ldi	r31, 0x00	; 0
    5c86:	8a 81       	ldd	r24, Y+2	; 0x02
    5c88:	80 83       	st	Z, r24
    5c8a:	04 c0       	rjmp	.+8      	; 0x5c94 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
    5c8c:	e1 e3       	ldi	r30, 0x31	; 49
    5c8e:	f0 e0       	ldi	r31, 0x00	; 0
    5c90:	8a 81       	ldd	r24, Y+2	; 0x02
    5c92:	80 83       	st	Z, r24
			break;
		}
	}
}
    5c94:	0f 90       	pop	r0
    5c96:	0f 90       	pop	r0
    5c98:	0f 90       	pop	r0
    5c9a:	0f 90       	pop	r0
    5c9c:	cf 91       	pop	r28
    5c9e:	df 91       	pop	r29
    5ca0:	08 95       	ret

00005ca2 <GPIO_writePort>:
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value)
{
    5ca2:	df 93       	push	r29
    5ca4:	cf 93       	push	r28
    5ca6:	00 d0       	rcall	.+0      	; 0x5ca8 <GPIO_writePort+0x6>
    5ca8:	00 d0       	rcall	.+0      	; 0x5caa <GPIO_writePort+0x8>
    5caa:	cd b7       	in	r28, 0x3d	; 61
    5cac:	de b7       	in	r29, 0x3e	; 62
    5cae:	89 83       	std	Y+1, r24	; 0x01
    5cb0:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    5cb2:	89 81       	ldd	r24, Y+1	; 0x01
    5cb4:	84 30       	cpi	r24, 0x04	; 4
    5cb6:	90 f5       	brcc	.+100    	; 0x5d1c <GPIO_writePort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Write the port value as required */
		switch(port_num)
    5cb8:	89 81       	ldd	r24, Y+1	; 0x01
    5cba:	28 2f       	mov	r18, r24
    5cbc:	30 e0       	ldi	r19, 0x00	; 0
    5cbe:	3c 83       	std	Y+4, r19	; 0x04
    5cc0:	2b 83       	std	Y+3, r18	; 0x03
    5cc2:	8b 81       	ldd	r24, Y+3	; 0x03
    5cc4:	9c 81       	ldd	r25, Y+4	; 0x04
    5cc6:	81 30       	cpi	r24, 0x01	; 1
    5cc8:	91 05       	cpc	r25, r1
    5cca:	d1 f0       	breq	.+52     	; 0x5d00 <GPIO_writePort+0x5e>
    5ccc:	2b 81       	ldd	r18, Y+3	; 0x03
    5cce:	3c 81       	ldd	r19, Y+4	; 0x04
    5cd0:	22 30       	cpi	r18, 0x02	; 2
    5cd2:	31 05       	cpc	r19, r1
    5cd4:	2c f4       	brge	.+10     	; 0x5ce0 <GPIO_writePort+0x3e>
    5cd6:	8b 81       	ldd	r24, Y+3	; 0x03
    5cd8:	9c 81       	ldd	r25, Y+4	; 0x04
    5cda:	00 97       	sbiw	r24, 0x00	; 0
    5cdc:	61 f0       	breq	.+24     	; 0x5cf6 <GPIO_writePort+0x54>
    5cde:	1e c0       	rjmp	.+60     	; 0x5d1c <GPIO_writePort+0x7a>
    5ce0:	2b 81       	ldd	r18, Y+3	; 0x03
    5ce2:	3c 81       	ldd	r19, Y+4	; 0x04
    5ce4:	22 30       	cpi	r18, 0x02	; 2
    5ce6:	31 05       	cpc	r19, r1
    5ce8:	81 f0       	breq	.+32     	; 0x5d0a <GPIO_writePort+0x68>
    5cea:	8b 81       	ldd	r24, Y+3	; 0x03
    5cec:	9c 81       	ldd	r25, Y+4	; 0x04
    5cee:	83 30       	cpi	r24, 0x03	; 3
    5cf0:	91 05       	cpc	r25, r1
    5cf2:	81 f0       	breq	.+32     	; 0x5d14 <GPIO_writePort+0x72>
    5cf4:	13 c0       	rjmp	.+38     	; 0x5d1c <GPIO_writePort+0x7a>
		{
		case PORTA_ID:
			PORTA = value;
    5cf6:	eb e3       	ldi	r30, 0x3B	; 59
    5cf8:	f0 e0       	ldi	r31, 0x00	; 0
    5cfa:	8a 81       	ldd	r24, Y+2	; 0x02
    5cfc:	80 83       	st	Z, r24
    5cfe:	0e c0       	rjmp	.+28     	; 0x5d1c <GPIO_writePort+0x7a>
			break;
		case PORTB_ID:
			PORTB = value;
    5d00:	e8 e3       	ldi	r30, 0x38	; 56
    5d02:	f0 e0       	ldi	r31, 0x00	; 0
    5d04:	8a 81       	ldd	r24, Y+2	; 0x02
    5d06:	80 83       	st	Z, r24
    5d08:	09 c0       	rjmp	.+18     	; 0x5d1c <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
    5d0a:	e5 e3       	ldi	r30, 0x35	; 53
    5d0c:	f0 e0       	ldi	r31, 0x00	; 0
    5d0e:	8a 81       	ldd	r24, Y+2	; 0x02
    5d10:	80 83       	st	Z, r24
    5d12:	04 c0       	rjmp	.+8      	; 0x5d1c <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
    5d14:	e2 e3       	ldi	r30, 0x32	; 50
    5d16:	f0 e0       	ldi	r31, 0x00	; 0
    5d18:	8a 81       	ldd	r24, Y+2	; 0x02
    5d1a:	80 83       	st	Z, r24
			break;
		}
	}
}
    5d1c:	0f 90       	pop	r0
    5d1e:	0f 90       	pop	r0
    5d20:	0f 90       	pop	r0
    5d22:	0f 90       	pop	r0
    5d24:	cf 91       	pop	r28
    5d26:	df 91       	pop	r29
    5d28:	08 95       	ret

00005d2a <GPIO_readPort>:
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num)
{
    5d2a:	df 93       	push	r29
    5d2c:	cf 93       	push	r28
    5d2e:	00 d0       	rcall	.+0      	; 0x5d30 <GPIO_readPort+0x6>
    5d30:	00 d0       	rcall	.+0      	; 0x5d32 <GPIO_readPort+0x8>
    5d32:	cd b7       	in	r28, 0x3d	; 61
    5d34:	de b7       	in	r29, 0x3e	; 62
    5d36:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    5d38:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    5d3a:	8a 81       	ldd	r24, Y+2	; 0x02
    5d3c:	84 30       	cpi	r24, 0x04	; 4
    5d3e:	90 f5       	brcc	.+100    	; 0x5da4 <GPIO_readPort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Read the port value as required */
		switch(port_num)
    5d40:	8a 81       	ldd	r24, Y+2	; 0x02
    5d42:	28 2f       	mov	r18, r24
    5d44:	30 e0       	ldi	r19, 0x00	; 0
    5d46:	3c 83       	std	Y+4, r19	; 0x04
    5d48:	2b 83       	std	Y+3, r18	; 0x03
    5d4a:	8b 81       	ldd	r24, Y+3	; 0x03
    5d4c:	9c 81       	ldd	r25, Y+4	; 0x04
    5d4e:	81 30       	cpi	r24, 0x01	; 1
    5d50:	91 05       	cpc	r25, r1
    5d52:	d1 f0       	breq	.+52     	; 0x5d88 <GPIO_readPort+0x5e>
    5d54:	2b 81       	ldd	r18, Y+3	; 0x03
    5d56:	3c 81       	ldd	r19, Y+4	; 0x04
    5d58:	22 30       	cpi	r18, 0x02	; 2
    5d5a:	31 05       	cpc	r19, r1
    5d5c:	2c f4       	brge	.+10     	; 0x5d68 <GPIO_readPort+0x3e>
    5d5e:	8b 81       	ldd	r24, Y+3	; 0x03
    5d60:	9c 81       	ldd	r25, Y+4	; 0x04
    5d62:	00 97       	sbiw	r24, 0x00	; 0
    5d64:	61 f0       	breq	.+24     	; 0x5d7e <GPIO_readPort+0x54>
    5d66:	1e c0       	rjmp	.+60     	; 0x5da4 <GPIO_readPort+0x7a>
    5d68:	2b 81       	ldd	r18, Y+3	; 0x03
    5d6a:	3c 81       	ldd	r19, Y+4	; 0x04
    5d6c:	22 30       	cpi	r18, 0x02	; 2
    5d6e:	31 05       	cpc	r19, r1
    5d70:	81 f0       	breq	.+32     	; 0x5d92 <GPIO_readPort+0x68>
    5d72:	8b 81       	ldd	r24, Y+3	; 0x03
    5d74:	9c 81       	ldd	r25, Y+4	; 0x04
    5d76:	83 30       	cpi	r24, 0x03	; 3
    5d78:	91 05       	cpc	r25, r1
    5d7a:	81 f0       	breq	.+32     	; 0x5d9c <GPIO_readPort+0x72>
    5d7c:	13 c0       	rjmp	.+38     	; 0x5da4 <GPIO_readPort+0x7a>
		{
		case PORTA_ID:
			value = PINA;
    5d7e:	e9 e3       	ldi	r30, 0x39	; 57
    5d80:	f0 e0       	ldi	r31, 0x00	; 0
    5d82:	80 81       	ld	r24, Z
    5d84:	89 83       	std	Y+1, r24	; 0x01
    5d86:	0e c0       	rjmp	.+28     	; 0x5da4 <GPIO_readPort+0x7a>
			break;
		case PORTB_ID:
			value = PINB;
    5d88:	e6 e3       	ldi	r30, 0x36	; 54
    5d8a:	f0 e0       	ldi	r31, 0x00	; 0
    5d8c:	80 81       	ld	r24, Z
    5d8e:	89 83       	std	Y+1, r24	; 0x01
    5d90:	09 c0       	rjmp	.+18     	; 0x5da4 <GPIO_readPort+0x7a>
			break;
		case PORTC_ID:
			value = PINC;
    5d92:	e3 e3       	ldi	r30, 0x33	; 51
    5d94:	f0 e0       	ldi	r31, 0x00	; 0
    5d96:	80 81       	ld	r24, Z
    5d98:	89 83       	std	Y+1, r24	; 0x01
    5d9a:	04 c0       	rjmp	.+8      	; 0x5da4 <GPIO_readPort+0x7a>
			break;
		case PORTD_ID:
			value = PIND;
    5d9c:	e0 e3       	ldi	r30, 0x30	; 48
    5d9e:	f0 e0       	ldi	r31, 0x00	; 0
    5da0:	80 81       	ld	r24, Z
    5da2:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}

	return value;
    5da4:	89 81       	ldd	r24, Y+1	; 0x01
}
    5da6:	0f 90       	pop	r0
    5da8:	0f 90       	pop	r0
    5daa:	0f 90       	pop	r0
    5dac:	0f 90       	pop	r0
    5dae:	cf 91       	pop	r28
    5db0:	df 91       	pop	r29
    5db2:	08 95       	ret

00005db4 <LCD_init>:
 * Initialize the LCD:
 * 1. Setup the LCD pins directions by use the GPIO driver.
 * 2. Setup the LCD Data Mode 4-bits or 8-bits.
 */
void LCD_init(void)
{
    5db4:	df 93       	push	r29
    5db6:	cf 93       	push	r28
    5db8:	cd b7       	in	r28, 0x3d	; 61
    5dba:	de b7       	in	r29, 0x3e	; 62
    5dbc:	2e 97       	sbiw	r28, 0x0e	; 14
    5dbe:	0f b6       	in	r0, 0x3f	; 63
    5dc0:	f8 94       	cli
    5dc2:	de bf       	out	0x3e, r29	; 62
    5dc4:	0f be       	out	0x3f, r0	; 63
    5dc6:	cd bf       	out	0x3d, r28	; 61
	/* Configure the direction for RS and E pins as output pins */
	GPIO_setupPinDirection(LCD_RS_PORT_ID,LCD_RS_PIN_ID,PIN_OUTPUT);
    5dc8:	81 e0       	ldi	r24, 0x01	; 1
    5dca:	67 e0       	ldi	r22, 0x07	; 7
    5dcc:	41 e0       	ldi	r20, 0x01	; 1
    5dce:	0e 94 9c 2b 	call	0x5738	; 0x5738 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_E_PORT_ID,LCD_E_PIN_ID,PIN_OUTPUT);
    5dd2:	81 e0       	ldi	r24, 0x01	; 1
    5dd4:	66 e0       	ldi	r22, 0x06	; 6
    5dd6:	41 e0       	ldi	r20, 0x01	; 1
    5dd8:	0e 94 9c 2b 	call	0x5738	; 0x5738 <GPIO_setupPinDirection>
    5ddc:	80 e0       	ldi	r24, 0x00	; 0
    5dde:	90 e0       	ldi	r25, 0x00	; 0
    5de0:	a0 ea       	ldi	r26, 0xA0	; 160
    5de2:	b1 e4       	ldi	r27, 0x41	; 65
    5de4:	8b 87       	std	Y+11, r24	; 0x0b
    5de6:	9c 87       	std	Y+12, r25	; 0x0c
    5de8:	ad 87       	std	Y+13, r26	; 0x0d
    5dea:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5dec:	6b 85       	ldd	r22, Y+11	; 0x0b
    5dee:	7c 85       	ldd	r23, Y+12	; 0x0c
    5df0:	8d 85       	ldd	r24, Y+13	; 0x0d
    5df2:	9e 85       	ldd	r25, Y+14	; 0x0e
    5df4:	20 e0       	ldi	r18, 0x00	; 0
    5df6:	30 e0       	ldi	r19, 0x00	; 0
    5df8:	4a e7       	ldi	r20, 0x7A	; 122
    5dfa:	53 e4       	ldi	r21, 0x43	; 67
    5dfc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5e00:	dc 01       	movw	r26, r24
    5e02:	cb 01       	movw	r24, r22
    5e04:	8f 83       	std	Y+7, r24	; 0x07
    5e06:	98 87       	std	Y+8, r25	; 0x08
    5e08:	a9 87       	std	Y+9, r26	; 0x09
    5e0a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5e0c:	6f 81       	ldd	r22, Y+7	; 0x07
    5e0e:	78 85       	ldd	r23, Y+8	; 0x08
    5e10:	89 85       	ldd	r24, Y+9	; 0x09
    5e12:	9a 85       	ldd	r25, Y+10	; 0x0a
    5e14:	20 e0       	ldi	r18, 0x00	; 0
    5e16:	30 e0       	ldi	r19, 0x00	; 0
    5e18:	40 e8       	ldi	r20, 0x80	; 128
    5e1a:	5f e3       	ldi	r21, 0x3F	; 63
    5e1c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5e20:	88 23       	and	r24, r24
    5e22:	2c f4       	brge	.+10     	; 0x5e2e <LCD_init+0x7a>
		__ticks = 1;
    5e24:	81 e0       	ldi	r24, 0x01	; 1
    5e26:	90 e0       	ldi	r25, 0x00	; 0
    5e28:	9e 83       	std	Y+6, r25	; 0x06
    5e2a:	8d 83       	std	Y+5, r24	; 0x05
    5e2c:	3f c0       	rjmp	.+126    	; 0x5eac <LCD_init+0xf8>
	else if (__tmp > 65535)
    5e2e:	6f 81       	ldd	r22, Y+7	; 0x07
    5e30:	78 85       	ldd	r23, Y+8	; 0x08
    5e32:	89 85       	ldd	r24, Y+9	; 0x09
    5e34:	9a 85       	ldd	r25, Y+10	; 0x0a
    5e36:	20 e0       	ldi	r18, 0x00	; 0
    5e38:	3f ef       	ldi	r19, 0xFF	; 255
    5e3a:	4f e7       	ldi	r20, 0x7F	; 127
    5e3c:	57 e4       	ldi	r21, 0x47	; 71
    5e3e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5e42:	18 16       	cp	r1, r24
    5e44:	4c f5       	brge	.+82     	; 0x5e98 <LCD_init+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5e46:	6b 85       	ldd	r22, Y+11	; 0x0b
    5e48:	7c 85       	ldd	r23, Y+12	; 0x0c
    5e4a:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e4c:	9e 85       	ldd	r25, Y+14	; 0x0e
    5e4e:	20 e0       	ldi	r18, 0x00	; 0
    5e50:	30 e0       	ldi	r19, 0x00	; 0
    5e52:	40 e2       	ldi	r20, 0x20	; 32
    5e54:	51 e4       	ldi	r21, 0x41	; 65
    5e56:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5e5a:	dc 01       	movw	r26, r24
    5e5c:	cb 01       	movw	r24, r22
    5e5e:	bc 01       	movw	r22, r24
    5e60:	cd 01       	movw	r24, r26
    5e62:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5e66:	dc 01       	movw	r26, r24
    5e68:	cb 01       	movw	r24, r22
    5e6a:	9e 83       	std	Y+6, r25	; 0x06
    5e6c:	8d 83       	std	Y+5, r24	; 0x05
    5e6e:	0f c0       	rjmp	.+30     	; 0x5e8e <LCD_init+0xda>
    5e70:	89 e1       	ldi	r24, 0x19	; 25
    5e72:	90 e0       	ldi	r25, 0x00	; 0
    5e74:	9c 83       	std	Y+4, r25	; 0x04
    5e76:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5e78:	8b 81       	ldd	r24, Y+3	; 0x03
    5e7a:	9c 81       	ldd	r25, Y+4	; 0x04
    5e7c:	01 97       	sbiw	r24, 0x01	; 1
    5e7e:	f1 f7       	brne	.-4      	; 0x5e7c <LCD_init+0xc8>
    5e80:	9c 83       	std	Y+4, r25	; 0x04
    5e82:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5e84:	8d 81       	ldd	r24, Y+5	; 0x05
    5e86:	9e 81       	ldd	r25, Y+6	; 0x06
    5e88:	01 97       	sbiw	r24, 0x01	; 1
    5e8a:	9e 83       	std	Y+6, r25	; 0x06
    5e8c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5e8e:	8d 81       	ldd	r24, Y+5	; 0x05
    5e90:	9e 81       	ldd	r25, Y+6	; 0x06
    5e92:	00 97       	sbiw	r24, 0x00	; 0
    5e94:	69 f7       	brne	.-38     	; 0x5e70 <LCD_init+0xbc>
    5e96:	14 c0       	rjmp	.+40     	; 0x5ec0 <LCD_init+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5e98:	6f 81       	ldd	r22, Y+7	; 0x07
    5e9a:	78 85       	ldd	r23, Y+8	; 0x08
    5e9c:	89 85       	ldd	r24, Y+9	; 0x09
    5e9e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5ea0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5ea4:	dc 01       	movw	r26, r24
    5ea6:	cb 01       	movw	r24, r22
    5ea8:	9e 83       	std	Y+6, r25	; 0x06
    5eaa:	8d 83       	std	Y+5, r24	; 0x05
    5eac:	8d 81       	ldd	r24, Y+5	; 0x05
    5eae:	9e 81       	ldd	r25, Y+6	; 0x06
    5eb0:	9a 83       	std	Y+2, r25	; 0x02
    5eb2:	89 83       	std	Y+1, r24	; 0x01
    5eb4:	89 81       	ldd	r24, Y+1	; 0x01
    5eb6:	9a 81       	ldd	r25, Y+2	; 0x02
    5eb8:	01 97       	sbiw	r24, 0x01	; 1
    5eba:	f1 f7       	brne	.-4      	; 0x5eb8 <LCD_init+0x104>
    5ebc:	9a 83       	std	Y+2, r25	; 0x02
    5ebe:	89 83       	std	Y+1, r24	; 0x01
	/* use 2-lines LCD + 4-bits Data Mode + 5*7 dot display Mode */
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE);

#elif(LCD_DATA_BITS_MODE == 8)
	/* Configure the data port as output port */
	GPIO_setupPortDirection(LCD_DATA_PORT_ID,PORT_OUTPUT);
    5ec0:	83 e0       	ldi	r24, 0x03	; 3
    5ec2:	6f ef       	ldi	r22, 0xFF	; 255
    5ec4:	0e 94 0d 2e 	call	0x5c1a	; 0x5c1a <GPIO_setupPortDirection>

	/* use 2-lines LCD + 8-bits Data Mode + 5*7 dot display Mode */
	LCD_sendCommand(LCD_TWO_LINES_EIGHT_BITS_MODE);
    5ec8:	88 e3       	ldi	r24, 0x38	; 56
    5eca:	0e 94 76 2f 	call	0x5eec	; 0x5eec <LCD_sendCommand>

#endif

	LCD_sendCommand(LCD_CURSOR_OFF); /* cursor off */
    5ece:	8c e0       	ldi	r24, 0x0C	; 12
    5ed0:	0e 94 76 2f 	call	0x5eec	; 0x5eec <LCD_sendCommand>
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* clear LCD at the beginning */
    5ed4:	81 e0       	ldi	r24, 0x01	; 1
    5ed6:	0e 94 76 2f 	call	0x5eec	; 0x5eec <LCD_sendCommand>
}
    5eda:	2e 96       	adiw	r28, 0x0e	; 14
    5edc:	0f b6       	in	r0, 0x3f	; 63
    5ede:	f8 94       	cli
    5ee0:	de bf       	out	0x3e, r29	; 62
    5ee2:	0f be       	out	0x3f, r0	; 63
    5ee4:	cd bf       	out	0x3d, r28	; 61
    5ee6:	cf 91       	pop	r28
    5ee8:	df 91       	pop	r29
    5eea:	08 95       	ret

00005eec <LCD_sendCommand>:
/*
 * Description :
 * Send the required command to the screen
 */
void LCD_sendCommand(uint8 command)
{
    5eec:	df 93       	push	r29
    5eee:	cf 93       	push	r28
    5ef0:	cd b7       	in	r28, 0x3d	; 61
    5ef2:	de b7       	in	r29, 0x3e	; 62
    5ef4:	e9 97       	sbiw	r28, 0x39	; 57
    5ef6:	0f b6       	in	r0, 0x3f	; 63
    5ef8:	f8 94       	cli
    5efa:	de bf       	out	0x3e, r29	; 62
    5efc:	0f be       	out	0x3f, r0	; 63
    5efe:	cd bf       	out	0x3d, r28	; 61
    5f00:	89 af       	std	Y+57, r24	; 0x39
	GPIO_writePin(LCD_RS_PORT_ID,LCD_RS_PIN_ID,LOGIC_LOW); /* Instruction Mode RS=0 */
    5f02:	81 e0       	ldi	r24, 0x01	; 1
    5f04:	67 e0       	ldi	r22, 0x07	; 7
    5f06:	40 e0       	ldi	r20, 0x00	; 0
    5f08:	0e 94 87 2c 	call	0x590e	; 0x590e <GPIO_writePin>
    5f0c:	80 e0       	ldi	r24, 0x00	; 0
    5f0e:	90 e0       	ldi	r25, 0x00	; 0
    5f10:	a0 e8       	ldi	r26, 0x80	; 128
    5f12:	bf e3       	ldi	r27, 0x3F	; 63
    5f14:	8d ab       	std	Y+53, r24	; 0x35
    5f16:	9e ab       	std	Y+54, r25	; 0x36
    5f18:	af ab       	std	Y+55, r26	; 0x37
    5f1a:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5f1c:	6d a9       	ldd	r22, Y+53	; 0x35
    5f1e:	7e a9       	ldd	r23, Y+54	; 0x36
    5f20:	8f a9       	ldd	r24, Y+55	; 0x37
    5f22:	98 ad       	ldd	r25, Y+56	; 0x38
    5f24:	20 e0       	ldi	r18, 0x00	; 0
    5f26:	30 e0       	ldi	r19, 0x00	; 0
    5f28:	4a e7       	ldi	r20, 0x7A	; 122
    5f2a:	53 e4       	ldi	r21, 0x43	; 67
    5f2c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5f30:	dc 01       	movw	r26, r24
    5f32:	cb 01       	movw	r24, r22
    5f34:	89 ab       	std	Y+49, r24	; 0x31
    5f36:	9a ab       	std	Y+50, r25	; 0x32
    5f38:	ab ab       	std	Y+51, r26	; 0x33
    5f3a:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    5f3c:	69 a9       	ldd	r22, Y+49	; 0x31
    5f3e:	7a a9       	ldd	r23, Y+50	; 0x32
    5f40:	8b a9       	ldd	r24, Y+51	; 0x33
    5f42:	9c a9       	ldd	r25, Y+52	; 0x34
    5f44:	20 e0       	ldi	r18, 0x00	; 0
    5f46:	30 e0       	ldi	r19, 0x00	; 0
    5f48:	40 e8       	ldi	r20, 0x80	; 128
    5f4a:	5f e3       	ldi	r21, 0x3F	; 63
    5f4c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5f50:	88 23       	and	r24, r24
    5f52:	2c f4       	brge	.+10     	; 0x5f5e <LCD_sendCommand+0x72>
		__ticks = 1;
    5f54:	81 e0       	ldi	r24, 0x01	; 1
    5f56:	90 e0       	ldi	r25, 0x00	; 0
    5f58:	98 ab       	std	Y+48, r25	; 0x30
    5f5a:	8f a7       	std	Y+47, r24	; 0x2f
    5f5c:	3f c0       	rjmp	.+126    	; 0x5fdc <LCD_sendCommand+0xf0>
	else if (__tmp > 65535)
    5f5e:	69 a9       	ldd	r22, Y+49	; 0x31
    5f60:	7a a9       	ldd	r23, Y+50	; 0x32
    5f62:	8b a9       	ldd	r24, Y+51	; 0x33
    5f64:	9c a9       	ldd	r25, Y+52	; 0x34
    5f66:	20 e0       	ldi	r18, 0x00	; 0
    5f68:	3f ef       	ldi	r19, 0xFF	; 255
    5f6a:	4f e7       	ldi	r20, 0x7F	; 127
    5f6c:	57 e4       	ldi	r21, 0x47	; 71
    5f6e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5f72:	18 16       	cp	r1, r24
    5f74:	4c f5       	brge	.+82     	; 0x5fc8 <LCD_sendCommand+0xdc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5f76:	6d a9       	ldd	r22, Y+53	; 0x35
    5f78:	7e a9       	ldd	r23, Y+54	; 0x36
    5f7a:	8f a9       	ldd	r24, Y+55	; 0x37
    5f7c:	98 ad       	ldd	r25, Y+56	; 0x38
    5f7e:	20 e0       	ldi	r18, 0x00	; 0
    5f80:	30 e0       	ldi	r19, 0x00	; 0
    5f82:	40 e2       	ldi	r20, 0x20	; 32
    5f84:	51 e4       	ldi	r21, 0x41	; 65
    5f86:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5f8a:	dc 01       	movw	r26, r24
    5f8c:	cb 01       	movw	r24, r22
    5f8e:	bc 01       	movw	r22, r24
    5f90:	cd 01       	movw	r24, r26
    5f92:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5f96:	dc 01       	movw	r26, r24
    5f98:	cb 01       	movw	r24, r22
    5f9a:	98 ab       	std	Y+48, r25	; 0x30
    5f9c:	8f a7       	std	Y+47, r24	; 0x2f
    5f9e:	0f c0       	rjmp	.+30     	; 0x5fbe <LCD_sendCommand+0xd2>
    5fa0:	89 e1       	ldi	r24, 0x19	; 25
    5fa2:	90 e0       	ldi	r25, 0x00	; 0
    5fa4:	9e a7       	std	Y+46, r25	; 0x2e
    5fa6:	8d a7       	std	Y+45, r24	; 0x2d
    5fa8:	8d a5       	ldd	r24, Y+45	; 0x2d
    5faa:	9e a5       	ldd	r25, Y+46	; 0x2e
    5fac:	01 97       	sbiw	r24, 0x01	; 1
    5fae:	f1 f7       	brne	.-4      	; 0x5fac <LCD_sendCommand+0xc0>
    5fb0:	9e a7       	std	Y+46, r25	; 0x2e
    5fb2:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5fb4:	8f a5       	ldd	r24, Y+47	; 0x2f
    5fb6:	98 a9       	ldd	r25, Y+48	; 0x30
    5fb8:	01 97       	sbiw	r24, 0x01	; 1
    5fba:	98 ab       	std	Y+48, r25	; 0x30
    5fbc:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5fbe:	8f a5       	ldd	r24, Y+47	; 0x2f
    5fc0:	98 a9       	ldd	r25, Y+48	; 0x30
    5fc2:	00 97       	sbiw	r24, 0x00	; 0
    5fc4:	69 f7       	brne	.-38     	; 0x5fa0 <LCD_sendCommand+0xb4>
    5fc6:	14 c0       	rjmp	.+40     	; 0x5ff0 <LCD_sendCommand+0x104>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5fc8:	69 a9       	ldd	r22, Y+49	; 0x31
    5fca:	7a a9       	ldd	r23, Y+50	; 0x32
    5fcc:	8b a9       	ldd	r24, Y+51	; 0x33
    5fce:	9c a9       	ldd	r25, Y+52	; 0x34
    5fd0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5fd4:	dc 01       	movw	r26, r24
    5fd6:	cb 01       	movw	r24, r22
    5fd8:	98 ab       	std	Y+48, r25	; 0x30
    5fda:	8f a7       	std	Y+47, r24	; 0x2f
    5fdc:	8f a5       	ldd	r24, Y+47	; 0x2f
    5fde:	98 a9       	ldd	r25, Y+48	; 0x30
    5fe0:	9c a7       	std	Y+44, r25	; 0x2c
    5fe2:	8b a7       	std	Y+43, r24	; 0x2b
    5fe4:	8b a5       	ldd	r24, Y+43	; 0x2b
    5fe6:	9c a5       	ldd	r25, Y+44	; 0x2c
    5fe8:	01 97       	sbiw	r24, 0x01	; 1
    5fea:	f1 f7       	brne	.-4      	; 0x5fe8 <LCD_sendCommand+0xfc>
    5fec:	9c a7       	std	Y+44, r25	; 0x2c
    5fee:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Tas = 50ns */


	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    5ff0:	81 e0       	ldi	r24, 0x01	; 1
    5ff2:	66 e0       	ldi	r22, 0x06	; 6
    5ff4:	41 e0       	ldi	r20, 0x01	; 1
    5ff6:	0e 94 87 2c 	call	0x590e	; 0x590e <GPIO_writePin>
    5ffa:	80 e0       	ldi	r24, 0x00	; 0
    5ffc:	90 e0       	ldi	r25, 0x00	; 0
    5ffe:	a0 e8       	ldi	r26, 0x80	; 128
    6000:	bf e3       	ldi	r27, 0x3F	; 63
    6002:	8f a3       	std	Y+39, r24	; 0x27
    6004:	98 a7       	std	Y+40, r25	; 0x28
    6006:	a9 a7       	std	Y+41, r26	; 0x29
    6008:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    600a:	6f a1       	ldd	r22, Y+39	; 0x27
    600c:	78 a5       	ldd	r23, Y+40	; 0x28
    600e:	89 a5       	ldd	r24, Y+41	; 0x29
    6010:	9a a5       	ldd	r25, Y+42	; 0x2a
    6012:	20 e0       	ldi	r18, 0x00	; 0
    6014:	30 e0       	ldi	r19, 0x00	; 0
    6016:	4a e7       	ldi	r20, 0x7A	; 122
    6018:	53 e4       	ldi	r21, 0x43	; 67
    601a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    601e:	dc 01       	movw	r26, r24
    6020:	cb 01       	movw	r24, r22
    6022:	8b a3       	std	Y+35, r24	; 0x23
    6024:	9c a3       	std	Y+36, r25	; 0x24
    6026:	ad a3       	std	Y+37, r26	; 0x25
    6028:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    602a:	6b a1       	ldd	r22, Y+35	; 0x23
    602c:	7c a1       	ldd	r23, Y+36	; 0x24
    602e:	8d a1       	ldd	r24, Y+37	; 0x25
    6030:	9e a1       	ldd	r25, Y+38	; 0x26
    6032:	20 e0       	ldi	r18, 0x00	; 0
    6034:	30 e0       	ldi	r19, 0x00	; 0
    6036:	40 e8       	ldi	r20, 0x80	; 128
    6038:	5f e3       	ldi	r21, 0x3F	; 63
    603a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    603e:	88 23       	and	r24, r24
    6040:	2c f4       	brge	.+10     	; 0x604c <LCD_sendCommand+0x160>
		__ticks = 1;
    6042:	81 e0       	ldi	r24, 0x01	; 1
    6044:	90 e0       	ldi	r25, 0x00	; 0
    6046:	9a a3       	std	Y+34, r25	; 0x22
    6048:	89 a3       	std	Y+33, r24	; 0x21
    604a:	3f c0       	rjmp	.+126    	; 0x60ca <LCD_sendCommand+0x1de>
	else if (__tmp > 65535)
    604c:	6b a1       	ldd	r22, Y+35	; 0x23
    604e:	7c a1       	ldd	r23, Y+36	; 0x24
    6050:	8d a1       	ldd	r24, Y+37	; 0x25
    6052:	9e a1       	ldd	r25, Y+38	; 0x26
    6054:	20 e0       	ldi	r18, 0x00	; 0
    6056:	3f ef       	ldi	r19, 0xFF	; 255
    6058:	4f e7       	ldi	r20, 0x7F	; 127
    605a:	57 e4       	ldi	r21, 0x47	; 71
    605c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6060:	18 16       	cp	r1, r24
    6062:	4c f5       	brge	.+82     	; 0x60b6 <LCD_sendCommand+0x1ca>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6064:	6f a1       	ldd	r22, Y+39	; 0x27
    6066:	78 a5       	ldd	r23, Y+40	; 0x28
    6068:	89 a5       	ldd	r24, Y+41	; 0x29
    606a:	9a a5       	ldd	r25, Y+42	; 0x2a
    606c:	20 e0       	ldi	r18, 0x00	; 0
    606e:	30 e0       	ldi	r19, 0x00	; 0
    6070:	40 e2       	ldi	r20, 0x20	; 32
    6072:	51 e4       	ldi	r21, 0x41	; 65
    6074:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6078:	dc 01       	movw	r26, r24
    607a:	cb 01       	movw	r24, r22
    607c:	bc 01       	movw	r22, r24
    607e:	cd 01       	movw	r24, r26
    6080:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6084:	dc 01       	movw	r26, r24
    6086:	cb 01       	movw	r24, r22
    6088:	9a a3       	std	Y+34, r25	; 0x22
    608a:	89 a3       	std	Y+33, r24	; 0x21
    608c:	0f c0       	rjmp	.+30     	; 0x60ac <LCD_sendCommand+0x1c0>
    608e:	89 e1       	ldi	r24, 0x19	; 25
    6090:	90 e0       	ldi	r25, 0x00	; 0
    6092:	98 a3       	std	Y+32, r25	; 0x20
    6094:	8f 8f       	std	Y+31, r24	; 0x1f
    6096:	8f 8d       	ldd	r24, Y+31	; 0x1f
    6098:	98 a1       	ldd	r25, Y+32	; 0x20
    609a:	01 97       	sbiw	r24, 0x01	; 1
    609c:	f1 f7       	brne	.-4      	; 0x609a <LCD_sendCommand+0x1ae>
    609e:	98 a3       	std	Y+32, r25	; 0x20
    60a0:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    60a2:	89 a1       	ldd	r24, Y+33	; 0x21
    60a4:	9a a1       	ldd	r25, Y+34	; 0x22
    60a6:	01 97       	sbiw	r24, 0x01	; 1
    60a8:	9a a3       	std	Y+34, r25	; 0x22
    60aa:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    60ac:	89 a1       	ldd	r24, Y+33	; 0x21
    60ae:	9a a1       	ldd	r25, Y+34	; 0x22
    60b0:	00 97       	sbiw	r24, 0x00	; 0
    60b2:	69 f7       	brne	.-38     	; 0x608e <LCD_sendCommand+0x1a2>
    60b4:	14 c0       	rjmp	.+40     	; 0x60de <LCD_sendCommand+0x1f2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    60b6:	6b a1       	ldd	r22, Y+35	; 0x23
    60b8:	7c a1       	ldd	r23, Y+36	; 0x24
    60ba:	8d a1       	ldd	r24, Y+37	; 0x25
    60bc:	9e a1       	ldd	r25, Y+38	; 0x26
    60be:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    60c2:	dc 01       	movw	r26, r24
    60c4:	cb 01       	movw	r24, r22
    60c6:	9a a3       	std	Y+34, r25	; 0x22
    60c8:	89 a3       	std	Y+33, r24	; 0x21
    60ca:	89 a1       	ldd	r24, Y+33	; 0x21
    60cc:	9a a1       	ldd	r25, Y+34	; 0x22
    60ce:	9e 8f       	std	Y+30, r25	; 0x1e
    60d0:	8d 8f       	std	Y+29, r24	; 0x1d
    60d2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    60d4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    60d6:	01 97       	sbiw	r24, 0x01	; 1
    60d8:	f1 f7       	brne	.-4      	; 0x60d6 <LCD_sendCommand+0x1ea>
    60da:	9e 8f       	std	Y+30, r25	; 0x1e
    60dc:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */

#elif(LCD_DATA_BITS_MODE == 8)
	GPIO_writePort(LCD_DATA_PORT_ID,command); /* out the required command to the data bus D0 --> D7 */
    60de:	83 e0       	ldi	r24, 0x03	; 3
    60e0:	69 ad       	ldd	r22, Y+57	; 0x39
    60e2:	0e 94 51 2e 	call	0x5ca2	; 0x5ca2 <GPIO_writePort>
    60e6:	80 e0       	ldi	r24, 0x00	; 0
    60e8:	90 e0       	ldi	r25, 0x00	; 0
    60ea:	a0 e8       	ldi	r26, 0x80	; 128
    60ec:	bf e3       	ldi	r27, 0x3F	; 63
    60ee:	89 8f       	std	Y+25, r24	; 0x19
    60f0:	9a 8f       	std	Y+26, r25	; 0x1a
    60f2:	ab 8f       	std	Y+27, r26	; 0x1b
    60f4:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    60f6:	69 8d       	ldd	r22, Y+25	; 0x19
    60f8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    60fa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    60fc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    60fe:	20 e0       	ldi	r18, 0x00	; 0
    6100:	30 e0       	ldi	r19, 0x00	; 0
    6102:	4a e7       	ldi	r20, 0x7A	; 122
    6104:	53 e4       	ldi	r21, 0x43	; 67
    6106:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    610a:	dc 01       	movw	r26, r24
    610c:	cb 01       	movw	r24, r22
    610e:	8d 8b       	std	Y+21, r24	; 0x15
    6110:	9e 8b       	std	Y+22, r25	; 0x16
    6112:	af 8b       	std	Y+23, r26	; 0x17
    6114:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    6116:	6d 89       	ldd	r22, Y+21	; 0x15
    6118:	7e 89       	ldd	r23, Y+22	; 0x16
    611a:	8f 89       	ldd	r24, Y+23	; 0x17
    611c:	98 8d       	ldd	r25, Y+24	; 0x18
    611e:	20 e0       	ldi	r18, 0x00	; 0
    6120:	30 e0       	ldi	r19, 0x00	; 0
    6122:	40 e8       	ldi	r20, 0x80	; 128
    6124:	5f e3       	ldi	r21, 0x3F	; 63
    6126:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    612a:	88 23       	and	r24, r24
    612c:	2c f4       	brge	.+10     	; 0x6138 <LCD_sendCommand+0x24c>
		__ticks = 1;
    612e:	81 e0       	ldi	r24, 0x01	; 1
    6130:	90 e0       	ldi	r25, 0x00	; 0
    6132:	9c 8b       	std	Y+20, r25	; 0x14
    6134:	8b 8b       	std	Y+19, r24	; 0x13
    6136:	3f c0       	rjmp	.+126    	; 0x61b6 <LCD_sendCommand+0x2ca>
	else if (__tmp > 65535)
    6138:	6d 89       	ldd	r22, Y+21	; 0x15
    613a:	7e 89       	ldd	r23, Y+22	; 0x16
    613c:	8f 89       	ldd	r24, Y+23	; 0x17
    613e:	98 8d       	ldd	r25, Y+24	; 0x18
    6140:	20 e0       	ldi	r18, 0x00	; 0
    6142:	3f ef       	ldi	r19, 0xFF	; 255
    6144:	4f e7       	ldi	r20, 0x7F	; 127
    6146:	57 e4       	ldi	r21, 0x47	; 71
    6148:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    614c:	18 16       	cp	r1, r24
    614e:	4c f5       	brge	.+82     	; 0x61a2 <LCD_sendCommand+0x2b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6150:	69 8d       	ldd	r22, Y+25	; 0x19
    6152:	7a 8d       	ldd	r23, Y+26	; 0x1a
    6154:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6156:	9c 8d       	ldd	r25, Y+28	; 0x1c
    6158:	20 e0       	ldi	r18, 0x00	; 0
    615a:	30 e0       	ldi	r19, 0x00	; 0
    615c:	40 e2       	ldi	r20, 0x20	; 32
    615e:	51 e4       	ldi	r21, 0x41	; 65
    6160:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6164:	dc 01       	movw	r26, r24
    6166:	cb 01       	movw	r24, r22
    6168:	bc 01       	movw	r22, r24
    616a:	cd 01       	movw	r24, r26
    616c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6170:	dc 01       	movw	r26, r24
    6172:	cb 01       	movw	r24, r22
    6174:	9c 8b       	std	Y+20, r25	; 0x14
    6176:	8b 8b       	std	Y+19, r24	; 0x13
    6178:	0f c0       	rjmp	.+30     	; 0x6198 <LCD_sendCommand+0x2ac>
    617a:	89 e1       	ldi	r24, 0x19	; 25
    617c:	90 e0       	ldi	r25, 0x00	; 0
    617e:	9a 8b       	std	Y+18, r25	; 0x12
    6180:	89 8b       	std	Y+17, r24	; 0x11
    6182:	89 89       	ldd	r24, Y+17	; 0x11
    6184:	9a 89       	ldd	r25, Y+18	; 0x12
    6186:	01 97       	sbiw	r24, 0x01	; 1
    6188:	f1 f7       	brne	.-4      	; 0x6186 <LCD_sendCommand+0x29a>
    618a:	9a 8b       	std	Y+18, r25	; 0x12
    618c:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    618e:	8b 89       	ldd	r24, Y+19	; 0x13
    6190:	9c 89       	ldd	r25, Y+20	; 0x14
    6192:	01 97       	sbiw	r24, 0x01	; 1
    6194:	9c 8b       	std	Y+20, r25	; 0x14
    6196:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6198:	8b 89       	ldd	r24, Y+19	; 0x13
    619a:	9c 89       	ldd	r25, Y+20	; 0x14
    619c:	00 97       	sbiw	r24, 0x00	; 0
    619e:	69 f7       	brne	.-38     	; 0x617a <LCD_sendCommand+0x28e>
    61a0:	14 c0       	rjmp	.+40     	; 0x61ca <LCD_sendCommand+0x2de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    61a2:	6d 89       	ldd	r22, Y+21	; 0x15
    61a4:	7e 89       	ldd	r23, Y+22	; 0x16
    61a6:	8f 89       	ldd	r24, Y+23	; 0x17
    61a8:	98 8d       	ldd	r25, Y+24	; 0x18
    61aa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    61ae:	dc 01       	movw	r26, r24
    61b0:	cb 01       	movw	r24, r22
    61b2:	9c 8b       	std	Y+20, r25	; 0x14
    61b4:	8b 8b       	std	Y+19, r24	; 0x13
    61b6:	8b 89       	ldd	r24, Y+19	; 0x13
    61b8:	9c 89       	ldd	r25, Y+20	; 0x14
    61ba:	98 8b       	std	Y+16, r25	; 0x10
    61bc:	8f 87       	std	Y+15, r24	; 0x0f
    61be:	8f 85       	ldd	r24, Y+15	; 0x0f
    61c0:	98 89       	ldd	r25, Y+16	; 0x10
    61c2:	01 97       	sbiw	r24, 0x01	; 1
    61c4:	f1 f7       	brne	.-4      	; 0x61c2 <LCD_sendCommand+0x2d6>
    61c6:	98 8b       	std	Y+16, r25	; 0x10
    61c8:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1); /* delay for processing Tdsw = 100ns */

	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    61ca:	81 e0       	ldi	r24, 0x01	; 1
    61cc:	66 e0       	ldi	r22, 0x06	; 6
    61ce:	40 e0       	ldi	r20, 0x00	; 0
    61d0:	0e 94 87 2c 	call	0x590e	; 0x590e <GPIO_writePin>
    61d4:	80 e0       	ldi	r24, 0x00	; 0
    61d6:	90 e0       	ldi	r25, 0x00	; 0
    61d8:	a0 e8       	ldi	r26, 0x80	; 128
    61da:	bf e3       	ldi	r27, 0x3F	; 63
    61dc:	8b 87       	std	Y+11, r24	; 0x0b
    61de:	9c 87       	std	Y+12, r25	; 0x0c
    61e0:	ad 87       	std	Y+13, r26	; 0x0d
    61e2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    61e4:	6b 85       	ldd	r22, Y+11	; 0x0b
    61e6:	7c 85       	ldd	r23, Y+12	; 0x0c
    61e8:	8d 85       	ldd	r24, Y+13	; 0x0d
    61ea:	9e 85       	ldd	r25, Y+14	; 0x0e
    61ec:	20 e0       	ldi	r18, 0x00	; 0
    61ee:	30 e0       	ldi	r19, 0x00	; 0
    61f0:	4a e7       	ldi	r20, 0x7A	; 122
    61f2:	53 e4       	ldi	r21, 0x43	; 67
    61f4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    61f8:	dc 01       	movw	r26, r24
    61fa:	cb 01       	movw	r24, r22
    61fc:	8f 83       	std	Y+7, r24	; 0x07
    61fe:	98 87       	std	Y+8, r25	; 0x08
    6200:	a9 87       	std	Y+9, r26	; 0x09
    6202:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    6204:	6f 81       	ldd	r22, Y+7	; 0x07
    6206:	78 85       	ldd	r23, Y+8	; 0x08
    6208:	89 85       	ldd	r24, Y+9	; 0x09
    620a:	9a 85       	ldd	r25, Y+10	; 0x0a
    620c:	20 e0       	ldi	r18, 0x00	; 0
    620e:	30 e0       	ldi	r19, 0x00	; 0
    6210:	40 e8       	ldi	r20, 0x80	; 128
    6212:	5f e3       	ldi	r21, 0x3F	; 63
    6214:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6218:	88 23       	and	r24, r24
    621a:	2c f4       	brge	.+10     	; 0x6226 <LCD_sendCommand+0x33a>
		__ticks = 1;
    621c:	81 e0       	ldi	r24, 0x01	; 1
    621e:	90 e0       	ldi	r25, 0x00	; 0
    6220:	9e 83       	std	Y+6, r25	; 0x06
    6222:	8d 83       	std	Y+5, r24	; 0x05
    6224:	3f c0       	rjmp	.+126    	; 0x62a4 <LCD_sendCommand+0x3b8>
	else if (__tmp > 65535)
    6226:	6f 81       	ldd	r22, Y+7	; 0x07
    6228:	78 85       	ldd	r23, Y+8	; 0x08
    622a:	89 85       	ldd	r24, Y+9	; 0x09
    622c:	9a 85       	ldd	r25, Y+10	; 0x0a
    622e:	20 e0       	ldi	r18, 0x00	; 0
    6230:	3f ef       	ldi	r19, 0xFF	; 255
    6232:	4f e7       	ldi	r20, 0x7F	; 127
    6234:	57 e4       	ldi	r21, 0x47	; 71
    6236:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    623a:	18 16       	cp	r1, r24
    623c:	4c f5       	brge	.+82     	; 0x6290 <LCD_sendCommand+0x3a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    623e:	6b 85       	ldd	r22, Y+11	; 0x0b
    6240:	7c 85       	ldd	r23, Y+12	; 0x0c
    6242:	8d 85       	ldd	r24, Y+13	; 0x0d
    6244:	9e 85       	ldd	r25, Y+14	; 0x0e
    6246:	20 e0       	ldi	r18, 0x00	; 0
    6248:	30 e0       	ldi	r19, 0x00	; 0
    624a:	40 e2       	ldi	r20, 0x20	; 32
    624c:	51 e4       	ldi	r21, 0x41	; 65
    624e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6252:	dc 01       	movw	r26, r24
    6254:	cb 01       	movw	r24, r22
    6256:	bc 01       	movw	r22, r24
    6258:	cd 01       	movw	r24, r26
    625a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    625e:	dc 01       	movw	r26, r24
    6260:	cb 01       	movw	r24, r22
    6262:	9e 83       	std	Y+6, r25	; 0x06
    6264:	8d 83       	std	Y+5, r24	; 0x05
    6266:	0f c0       	rjmp	.+30     	; 0x6286 <LCD_sendCommand+0x39a>
    6268:	89 e1       	ldi	r24, 0x19	; 25
    626a:	90 e0       	ldi	r25, 0x00	; 0
    626c:	9c 83       	std	Y+4, r25	; 0x04
    626e:	8b 83       	std	Y+3, r24	; 0x03
    6270:	8b 81       	ldd	r24, Y+3	; 0x03
    6272:	9c 81       	ldd	r25, Y+4	; 0x04
    6274:	01 97       	sbiw	r24, 0x01	; 1
    6276:	f1 f7       	brne	.-4      	; 0x6274 <LCD_sendCommand+0x388>
    6278:	9c 83       	std	Y+4, r25	; 0x04
    627a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    627c:	8d 81       	ldd	r24, Y+5	; 0x05
    627e:	9e 81       	ldd	r25, Y+6	; 0x06
    6280:	01 97       	sbiw	r24, 0x01	; 1
    6282:	9e 83       	std	Y+6, r25	; 0x06
    6284:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6286:	8d 81       	ldd	r24, Y+5	; 0x05
    6288:	9e 81       	ldd	r25, Y+6	; 0x06
    628a:	00 97       	sbiw	r24, 0x00	; 0
    628c:	69 f7       	brne	.-38     	; 0x6268 <LCD_sendCommand+0x37c>
    628e:	14 c0       	rjmp	.+40     	; 0x62b8 <LCD_sendCommand+0x3cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6290:	6f 81       	ldd	r22, Y+7	; 0x07
    6292:	78 85       	ldd	r23, Y+8	; 0x08
    6294:	89 85       	ldd	r24, Y+9	; 0x09
    6296:	9a 85       	ldd	r25, Y+10	; 0x0a
    6298:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    629c:	dc 01       	movw	r26, r24
    629e:	cb 01       	movw	r24, r22
    62a0:	9e 83       	std	Y+6, r25	; 0x06
    62a2:	8d 83       	std	Y+5, r24	; 0x05
    62a4:	8d 81       	ldd	r24, Y+5	; 0x05
    62a6:	9e 81       	ldd	r25, Y+6	; 0x06
    62a8:	9a 83       	std	Y+2, r25	; 0x02
    62aa:	89 83       	std	Y+1, r24	; 0x01
    62ac:	89 81       	ldd	r24, Y+1	; 0x01
    62ae:	9a 81       	ldd	r25, Y+2	; 0x02
    62b0:	01 97       	sbiw	r24, 0x01	; 1
    62b2:	f1 f7       	brne	.-4      	; 0x62b0 <LCD_sendCommand+0x3c4>
    62b4:	9a 83       	std	Y+2, r25	; 0x02
    62b6:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1); /* delay for processing Th = 13ns */

#endif
}
    62b8:	e9 96       	adiw	r28, 0x39	; 57
    62ba:	0f b6       	in	r0, 0x3f	; 63
    62bc:	f8 94       	cli
    62be:	de bf       	out	0x3e, r29	; 62
    62c0:	0f be       	out	0x3f, r0	; 63
    62c2:	cd bf       	out	0x3d, r28	; 61
    62c4:	cf 91       	pop	r28
    62c6:	df 91       	pop	r29
    62c8:	08 95       	ret

000062ca <LCD_displayCharacter>:
/*
 * Description :
 * Display the required character on the screen
 */
void LCD_displayCharacter(uint8 data)
{
    62ca:	df 93       	push	r29
    62cc:	cf 93       	push	r28
    62ce:	cd b7       	in	r28, 0x3d	; 61
    62d0:	de b7       	in	r29, 0x3e	; 62
    62d2:	e9 97       	sbiw	r28, 0x39	; 57
    62d4:	0f b6       	in	r0, 0x3f	; 63
    62d6:	f8 94       	cli
    62d8:	de bf       	out	0x3e, r29	; 62
    62da:	0f be       	out	0x3f, r0	; 63
    62dc:	cd bf       	out	0x3d, r28	; 61
    62de:	89 af       	std	Y+57, r24	; 0x39
	GPIO_writePin(LCD_RS_PORT_ID,LCD_RS_PIN_ID,LOGIC_HIGH); /* Data Mode RS=1 */
    62e0:	81 e0       	ldi	r24, 0x01	; 1
    62e2:	67 e0       	ldi	r22, 0x07	; 7
    62e4:	41 e0       	ldi	r20, 0x01	; 1
    62e6:	0e 94 87 2c 	call	0x590e	; 0x590e <GPIO_writePin>
    62ea:	80 e0       	ldi	r24, 0x00	; 0
    62ec:	90 e0       	ldi	r25, 0x00	; 0
    62ee:	a0 e8       	ldi	r26, 0x80	; 128
    62f0:	bf e3       	ldi	r27, 0x3F	; 63
    62f2:	8d ab       	std	Y+53, r24	; 0x35
    62f4:	9e ab       	std	Y+54, r25	; 0x36
    62f6:	af ab       	std	Y+55, r26	; 0x37
    62f8:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    62fa:	6d a9       	ldd	r22, Y+53	; 0x35
    62fc:	7e a9       	ldd	r23, Y+54	; 0x36
    62fe:	8f a9       	ldd	r24, Y+55	; 0x37
    6300:	98 ad       	ldd	r25, Y+56	; 0x38
    6302:	20 e0       	ldi	r18, 0x00	; 0
    6304:	30 e0       	ldi	r19, 0x00	; 0
    6306:	4a e7       	ldi	r20, 0x7A	; 122
    6308:	53 e4       	ldi	r21, 0x43	; 67
    630a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    630e:	dc 01       	movw	r26, r24
    6310:	cb 01       	movw	r24, r22
    6312:	89 ab       	std	Y+49, r24	; 0x31
    6314:	9a ab       	std	Y+50, r25	; 0x32
    6316:	ab ab       	std	Y+51, r26	; 0x33
    6318:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    631a:	69 a9       	ldd	r22, Y+49	; 0x31
    631c:	7a a9       	ldd	r23, Y+50	; 0x32
    631e:	8b a9       	ldd	r24, Y+51	; 0x33
    6320:	9c a9       	ldd	r25, Y+52	; 0x34
    6322:	20 e0       	ldi	r18, 0x00	; 0
    6324:	30 e0       	ldi	r19, 0x00	; 0
    6326:	40 e8       	ldi	r20, 0x80	; 128
    6328:	5f e3       	ldi	r21, 0x3F	; 63
    632a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    632e:	88 23       	and	r24, r24
    6330:	2c f4       	brge	.+10     	; 0x633c <LCD_displayCharacter+0x72>
		__ticks = 1;
    6332:	81 e0       	ldi	r24, 0x01	; 1
    6334:	90 e0       	ldi	r25, 0x00	; 0
    6336:	98 ab       	std	Y+48, r25	; 0x30
    6338:	8f a7       	std	Y+47, r24	; 0x2f
    633a:	3f c0       	rjmp	.+126    	; 0x63ba <LCD_displayCharacter+0xf0>
	else if (__tmp > 65535)
    633c:	69 a9       	ldd	r22, Y+49	; 0x31
    633e:	7a a9       	ldd	r23, Y+50	; 0x32
    6340:	8b a9       	ldd	r24, Y+51	; 0x33
    6342:	9c a9       	ldd	r25, Y+52	; 0x34
    6344:	20 e0       	ldi	r18, 0x00	; 0
    6346:	3f ef       	ldi	r19, 0xFF	; 255
    6348:	4f e7       	ldi	r20, 0x7F	; 127
    634a:	57 e4       	ldi	r21, 0x47	; 71
    634c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6350:	18 16       	cp	r1, r24
    6352:	4c f5       	brge	.+82     	; 0x63a6 <LCD_displayCharacter+0xdc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6354:	6d a9       	ldd	r22, Y+53	; 0x35
    6356:	7e a9       	ldd	r23, Y+54	; 0x36
    6358:	8f a9       	ldd	r24, Y+55	; 0x37
    635a:	98 ad       	ldd	r25, Y+56	; 0x38
    635c:	20 e0       	ldi	r18, 0x00	; 0
    635e:	30 e0       	ldi	r19, 0x00	; 0
    6360:	40 e2       	ldi	r20, 0x20	; 32
    6362:	51 e4       	ldi	r21, 0x41	; 65
    6364:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6368:	dc 01       	movw	r26, r24
    636a:	cb 01       	movw	r24, r22
    636c:	bc 01       	movw	r22, r24
    636e:	cd 01       	movw	r24, r26
    6370:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6374:	dc 01       	movw	r26, r24
    6376:	cb 01       	movw	r24, r22
    6378:	98 ab       	std	Y+48, r25	; 0x30
    637a:	8f a7       	std	Y+47, r24	; 0x2f
    637c:	0f c0       	rjmp	.+30     	; 0x639c <LCD_displayCharacter+0xd2>
    637e:	89 e1       	ldi	r24, 0x19	; 25
    6380:	90 e0       	ldi	r25, 0x00	; 0
    6382:	9e a7       	std	Y+46, r25	; 0x2e
    6384:	8d a7       	std	Y+45, r24	; 0x2d
    6386:	8d a5       	ldd	r24, Y+45	; 0x2d
    6388:	9e a5       	ldd	r25, Y+46	; 0x2e
    638a:	01 97       	sbiw	r24, 0x01	; 1
    638c:	f1 f7       	brne	.-4      	; 0x638a <LCD_displayCharacter+0xc0>
    638e:	9e a7       	std	Y+46, r25	; 0x2e
    6390:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6392:	8f a5       	ldd	r24, Y+47	; 0x2f
    6394:	98 a9       	ldd	r25, Y+48	; 0x30
    6396:	01 97       	sbiw	r24, 0x01	; 1
    6398:	98 ab       	std	Y+48, r25	; 0x30
    639a:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    639c:	8f a5       	ldd	r24, Y+47	; 0x2f
    639e:	98 a9       	ldd	r25, Y+48	; 0x30
    63a0:	00 97       	sbiw	r24, 0x00	; 0
    63a2:	69 f7       	brne	.-38     	; 0x637e <LCD_displayCharacter+0xb4>
    63a4:	14 c0       	rjmp	.+40     	; 0x63ce <LCD_displayCharacter+0x104>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    63a6:	69 a9       	ldd	r22, Y+49	; 0x31
    63a8:	7a a9       	ldd	r23, Y+50	; 0x32
    63aa:	8b a9       	ldd	r24, Y+51	; 0x33
    63ac:	9c a9       	ldd	r25, Y+52	; 0x34
    63ae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    63b2:	dc 01       	movw	r26, r24
    63b4:	cb 01       	movw	r24, r22
    63b6:	98 ab       	std	Y+48, r25	; 0x30
    63b8:	8f a7       	std	Y+47, r24	; 0x2f
    63ba:	8f a5       	ldd	r24, Y+47	; 0x2f
    63bc:	98 a9       	ldd	r25, Y+48	; 0x30
    63be:	9c a7       	std	Y+44, r25	; 0x2c
    63c0:	8b a7       	std	Y+43, r24	; 0x2b
    63c2:	8b a5       	ldd	r24, Y+43	; 0x2b
    63c4:	9c a5       	ldd	r25, Y+44	; 0x2c
    63c6:	01 97       	sbiw	r24, 0x01	; 1
    63c8:	f1 f7       	brne	.-4      	; 0x63c6 <LCD_displayCharacter+0xfc>
    63ca:	9c a7       	std	Y+44, r25	; 0x2c
    63cc:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Tas = 50ns */

	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    63ce:	81 e0       	ldi	r24, 0x01	; 1
    63d0:	66 e0       	ldi	r22, 0x06	; 6
    63d2:	41 e0       	ldi	r20, 0x01	; 1
    63d4:	0e 94 87 2c 	call	0x590e	; 0x590e <GPIO_writePin>
    63d8:	80 e0       	ldi	r24, 0x00	; 0
    63da:	90 e0       	ldi	r25, 0x00	; 0
    63dc:	a0 e8       	ldi	r26, 0x80	; 128
    63de:	bf e3       	ldi	r27, 0x3F	; 63
    63e0:	8f a3       	std	Y+39, r24	; 0x27
    63e2:	98 a7       	std	Y+40, r25	; 0x28
    63e4:	a9 a7       	std	Y+41, r26	; 0x29
    63e6:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    63e8:	6f a1       	ldd	r22, Y+39	; 0x27
    63ea:	78 a5       	ldd	r23, Y+40	; 0x28
    63ec:	89 a5       	ldd	r24, Y+41	; 0x29
    63ee:	9a a5       	ldd	r25, Y+42	; 0x2a
    63f0:	20 e0       	ldi	r18, 0x00	; 0
    63f2:	30 e0       	ldi	r19, 0x00	; 0
    63f4:	4a e7       	ldi	r20, 0x7A	; 122
    63f6:	53 e4       	ldi	r21, 0x43	; 67
    63f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    63fc:	dc 01       	movw	r26, r24
    63fe:	cb 01       	movw	r24, r22
    6400:	8b a3       	std	Y+35, r24	; 0x23
    6402:	9c a3       	std	Y+36, r25	; 0x24
    6404:	ad a3       	std	Y+37, r26	; 0x25
    6406:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    6408:	6b a1       	ldd	r22, Y+35	; 0x23
    640a:	7c a1       	ldd	r23, Y+36	; 0x24
    640c:	8d a1       	ldd	r24, Y+37	; 0x25
    640e:	9e a1       	ldd	r25, Y+38	; 0x26
    6410:	20 e0       	ldi	r18, 0x00	; 0
    6412:	30 e0       	ldi	r19, 0x00	; 0
    6414:	40 e8       	ldi	r20, 0x80	; 128
    6416:	5f e3       	ldi	r21, 0x3F	; 63
    6418:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    641c:	88 23       	and	r24, r24
    641e:	2c f4       	brge	.+10     	; 0x642a <LCD_displayCharacter+0x160>
		__ticks = 1;
    6420:	81 e0       	ldi	r24, 0x01	; 1
    6422:	90 e0       	ldi	r25, 0x00	; 0
    6424:	9a a3       	std	Y+34, r25	; 0x22
    6426:	89 a3       	std	Y+33, r24	; 0x21
    6428:	3f c0       	rjmp	.+126    	; 0x64a8 <LCD_displayCharacter+0x1de>
	else if (__tmp > 65535)
    642a:	6b a1       	ldd	r22, Y+35	; 0x23
    642c:	7c a1       	ldd	r23, Y+36	; 0x24
    642e:	8d a1       	ldd	r24, Y+37	; 0x25
    6430:	9e a1       	ldd	r25, Y+38	; 0x26
    6432:	20 e0       	ldi	r18, 0x00	; 0
    6434:	3f ef       	ldi	r19, 0xFF	; 255
    6436:	4f e7       	ldi	r20, 0x7F	; 127
    6438:	57 e4       	ldi	r21, 0x47	; 71
    643a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    643e:	18 16       	cp	r1, r24
    6440:	4c f5       	brge	.+82     	; 0x6494 <LCD_displayCharacter+0x1ca>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6442:	6f a1       	ldd	r22, Y+39	; 0x27
    6444:	78 a5       	ldd	r23, Y+40	; 0x28
    6446:	89 a5       	ldd	r24, Y+41	; 0x29
    6448:	9a a5       	ldd	r25, Y+42	; 0x2a
    644a:	20 e0       	ldi	r18, 0x00	; 0
    644c:	30 e0       	ldi	r19, 0x00	; 0
    644e:	40 e2       	ldi	r20, 0x20	; 32
    6450:	51 e4       	ldi	r21, 0x41	; 65
    6452:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6456:	dc 01       	movw	r26, r24
    6458:	cb 01       	movw	r24, r22
    645a:	bc 01       	movw	r22, r24
    645c:	cd 01       	movw	r24, r26
    645e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6462:	dc 01       	movw	r26, r24
    6464:	cb 01       	movw	r24, r22
    6466:	9a a3       	std	Y+34, r25	; 0x22
    6468:	89 a3       	std	Y+33, r24	; 0x21
    646a:	0f c0       	rjmp	.+30     	; 0x648a <LCD_displayCharacter+0x1c0>
    646c:	89 e1       	ldi	r24, 0x19	; 25
    646e:	90 e0       	ldi	r25, 0x00	; 0
    6470:	98 a3       	std	Y+32, r25	; 0x20
    6472:	8f 8f       	std	Y+31, r24	; 0x1f
    6474:	8f 8d       	ldd	r24, Y+31	; 0x1f
    6476:	98 a1       	ldd	r25, Y+32	; 0x20
    6478:	01 97       	sbiw	r24, 0x01	; 1
    647a:	f1 f7       	brne	.-4      	; 0x6478 <LCD_displayCharacter+0x1ae>
    647c:	98 a3       	std	Y+32, r25	; 0x20
    647e:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6480:	89 a1       	ldd	r24, Y+33	; 0x21
    6482:	9a a1       	ldd	r25, Y+34	; 0x22
    6484:	01 97       	sbiw	r24, 0x01	; 1
    6486:	9a a3       	std	Y+34, r25	; 0x22
    6488:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    648a:	89 a1       	ldd	r24, Y+33	; 0x21
    648c:	9a a1       	ldd	r25, Y+34	; 0x22
    648e:	00 97       	sbiw	r24, 0x00	; 0
    6490:	69 f7       	brne	.-38     	; 0x646c <LCD_displayCharacter+0x1a2>
    6492:	14 c0       	rjmp	.+40     	; 0x64bc <LCD_displayCharacter+0x1f2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6494:	6b a1       	ldd	r22, Y+35	; 0x23
    6496:	7c a1       	ldd	r23, Y+36	; 0x24
    6498:	8d a1       	ldd	r24, Y+37	; 0x25
    649a:	9e a1       	ldd	r25, Y+38	; 0x26
    649c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    64a0:	dc 01       	movw	r26, r24
    64a2:	cb 01       	movw	r24, r22
    64a4:	9a a3       	std	Y+34, r25	; 0x22
    64a6:	89 a3       	std	Y+33, r24	; 0x21
    64a8:	89 a1       	ldd	r24, Y+33	; 0x21
    64aa:	9a a1       	ldd	r25, Y+34	; 0x22
    64ac:	9e 8f       	std	Y+30, r25	; 0x1e
    64ae:	8d 8f       	std	Y+29, r24	; 0x1d
    64b0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    64b2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    64b4:	01 97       	sbiw	r24, 0x01	; 1
    64b6:	f1 f7       	brne	.-4      	; 0x64b4 <LCD_displayCharacter+0x1ea>
    64b8:	9e 8f       	std	Y+30, r25	; 0x1e
    64ba:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */

#elif(LCD_DATA_BITS_MODE == 8)
	GPIO_writePort(LCD_DATA_PORT_ID,data); /* out the required command to the data bus D0 --> D7 */
    64bc:	83 e0       	ldi	r24, 0x03	; 3
    64be:	69 ad       	ldd	r22, Y+57	; 0x39
    64c0:	0e 94 51 2e 	call	0x5ca2	; 0x5ca2 <GPIO_writePort>
    64c4:	80 e0       	ldi	r24, 0x00	; 0
    64c6:	90 e0       	ldi	r25, 0x00	; 0
    64c8:	a0 e8       	ldi	r26, 0x80	; 128
    64ca:	bf e3       	ldi	r27, 0x3F	; 63
    64cc:	89 8f       	std	Y+25, r24	; 0x19
    64ce:	9a 8f       	std	Y+26, r25	; 0x1a
    64d0:	ab 8f       	std	Y+27, r26	; 0x1b
    64d2:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    64d4:	69 8d       	ldd	r22, Y+25	; 0x19
    64d6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    64d8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    64da:	9c 8d       	ldd	r25, Y+28	; 0x1c
    64dc:	20 e0       	ldi	r18, 0x00	; 0
    64de:	30 e0       	ldi	r19, 0x00	; 0
    64e0:	4a e7       	ldi	r20, 0x7A	; 122
    64e2:	53 e4       	ldi	r21, 0x43	; 67
    64e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    64e8:	dc 01       	movw	r26, r24
    64ea:	cb 01       	movw	r24, r22
    64ec:	8d 8b       	std	Y+21, r24	; 0x15
    64ee:	9e 8b       	std	Y+22, r25	; 0x16
    64f0:	af 8b       	std	Y+23, r26	; 0x17
    64f2:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    64f4:	6d 89       	ldd	r22, Y+21	; 0x15
    64f6:	7e 89       	ldd	r23, Y+22	; 0x16
    64f8:	8f 89       	ldd	r24, Y+23	; 0x17
    64fa:	98 8d       	ldd	r25, Y+24	; 0x18
    64fc:	20 e0       	ldi	r18, 0x00	; 0
    64fe:	30 e0       	ldi	r19, 0x00	; 0
    6500:	40 e8       	ldi	r20, 0x80	; 128
    6502:	5f e3       	ldi	r21, 0x3F	; 63
    6504:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6508:	88 23       	and	r24, r24
    650a:	2c f4       	brge	.+10     	; 0x6516 <LCD_displayCharacter+0x24c>
		__ticks = 1;
    650c:	81 e0       	ldi	r24, 0x01	; 1
    650e:	90 e0       	ldi	r25, 0x00	; 0
    6510:	9c 8b       	std	Y+20, r25	; 0x14
    6512:	8b 8b       	std	Y+19, r24	; 0x13
    6514:	3f c0       	rjmp	.+126    	; 0x6594 <LCD_displayCharacter+0x2ca>
	else if (__tmp > 65535)
    6516:	6d 89       	ldd	r22, Y+21	; 0x15
    6518:	7e 89       	ldd	r23, Y+22	; 0x16
    651a:	8f 89       	ldd	r24, Y+23	; 0x17
    651c:	98 8d       	ldd	r25, Y+24	; 0x18
    651e:	20 e0       	ldi	r18, 0x00	; 0
    6520:	3f ef       	ldi	r19, 0xFF	; 255
    6522:	4f e7       	ldi	r20, 0x7F	; 127
    6524:	57 e4       	ldi	r21, 0x47	; 71
    6526:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    652a:	18 16       	cp	r1, r24
    652c:	4c f5       	brge	.+82     	; 0x6580 <LCD_displayCharacter+0x2b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    652e:	69 8d       	ldd	r22, Y+25	; 0x19
    6530:	7a 8d       	ldd	r23, Y+26	; 0x1a
    6532:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6534:	9c 8d       	ldd	r25, Y+28	; 0x1c
    6536:	20 e0       	ldi	r18, 0x00	; 0
    6538:	30 e0       	ldi	r19, 0x00	; 0
    653a:	40 e2       	ldi	r20, 0x20	; 32
    653c:	51 e4       	ldi	r21, 0x41	; 65
    653e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6542:	dc 01       	movw	r26, r24
    6544:	cb 01       	movw	r24, r22
    6546:	bc 01       	movw	r22, r24
    6548:	cd 01       	movw	r24, r26
    654a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    654e:	dc 01       	movw	r26, r24
    6550:	cb 01       	movw	r24, r22
    6552:	9c 8b       	std	Y+20, r25	; 0x14
    6554:	8b 8b       	std	Y+19, r24	; 0x13
    6556:	0f c0       	rjmp	.+30     	; 0x6576 <LCD_displayCharacter+0x2ac>
    6558:	89 e1       	ldi	r24, 0x19	; 25
    655a:	90 e0       	ldi	r25, 0x00	; 0
    655c:	9a 8b       	std	Y+18, r25	; 0x12
    655e:	89 8b       	std	Y+17, r24	; 0x11
    6560:	89 89       	ldd	r24, Y+17	; 0x11
    6562:	9a 89       	ldd	r25, Y+18	; 0x12
    6564:	01 97       	sbiw	r24, 0x01	; 1
    6566:	f1 f7       	brne	.-4      	; 0x6564 <LCD_displayCharacter+0x29a>
    6568:	9a 8b       	std	Y+18, r25	; 0x12
    656a:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    656c:	8b 89       	ldd	r24, Y+19	; 0x13
    656e:	9c 89       	ldd	r25, Y+20	; 0x14
    6570:	01 97       	sbiw	r24, 0x01	; 1
    6572:	9c 8b       	std	Y+20, r25	; 0x14
    6574:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6576:	8b 89       	ldd	r24, Y+19	; 0x13
    6578:	9c 89       	ldd	r25, Y+20	; 0x14
    657a:	00 97       	sbiw	r24, 0x00	; 0
    657c:	69 f7       	brne	.-38     	; 0x6558 <LCD_displayCharacter+0x28e>
    657e:	14 c0       	rjmp	.+40     	; 0x65a8 <LCD_displayCharacter+0x2de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6580:	6d 89       	ldd	r22, Y+21	; 0x15
    6582:	7e 89       	ldd	r23, Y+22	; 0x16
    6584:	8f 89       	ldd	r24, Y+23	; 0x17
    6586:	98 8d       	ldd	r25, Y+24	; 0x18
    6588:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    658c:	dc 01       	movw	r26, r24
    658e:	cb 01       	movw	r24, r22
    6590:	9c 8b       	std	Y+20, r25	; 0x14
    6592:	8b 8b       	std	Y+19, r24	; 0x13
    6594:	8b 89       	ldd	r24, Y+19	; 0x13
    6596:	9c 89       	ldd	r25, Y+20	; 0x14
    6598:	98 8b       	std	Y+16, r25	; 0x10
    659a:	8f 87       	std	Y+15, r24	; 0x0f
    659c:	8f 85       	ldd	r24, Y+15	; 0x0f
    659e:	98 89       	ldd	r25, Y+16	; 0x10
    65a0:	01 97       	sbiw	r24, 0x01	; 1
    65a2:	f1 f7       	brne	.-4      	; 0x65a0 <LCD_displayCharacter+0x2d6>
    65a4:	98 8b       	std	Y+16, r25	; 0x10
    65a6:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1); /* delay for processing Tdsw = 100ns */

	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    65a8:	81 e0       	ldi	r24, 0x01	; 1
    65aa:	66 e0       	ldi	r22, 0x06	; 6
    65ac:	40 e0       	ldi	r20, 0x00	; 0
    65ae:	0e 94 87 2c 	call	0x590e	; 0x590e <GPIO_writePin>
    65b2:	80 e0       	ldi	r24, 0x00	; 0
    65b4:	90 e0       	ldi	r25, 0x00	; 0
    65b6:	a0 e8       	ldi	r26, 0x80	; 128
    65b8:	bf e3       	ldi	r27, 0x3F	; 63
    65ba:	8b 87       	std	Y+11, r24	; 0x0b
    65bc:	9c 87       	std	Y+12, r25	; 0x0c
    65be:	ad 87       	std	Y+13, r26	; 0x0d
    65c0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    65c2:	6b 85       	ldd	r22, Y+11	; 0x0b
    65c4:	7c 85       	ldd	r23, Y+12	; 0x0c
    65c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    65c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    65ca:	20 e0       	ldi	r18, 0x00	; 0
    65cc:	30 e0       	ldi	r19, 0x00	; 0
    65ce:	4a e7       	ldi	r20, 0x7A	; 122
    65d0:	53 e4       	ldi	r21, 0x43	; 67
    65d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    65d6:	dc 01       	movw	r26, r24
    65d8:	cb 01       	movw	r24, r22
    65da:	8f 83       	std	Y+7, r24	; 0x07
    65dc:	98 87       	std	Y+8, r25	; 0x08
    65de:	a9 87       	std	Y+9, r26	; 0x09
    65e0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    65e2:	6f 81       	ldd	r22, Y+7	; 0x07
    65e4:	78 85       	ldd	r23, Y+8	; 0x08
    65e6:	89 85       	ldd	r24, Y+9	; 0x09
    65e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    65ea:	20 e0       	ldi	r18, 0x00	; 0
    65ec:	30 e0       	ldi	r19, 0x00	; 0
    65ee:	40 e8       	ldi	r20, 0x80	; 128
    65f0:	5f e3       	ldi	r21, 0x3F	; 63
    65f2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    65f6:	88 23       	and	r24, r24
    65f8:	2c f4       	brge	.+10     	; 0x6604 <LCD_displayCharacter+0x33a>
		__ticks = 1;
    65fa:	81 e0       	ldi	r24, 0x01	; 1
    65fc:	90 e0       	ldi	r25, 0x00	; 0
    65fe:	9e 83       	std	Y+6, r25	; 0x06
    6600:	8d 83       	std	Y+5, r24	; 0x05
    6602:	3f c0       	rjmp	.+126    	; 0x6682 <LCD_displayCharacter+0x3b8>
	else if (__tmp > 65535)
    6604:	6f 81       	ldd	r22, Y+7	; 0x07
    6606:	78 85       	ldd	r23, Y+8	; 0x08
    6608:	89 85       	ldd	r24, Y+9	; 0x09
    660a:	9a 85       	ldd	r25, Y+10	; 0x0a
    660c:	20 e0       	ldi	r18, 0x00	; 0
    660e:	3f ef       	ldi	r19, 0xFF	; 255
    6610:	4f e7       	ldi	r20, 0x7F	; 127
    6612:	57 e4       	ldi	r21, 0x47	; 71
    6614:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6618:	18 16       	cp	r1, r24
    661a:	4c f5       	brge	.+82     	; 0x666e <LCD_displayCharacter+0x3a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    661c:	6b 85       	ldd	r22, Y+11	; 0x0b
    661e:	7c 85       	ldd	r23, Y+12	; 0x0c
    6620:	8d 85       	ldd	r24, Y+13	; 0x0d
    6622:	9e 85       	ldd	r25, Y+14	; 0x0e
    6624:	20 e0       	ldi	r18, 0x00	; 0
    6626:	30 e0       	ldi	r19, 0x00	; 0
    6628:	40 e2       	ldi	r20, 0x20	; 32
    662a:	51 e4       	ldi	r21, 0x41	; 65
    662c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6630:	dc 01       	movw	r26, r24
    6632:	cb 01       	movw	r24, r22
    6634:	bc 01       	movw	r22, r24
    6636:	cd 01       	movw	r24, r26
    6638:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    663c:	dc 01       	movw	r26, r24
    663e:	cb 01       	movw	r24, r22
    6640:	9e 83       	std	Y+6, r25	; 0x06
    6642:	8d 83       	std	Y+5, r24	; 0x05
    6644:	0f c0       	rjmp	.+30     	; 0x6664 <LCD_displayCharacter+0x39a>
    6646:	89 e1       	ldi	r24, 0x19	; 25
    6648:	90 e0       	ldi	r25, 0x00	; 0
    664a:	9c 83       	std	Y+4, r25	; 0x04
    664c:	8b 83       	std	Y+3, r24	; 0x03
    664e:	8b 81       	ldd	r24, Y+3	; 0x03
    6650:	9c 81       	ldd	r25, Y+4	; 0x04
    6652:	01 97       	sbiw	r24, 0x01	; 1
    6654:	f1 f7       	brne	.-4      	; 0x6652 <LCD_displayCharacter+0x388>
    6656:	9c 83       	std	Y+4, r25	; 0x04
    6658:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    665a:	8d 81       	ldd	r24, Y+5	; 0x05
    665c:	9e 81       	ldd	r25, Y+6	; 0x06
    665e:	01 97       	sbiw	r24, 0x01	; 1
    6660:	9e 83       	std	Y+6, r25	; 0x06
    6662:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6664:	8d 81       	ldd	r24, Y+5	; 0x05
    6666:	9e 81       	ldd	r25, Y+6	; 0x06
    6668:	00 97       	sbiw	r24, 0x00	; 0
    666a:	69 f7       	brne	.-38     	; 0x6646 <LCD_displayCharacter+0x37c>
    666c:	14 c0       	rjmp	.+40     	; 0x6696 <LCD_displayCharacter+0x3cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    666e:	6f 81       	ldd	r22, Y+7	; 0x07
    6670:	78 85       	ldd	r23, Y+8	; 0x08
    6672:	89 85       	ldd	r24, Y+9	; 0x09
    6674:	9a 85       	ldd	r25, Y+10	; 0x0a
    6676:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    667a:	dc 01       	movw	r26, r24
    667c:	cb 01       	movw	r24, r22
    667e:	9e 83       	std	Y+6, r25	; 0x06
    6680:	8d 83       	std	Y+5, r24	; 0x05
    6682:	8d 81       	ldd	r24, Y+5	; 0x05
    6684:	9e 81       	ldd	r25, Y+6	; 0x06
    6686:	9a 83       	std	Y+2, r25	; 0x02
    6688:	89 83       	std	Y+1, r24	; 0x01
    668a:	89 81       	ldd	r24, Y+1	; 0x01
    668c:	9a 81       	ldd	r25, Y+2	; 0x02
    668e:	01 97       	sbiw	r24, 0x01	; 1
    6690:	f1 f7       	brne	.-4      	; 0x668e <LCD_displayCharacter+0x3c4>
    6692:	9a 83       	std	Y+2, r25	; 0x02
    6694:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1); /* delay for processing Th = 13ns */

#endif
}
    6696:	e9 96       	adiw	r28, 0x39	; 57
    6698:	0f b6       	in	r0, 0x3f	; 63
    669a:	f8 94       	cli
    669c:	de bf       	out	0x3e, r29	; 62
    669e:	0f be       	out	0x3f, r0	; 63
    66a0:	cd bf       	out	0x3d, r28	; 61
    66a2:	cf 91       	pop	r28
    66a4:	df 91       	pop	r29
    66a6:	08 95       	ret

000066a8 <LCD_displayString>:
/*
 * Description :
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
    66a8:	df 93       	push	r29
    66aa:	cf 93       	push	r28
    66ac:	00 d0       	rcall	.+0      	; 0x66ae <LCD_displayString+0x6>
    66ae:	0f 92       	push	r0
    66b0:	cd b7       	in	r28, 0x3d	; 61
    66b2:	de b7       	in	r29, 0x3e	; 62
    66b4:	9b 83       	std	Y+3, r25	; 0x03
    66b6:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    66b8:	19 82       	std	Y+1, r1	; 0x01
    66ba:	0e c0       	rjmp	.+28     	; 0x66d8 <LCD_displayString+0x30>
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    66bc:	89 81       	ldd	r24, Y+1	; 0x01
    66be:	28 2f       	mov	r18, r24
    66c0:	30 e0       	ldi	r19, 0x00	; 0
    66c2:	8a 81       	ldd	r24, Y+2	; 0x02
    66c4:	9b 81       	ldd	r25, Y+3	; 0x03
    66c6:	fc 01       	movw	r30, r24
    66c8:	e2 0f       	add	r30, r18
    66ca:	f3 1f       	adc	r31, r19
    66cc:	80 81       	ld	r24, Z
    66ce:	0e 94 65 31 	call	0x62ca	; 0x62ca <LCD_displayCharacter>
		i++;
    66d2:	89 81       	ldd	r24, Y+1	; 0x01
    66d4:	8f 5f       	subi	r24, 0xFF	; 255
    66d6:	89 83       	std	Y+1, r24	; 0x01
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
	uint8 i = 0;
	while(Str[i] != '\0')
    66d8:	89 81       	ldd	r24, Y+1	; 0x01
    66da:	28 2f       	mov	r18, r24
    66dc:	30 e0       	ldi	r19, 0x00	; 0
    66de:	8a 81       	ldd	r24, Y+2	; 0x02
    66e0:	9b 81       	ldd	r25, Y+3	; 0x03
    66e2:	fc 01       	movw	r30, r24
    66e4:	e2 0f       	add	r30, r18
    66e6:	f3 1f       	adc	r31, r19
    66e8:	80 81       	ld	r24, Z
    66ea:	88 23       	and	r24, r24
    66ec:	39 f7       	brne	.-50     	; 0x66bc <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	*********************************************************/
}
    66ee:	0f 90       	pop	r0
    66f0:	0f 90       	pop	r0
    66f2:	0f 90       	pop	r0
    66f4:	cf 91       	pop	r28
    66f6:	df 91       	pop	r29
    66f8:	08 95       	ret

000066fa <LCD_moveCursor>:
/*
 * Description :
 * Move the cursor to a specified row and column index on the screen
 */
void LCD_moveCursor(uint8 row,uint8 col)
{
    66fa:	df 93       	push	r29
    66fc:	cf 93       	push	r28
    66fe:	00 d0       	rcall	.+0      	; 0x6700 <LCD_moveCursor+0x6>
    6700:	00 d0       	rcall	.+0      	; 0x6702 <LCD_moveCursor+0x8>
    6702:	0f 92       	push	r0
    6704:	cd b7       	in	r28, 0x3d	; 61
    6706:	de b7       	in	r29, 0x3e	; 62
    6708:	8a 83       	std	Y+2, r24	; 0x02
    670a:	6b 83       	std	Y+3, r22	; 0x03
	uint8 lcd_memory_address;
	
	/* Calculate the required address in the LCD DDRAM */
	switch(row)
    670c:	8a 81       	ldd	r24, Y+2	; 0x02
    670e:	28 2f       	mov	r18, r24
    6710:	30 e0       	ldi	r19, 0x00	; 0
    6712:	3d 83       	std	Y+5, r19	; 0x05
    6714:	2c 83       	std	Y+4, r18	; 0x04
    6716:	8c 81       	ldd	r24, Y+4	; 0x04
    6718:	9d 81       	ldd	r25, Y+5	; 0x05
    671a:	81 30       	cpi	r24, 0x01	; 1
    671c:	91 05       	cpc	r25, r1
    671e:	c1 f0       	breq	.+48     	; 0x6750 <LCD_moveCursor+0x56>
    6720:	2c 81       	ldd	r18, Y+4	; 0x04
    6722:	3d 81       	ldd	r19, Y+5	; 0x05
    6724:	22 30       	cpi	r18, 0x02	; 2
    6726:	31 05       	cpc	r19, r1
    6728:	2c f4       	brge	.+10     	; 0x6734 <LCD_moveCursor+0x3a>
    672a:	8c 81       	ldd	r24, Y+4	; 0x04
    672c:	9d 81       	ldd	r25, Y+5	; 0x05
    672e:	00 97       	sbiw	r24, 0x00	; 0
    6730:	61 f0       	breq	.+24     	; 0x674a <LCD_moveCursor+0x50>
    6732:	19 c0       	rjmp	.+50     	; 0x6766 <LCD_moveCursor+0x6c>
    6734:	2c 81       	ldd	r18, Y+4	; 0x04
    6736:	3d 81       	ldd	r19, Y+5	; 0x05
    6738:	22 30       	cpi	r18, 0x02	; 2
    673a:	31 05       	cpc	r19, r1
    673c:	69 f0       	breq	.+26     	; 0x6758 <LCD_moveCursor+0x5e>
    673e:	8c 81       	ldd	r24, Y+4	; 0x04
    6740:	9d 81       	ldd	r25, Y+5	; 0x05
    6742:	83 30       	cpi	r24, 0x03	; 3
    6744:	91 05       	cpc	r25, r1
    6746:	61 f0       	breq	.+24     	; 0x6760 <LCD_moveCursor+0x66>
    6748:	0e c0       	rjmp	.+28     	; 0x6766 <LCD_moveCursor+0x6c>
	{
		case 0:
			lcd_memory_address=col;
    674a:	8b 81       	ldd	r24, Y+3	; 0x03
    674c:	89 83       	std	Y+1, r24	; 0x01
    674e:	0b c0       	rjmp	.+22     	; 0x6766 <LCD_moveCursor+0x6c>
				break;
		case 1:
			lcd_memory_address=col+0x40;
    6750:	8b 81       	ldd	r24, Y+3	; 0x03
    6752:	80 5c       	subi	r24, 0xC0	; 192
    6754:	89 83       	std	Y+1, r24	; 0x01
    6756:	07 c0       	rjmp	.+14     	; 0x6766 <LCD_moveCursor+0x6c>
				break;
		case 2:
			lcd_memory_address=col+0x10;
    6758:	8b 81       	ldd	r24, Y+3	; 0x03
    675a:	80 5f       	subi	r24, 0xF0	; 240
    675c:	89 83       	std	Y+1, r24	; 0x01
    675e:	03 c0       	rjmp	.+6      	; 0x6766 <LCD_moveCursor+0x6c>
				break;
		case 3:
			lcd_memory_address=col+0x50;
    6760:	8b 81       	ldd	r24, Y+3	; 0x03
    6762:	80 5b       	subi	r24, 0xB0	; 176
    6764:	89 83       	std	Y+1, r24	; 0x01
				break;
	}					
	/* Move the LCD cursor to this specific address */
	LCD_sendCommand(lcd_memory_address | LCD_SET_CURSOR_LOCATION);
    6766:	89 81       	ldd	r24, Y+1	; 0x01
    6768:	80 68       	ori	r24, 0x80	; 128
    676a:	0e 94 76 2f 	call	0x5eec	; 0x5eec <LCD_sendCommand>
}
    676e:	0f 90       	pop	r0
    6770:	0f 90       	pop	r0
    6772:	0f 90       	pop	r0
    6774:	0f 90       	pop	r0
    6776:	0f 90       	pop	r0
    6778:	cf 91       	pop	r28
    677a:	df 91       	pop	r29
    677c:	08 95       	ret

0000677e <LCD_displayStringRowColumn>:
/*
 * Description :
 * Display the required string in a specified row and column index on the screen
 */
void LCD_displayStringRowColumn(uint8 row,uint8 col,const char *Str)
{
    677e:	df 93       	push	r29
    6780:	cf 93       	push	r28
    6782:	00 d0       	rcall	.+0      	; 0x6784 <LCD_displayStringRowColumn+0x6>
    6784:	00 d0       	rcall	.+0      	; 0x6786 <LCD_displayStringRowColumn+0x8>
    6786:	cd b7       	in	r28, 0x3d	; 61
    6788:	de b7       	in	r29, 0x3e	; 62
    678a:	89 83       	std	Y+1, r24	; 0x01
    678c:	6a 83       	std	Y+2, r22	; 0x02
    678e:	5c 83       	std	Y+4, r21	; 0x04
    6790:	4b 83       	std	Y+3, r20	; 0x03
	LCD_moveCursor(row,col); /* go to to the required LCD position */
    6792:	89 81       	ldd	r24, Y+1	; 0x01
    6794:	6a 81       	ldd	r22, Y+2	; 0x02
    6796:	0e 94 7d 33 	call	0x66fa	; 0x66fa <LCD_moveCursor>
	LCD_displayString(Str); /* display the string */
    679a:	8b 81       	ldd	r24, Y+3	; 0x03
    679c:	9c 81       	ldd	r25, Y+4	; 0x04
    679e:	0e 94 54 33 	call	0x66a8	; 0x66a8 <LCD_displayString>
}
    67a2:	0f 90       	pop	r0
    67a4:	0f 90       	pop	r0
    67a6:	0f 90       	pop	r0
    67a8:	0f 90       	pop	r0
    67aa:	cf 91       	pop	r28
    67ac:	df 91       	pop	r29
    67ae:	08 95       	ret

000067b0 <LCD_intgerToString>:
/*
 * Description :
 * Display the required decimal value on the screen
 */
void LCD_intgerToString(int data)
{
    67b0:	df 93       	push	r29
    67b2:	cf 93       	push	r28
    67b4:	cd b7       	in	r28, 0x3d	; 61
    67b6:	de b7       	in	r29, 0x3e	; 62
    67b8:	62 97       	sbiw	r28, 0x12	; 18
    67ba:	0f b6       	in	r0, 0x3f	; 63
    67bc:	f8 94       	cli
    67be:	de bf       	out	0x3e, r29	; 62
    67c0:	0f be       	out	0x3f, r0	; 63
    67c2:	cd bf       	out	0x3d, r28	; 61
    67c4:	9a 8b       	std	Y+18, r25	; 0x12
    67c6:	89 8b       	std	Y+17, r24	; 0x11
   char buff[16]; /* String to hold the ascii result */
   itoa(data,buff,10); /* Use itoa C function to convert the data to its corresponding ASCII value, 10 for decimal */
    67c8:	89 89       	ldd	r24, Y+17	; 0x11
    67ca:	9a 89       	ldd	r25, Y+18	; 0x12
    67cc:	9e 01       	movw	r18, r28
    67ce:	2f 5f       	subi	r18, 0xFF	; 255
    67d0:	3f 4f       	sbci	r19, 0xFF	; 255
    67d2:	b9 01       	movw	r22, r18
    67d4:	4a e0       	ldi	r20, 0x0A	; 10
    67d6:	50 e0       	ldi	r21, 0x00	; 0
    67d8:	0e 94 c4 35 	call	0x6b88	; 0x6b88 <itoa>
   LCD_displayString(buff); /* Display the string */
    67dc:	ce 01       	movw	r24, r28
    67de:	01 96       	adiw	r24, 0x01	; 1
    67e0:	0e 94 54 33 	call	0x66a8	; 0x66a8 <LCD_displayString>
}
    67e4:	62 96       	adiw	r28, 0x12	; 18
    67e6:	0f b6       	in	r0, 0x3f	; 63
    67e8:	f8 94       	cli
    67ea:	de bf       	out	0x3e, r29	; 62
    67ec:	0f be       	out	0x3f, r0	; 63
    67ee:	cd bf       	out	0x3d, r28	; 61
    67f0:	cf 91       	pop	r28
    67f2:	df 91       	pop	r29
    67f4:	08 95       	ret

000067f6 <LCD_clearScreen>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
    67f6:	df 93       	push	r29
    67f8:	cf 93       	push	r28
    67fa:	cd b7       	in	r28, 0x3d	; 61
    67fc:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
    67fe:	81 e0       	ldi	r24, 0x01	; 1
    6800:	0e 94 76 2f 	call	0x5eec	; 0x5eec <LCD_sendCommand>
}
    6804:	cf 91       	pop	r28
    6806:	df 91       	pop	r29
    6808:	08 95       	ret

0000680a <LM35_getTemperature>:
/*
 * Description :
 * Function responsible for calculate the temperature from the ADC digital value.
 */
uint8 LM35_getTemperature(void)
{
    680a:	df 93       	push	r29
    680c:	cf 93       	push	r28
    680e:	00 d0       	rcall	.+0      	; 0x6810 <LM35_getTemperature+0x6>
    6810:	0f 92       	push	r0
    6812:	cd b7       	in	r28, 0x3d	; 61
    6814:	de b7       	in	r29, 0x3e	; 62
	uint8 temp_value = 0;
    6816:	1b 82       	std	Y+3, r1	; 0x03

	uint16 adc_value = 0;
    6818:	1a 82       	std	Y+2, r1	; 0x02
    681a:	19 82       	std	Y+1, r1	; 0x01

	/* Read ADC channel where the temperature sensor is connected */
	adc_value = ADC_readChannel(SENSOR_CHANNEL_ID);
    681c:	82 e0       	ldi	r24, 0x02	; 2
    681e:	0e 94 0c 2b 	call	0x5618	; 0x5618 <ADC_readChannel>
    6822:	9a 83       	std	Y+2, r25	; 0x02
    6824:	89 83       	std	Y+1, r24	; 0x01

	/* Calculate the temperature from the ADC value*/
	temp_value = (uint8)(((uint32)adc_value*SENSOR_MAX_TEMPERATURE*ADC_REF_VOLT_VALUE)/(ADC_MAXIMUM_VALUE*SENSOR_MAX_VOLT_VALUE));
    6826:	89 81       	ldd	r24, Y+1	; 0x01
    6828:	9a 81       	ldd	r25, Y+2	; 0x02
    682a:	cc 01       	movw	r24, r24
    682c:	a0 e0       	ldi	r26, 0x00	; 0
    682e:	b0 e0       	ldi	r27, 0x00	; 0
    6830:	26 e9       	ldi	r18, 0x96	; 150
    6832:	30 e0       	ldi	r19, 0x00	; 0
    6834:	40 e0       	ldi	r20, 0x00	; 0
    6836:	50 e0       	ldi	r21, 0x00	; 0
    6838:	bc 01       	movw	r22, r24
    683a:	cd 01       	movw	r24, r26
    683c:	0e 94 5e 35 	call	0x6abc	; 0x6abc <__mulsi3>
    6840:	dc 01       	movw	r26, r24
    6842:	cb 01       	movw	r24, r22
    6844:	bc 01       	movw	r22, r24
    6846:	cd 01       	movw	r24, r26
    6848:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    684c:	dc 01       	movw	r26, r24
    684e:	cb 01       	movw	r24, r22
    6850:	bc 01       	movw	r22, r24
    6852:	cd 01       	movw	r24, r26
    6854:	2a e0       	ldi	r18, 0x0A	; 10
    6856:	37 ed       	ldi	r19, 0xD7	; 215
    6858:	43 e2       	ldi	r20, 0x23	; 35
    685a:	50 e4       	ldi	r21, 0x40	; 64
    685c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6860:	dc 01       	movw	r26, r24
    6862:	cb 01       	movw	r24, r22
    6864:	bc 01       	movw	r22, r24
    6866:	cd 01       	movw	r24, r26
    6868:	20 e0       	ldi	r18, 0x00	; 0
    686a:	30 ed       	ldi	r19, 0xD0	; 208
    686c:	4f eb       	ldi	r20, 0xBF	; 191
    686e:	54 e4       	ldi	r21, 0x44	; 68
    6870:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    6874:	dc 01       	movw	r26, r24
    6876:	cb 01       	movw	r24, r22
    6878:	bc 01       	movw	r22, r24
    687a:	cd 01       	movw	r24, r26
    687c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6880:	dc 01       	movw	r26, r24
    6882:	cb 01       	movw	r24, r22
    6884:	8b 83       	std	Y+3, r24	; 0x03

	return temp_value;
    6886:	8b 81       	ldd	r24, Y+3	; 0x03
}
    6888:	0f 90       	pop	r0
    688a:	0f 90       	pop	r0
    688c:	0f 90       	pop	r0
    688e:	cf 91       	pop	r28
    6890:	df 91       	pop	r29
    6892:	08 95       	ret

00006894 <main>:

Fan_State Fan = FAN_OFF;


void main(void)
{
    6894:	ef 92       	push	r14
    6896:	ff 92       	push	r15
    6898:	0f 93       	push	r16
    689a:	df 93       	push	r29
    689c:	cf 93       	push	r28
    689e:	00 d0       	rcall	.+0      	; 0x68a0 <main+0xc>
    68a0:	0f 92       	push	r0
    68a2:	cd b7       	in	r28, 0x3d	; 61
    68a4:	de b7       	in	r29, 0x3e	; 62
	BaseType_t status;

	ADC_ConfigType ADC_Configurations = {INTERNAL_VOLT,F_CPU_8};
    68a6:	83 e0       	ldi	r24, 0x03	; 3
    68a8:	8a 83       	std	Y+2, r24	; 0x02
    68aa:	83 e0       	ldi	r24, 0x03	; 3
    68ac:	8b 83       	std	Y+3, r24	; 0x03

	LCD_init();  		 /*The delay*/
    68ae:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <LCD_init>
	DcMotor_Init();
    68b2:	0e 94 43 2b 	call	0x5686	; 0x5686 <DcMotor_Init>
	ADC_init(&ADC_Configurations);					/* Initialize ADC driver */
    68b6:	ce 01       	movw	r24, r28
    68b8:	02 96       	adiw	r24, 0x02	; 2
    68ba:	0e 94 d9 2a 	call	0x55b2	; 0x55b2 <ADC_init>

//	GPIO_setupPinDirection(PORTC_ID,PIN4_ID,PIN_OUTPUT);
//	GPIO_setupPinDirection(PORTC_ID,PIN5_ID,PIN_OUTPUT);
//	GPIO_setupPinDirection(PORTC_ID,PIN6_ID,PIN_OUTPUT);

	status = xTaskCreate(vLcd_Task, "Lcd_Task", 100, NULL, LCD_Priority, &Lcd_Handler); //180
    68be:	8a e9       	ldi	r24, 0x9A	; 154
    68c0:	94 e3       	ldi	r25, 0x34	; 52
    68c2:	25 e6       	ldi	r18, 0x65	; 101
    68c4:	30 e0       	ldi	r19, 0x00	; 0
    68c6:	e3 e0       	ldi	r30, 0x03	; 3
    68c8:	f8 e0       	ldi	r31, 0x08	; 8
    68ca:	b9 01       	movw	r22, r18
    68cc:	44 e6       	ldi	r20, 0x64	; 100
    68ce:	50 e0       	ldi	r21, 0x00	; 0
    68d0:	20 e0       	ldi	r18, 0x00	; 0
    68d2:	30 e0       	ldi	r19, 0x00	; 0
    68d4:	01 e0       	ldi	r16, 0x01	; 1
    68d6:	7f 01       	movw	r14, r30
    68d8:	0e 94 36 19 	call	0x326c	; 0x326c <xTaskCreate>
    68dc:	89 83       	std	Y+1, r24	; 0x01
	configASSERT(status == pdPASS);								// if status=0 enter infinity loop

	status = xTaskCreate(vTemp_Task, "Temp_Task", 100, NULL, TEMP_Priority, &Temp_Sensor_Handeler);
    68de:	8f ed       	ldi	r24, 0xDF	; 223
    68e0:	94 e3       	ldi	r25, 0x34	; 52
    68e2:	2e e6       	ldi	r18, 0x6E	; 110
    68e4:	30 e0       	ldi	r19, 0x00	; 0
    68e6:	ef ef       	ldi	r30, 0xFF	; 255
    68e8:	f7 e0       	ldi	r31, 0x07	; 7
    68ea:	b9 01       	movw	r22, r18
    68ec:	44 e6       	ldi	r20, 0x64	; 100
    68ee:	50 e0       	ldi	r21, 0x00	; 0
    68f0:	20 e0       	ldi	r18, 0x00	; 0
    68f2:	30 e0       	ldi	r19, 0x00	; 0
    68f4:	03 e0       	ldi	r16, 0x03	; 3
    68f6:	7f 01       	movw	r14, r30
    68f8:	0e 94 36 19 	call	0x326c	; 0x326c <xTaskCreate>
    68fc:	89 83       	std	Y+1, r24	; 0x01
//	if( Temp_Sensor_Handeler == NULL )
//	{
//		G_Error = 1;
//	}

	status = xTaskCreate(vMotor_LED_Task, "Motor_LED_Task", 100, NULL,MOTOR_LED_Priority, &Dc_motor_Handler);
    68fe:	81 ef       	ldi	r24, 0xF1	; 241
    6900:	94 e3       	ldi	r25, 0x34	; 52
    6902:	28 e7       	ldi	r18, 0x78	; 120
    6904:	30 e0       	ldi	r19, 0x00	; 0
    6906:	e1 e0       	ldi	r30, 0x01	; 1
    6908:	f8 e0       	ldi	r31, 0x08	; 8
    690a:	b9 01       	movw	r22, r18
    690c:	44 e6       	ldi	r20, 0x64	; 100
    690e:	50 e0       	ldi	r21, 0x00	; 0
    6910:	20 e0       	ldi	r18, 0x00	; 0
    6912:	30 e0       	ldi	r19, 0x00	; 0
    6914:	02 e0       	ldi	r16, 0x02	; 2
    6916:	7f 01       	movw	r14, r30
    6918:	0e 94 36 19 	call	0x326c	; 0x326c <xTaskCreate>
    691c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT(status == pdPASS); 							// if status=0 enter infinity loop


	vTaskStartScheduler();
    691e:	0e 94 24 1d 	call	0x3a48	; 0x3a48 <vTaskStartScheduler>

}
    6922:	0f 90       	pop	r0
    6924:	0f 90       	pop	r0
    6926:	0f 90       	pop	r0
    6928:	cf 91       	pop	r28
    692a:	df 91       	pop	r29
    692c:	0f 91       	pop	r16
    692e:	ff 90       	pop	r15
    6930:	ef 90       	pop	r14
    6932:	08 95       	ret

00006934 <vLcd_Task>:

void vLcd_Task(void *pvparamters)
{
    6934:	df 93       	push	r29
    6936:	cf 93       	push	r28
    6938:	00 d0       	rcall	.+0      	; 0x693a <vLcd_Task+0x6>
    693a:	cd b7       	in	r28, 0x3d	; 61
    693c:	de b7       	in	r29, 0x3e	; 62
    693e:	9a 83       	std	Y+2, r25	; 0x02
    6940:	89 83       	std	Y+1, r24	; 0x01
//			/*do nothing no errors*/
//		}
//		GPIO_writePin(PORTD_ID, PIN3_ID , LOGIC_HIGH);


		if(Fan == FAN_OFF)
    6942:	80 91 fe 07 	lds	r24, 0x07FE
    6946:	88 23       	and	r24, r24
    6948:	49 f4       	brne	.+18     	; 0x695c <vLcd_Task+0x28>
		{
			LCD_moveCursor(0,0);
    694a:	80 e0       	ldi	r24, 0x00	; 0
    694c:	60 e0       	ldi	r22, 0x00	; 0
    694e:	0e 94 7d 33 	call	0x66fa	; 0x66fa <LCD_moveCursor>
			LCD_displayString("FAN is OFF");
    6952:	87 e8       	ldi	r24, 0x87	; 135
    6954:	90 e0       	ldi	r25, 0x00	; 0
    6956:	0e 94 54 33 	call	0x66a8	; 0x66a8 <LCD_displayString>
    695a:	08 c0       	rjmp	.+16     	; 0x696c <vLcd_Task+0x38>
		}
		else
		{
			LCD_moveCursor(0,0);
    695c:	80 e0       	ldi	r24, 0x00	; 0
    695e:	60 e0       	ldi	r22, 0x00	; 0
    6960:	0e 94 7d 33 	call	0x66fa	; 0x66fa <LCD_moveCursor>
			LCD_displayString("FAN is ON ");
    6964:	82 e9       	ldi	r24, 0x92	; 146
    6966:	90 e0       	ldi	r25, 0x00	; 0
    6968:	0e 94 54 33 	call	0x66a8	; 0x66a8 <LCD_displayString>
		}

		LCD_moveCursor(1,0);
    696c:	81 e0       	ldi	r24, 0x01	; 1
    696e:	60 e0       	ldi	r22, 0x00	; 0
    6970:	0e 94 7d 33 	call	0x66fa	; 0x66fa <LCD_moveCursor>
		LCD_displayString("Temp =    C");
    6974:	8d e9       	ldi	r24, 0x9D	; 157
    6976:	90 e0       	ldi	r25, 0x00	; 0
    6978:	0e 94 54 33 	call	0x66a8	; 0x66a8 <LCD_displayString>

		LCD_moveCursor(1,7);
    697c:	81 e0       	ldi	r24, 0x01	; 1
    697e:	67 e0       	ldi	r22, 0x07	; 7
    6980:	0e 94 7d 33 	call	0x66fa	; 0x66fa <LCD_moveCursor>
		if(G_temp >= 100)
    6984:	80 91 fd 07 	lds	r24, 0x07FD
    6988:	84 36       	cpi	r24, 0x64	; 100
    698a:	58 f0       	brcs	.+22     	; 0x69a2 <vLcd_Task+0x6e>
		{
			LCD_intgerToString(G_temp);
    698c:	80 91 fd 07 	lds	r24, 0x07FD
    6990:	88 2f       	mov	r24, r24
    6992:	90 e0       	ldi	r25, 0x00	; 0
    6994:	0e 94 d8 33 	call	0x67b0	; 0x67b0 <LCD_intgerToString>
//			GPIO_writePin(PORTD_ID, PIN3_ID , LOGIC_LOW);

			vTaskDelay(pdMS_TO_TICKS(2000)); /* sends the task to the block state for 2000 ms*/
    6998:	81 e2       	ldi	r24, 0x21	; 33
    699a:	90 e0       	ldi	r25, 0x00	; 0
    699c:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <vTaskDelay>
    69a0:	d0 cf       	rjmp	.-96     	; 0x6942 <vLcd_Task+0xe>

		}
		else
		{
			LCD_intgerToString(G_temp);
    69a2:	80 91 fd 07 	lds	r24, 0x07FD
    69a6:	88 2f       	mov	r24, r24
    69a8:	90 e0       	ldi	r25, 0x00	; 0
    69aa:	0e 94 d8 33 	call	0x67b0	; 0x67b0 <LCD_intgerToString>
			/* In case the digital value is two or one digits print space in the next digit place */
			LCD_displayCharacter(' ');
    69ae:	80 e2       	ldi	r24, 0x20	; 32
    69b0:	0e 94 65 31 	call	0x62ca	; 0x62ca <LCD_displayCharacter>
//			GPIO_writePin(PORTD_ID, PIN3_ID , LOGIC_LOW);

			vTaskDelay(pdMS_TO_TICKS(2000));
    69b4:	81 e2       	ldi	r24, 0x21	; 33
    69b6:	90 e0       	ldi	r25, 0x00	; 0
    69b8:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <vTaskDelay>
    69bc:	c2 cf       	rjmp	.-124    	; 0x6942 <vLcd_Task+0xe>

000069be <vTemp_Task>:

	}
}

void vTemp_Task(void *pvparamters)
{
    69be:	df 93       	push	r29
    69c0:	cf 93       	push	r28
    69c2:	00 d0       	rcall	.+0      	; 0x69c4 <vTemp_Task+0x6>
    69c4:	cd b7       	in	r28, 0x3d	; 61
    69c6:	de b7       	in	r29, 0x3e	; 62
    69c8:	9a 83       	std	Y+2, r25	; 0x02
    69ca:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
//		GPIO_writePin(PORTD_ID, PIN4_ID , LOGIC_HIGH);

		G_temp = 0 ;
    69cc:	10 92 fd 07 	sts	0x07FD, r1
		G_temp = LM35_getTemperature();
    69d0:	0e 94 05 34 	call	0x680a	; 0x680a <LM35_getTemperature>
    69d4:	80 93 fd 07 	sts	0x07FD, r24

//		GPIO_writePin(PORTD_ID, PIN4_ID , LOGIC_LOW);

		vTaskDelay(pdMS_TO_TICKS(1000));
    69d8:	80 e1       	ldi	r24, 0x10	; 16
    69da:	90 e0       	ldi	r25, 0x00	; 0
    69dc:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <vTaskDelay>
    69e0:	f5 cf       	rjmp	.-22     	; 0x69cc <vTemp_Task+0xe>

000069e2 <vMotor_LED_Task>:
//		}
	}
}

void vMotor_LED_Task(void *pvparamters)
{
    69e2:	df 93       	push	r29
    69e4:	cf 93       	push	r28
    69e6:	00 d0       	rcall	.+0      	; 0x69e8 <vMotor_LED_Task+0x6>
    69e8:	cd b7       	in	r28, 0x3d	; 61
    69ea:	de b7       	in	r29, 0x3e	; 62
    69ec:	9a 83       	std	Y+2, r25	; 0x02
    69ee:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
//		GPIO_writePin(PORTD_ID, PIN5_ID , LOGIC_HIGH);

		 if(G_temp >= 30)
    69f0:	80 91 fd 07 	lds	r24, 0x07FD
    69f4:	8e 31       	cpi	r24, 0x1E	; 30
    69f6:	40 f0       	brcs	.+16     	; 0x6a08 <vMotor_LED_Task+0x26>
		{
			Fan = FAN_ON;
    69f8:	81 e0       	ldi	r24, 0x01	; 1
    69fa:	80 93 fe 07 	sts	0x07FE, r24
			DcMotor_Rotate(DC_MOTOR_CW,50); /* Rotates the motor with 50% from its speed */
    69fe:	81 e0       	ldi	r24, 0x01	; 1
    6a00:	62 e3       	ldi	r22, 0x32	; 50
    6a02:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <DcMotor_Rotate>
    6a06:	12 c0       	rjmp	.+36     	; 0x6a2c <vMotor_LED_Task+0x4a>
		}
		else if(G_temp <= 20)
    6a08:	80 91 fd 07 	lds	r24, 0x07FD
    6a0c:	85 31       	cpi	r24, 0x15	; 21
    6a0e:	40 f4       	brcc	.+16     	; 0x6a20 <vMotor_LED_Task+0x3e>
		{
			Fan = FAN_ON;
    6a10:	81 e0       	ldi	r24, 0x01	; 1
    6a12:	80 93 fe 07 	sts	0x07FE, r24
			DcMotor_Rotate(DC_MOTOR_ACW,50); /* Rotates the motor with 50% from its speed */
    6a16:	82 e0       	ldi	r24, 0x02	; 2
    6a18:	62 e3       	ldi	r22, 0x32	; 50
    6a1a:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <DcMotor_Rotate>
    6a1e:	06 c0       	rjmp	.+12     	; 0x6a2c <vMotor_LED_Task+0x4a>
		}
		else
		{
			Fan = FAN_OFF;
    6a20:	10 92 fe 07 	sts	0x07FE, r1
			DcMotor_Rotate(DC_MOTOR_STOP,0); /* Stop the motor */
    6a24:	80 e0       	ldi	r24, 0x00	; 0
    6a26:	60 e0       	ldi	r22, 0x00	; 0
    6a28:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <DcMotor_Rotate>
		}
//		GPIO_writePin(PORTD_ID, PIN5_ID, LOGIC_LOW);

		vTaskDelay(pdMS_TO_TICKS(50));
    6a2c:	82 e3       	ldi	r24, 0x32	; 50
    6a2e:	90 e0       	ldi	r25, 0x00	; 0
    6a30:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <vTaskDelay>
    6a34:	dd cf       	rjmp	.-70     	; 0x69f0 <vMotor_LED_Task+0xe>

00006a36 <PWM_Timer0_Start>:
 * 3. Setup the prescaler with F_CPU/8
 * 4. Setup the compare value based on the required input duty cycle
 * 5. Setup the direction for OC0 as output pin
 */
void PWM_Timer0_Start(uint8 duty_cycle)
{
    6a36:	0f 93       	push	r16
    6a38:	1f 93       	push	r17
    6a3a:	df 93       	push	r29
    6a3c:	cf 93       	push	r28
    6a3e:	0f 92       	push	r0
    6a40:	cd b7       	in	r28, 0x3d	; 61
    6a42:	de b7       	in	r29, 0x3e	; 62
    6a44:	89 83       	std	Y+1, r24	; 0x01
	TCNT0 = 0; /* Timer0 initial value */
    6a46:	e2 e5       	ldi	r30, 0x52	; 82
    6a48:	f0 e0       	ldi	r31, 0x00	; 0
    6a4a:	10 82       	st	Z, r1

	OCR0  = ((float)duty_cycle / 100) * 255; /* Set Compare value */
    6a4c:	0c e5       	ldi	r16, 0x5C	; 92
    6a4e:	10 e0       	ldi	r17, 0x00	; 0
    6a50:	89 81       	ldd	r24, Y+1	; 0x01
    6a52:	88 2f       	mov	r24, r24
    6a54:	90 e0       	ldi	r25, 0x00	; 0
    6a56:	a0 e0       	ldi	r26, 0x00	; 0
    6a58:	b0 e0       	ldi	r27, 0x00	; 0
    6a5a:	bc 01       	movw	r22, r24
    6a5c:	cd 01       	movw	r24, r26
    6a5e:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    6a62:	dc 01       	movw	r26, r24
    6a64:	cb 01       	movw	r24, r22
    6a66:	bc 01       	movw	r22, r24
    6a68:	cd 01       	movw	r24, r26
    6a6a:	20 e0       	ldi	r18, 0x00	; 0
    6a6c:	30 e0       	ldi	r19, 0x00	; 0
    6a6e:	48 ec       	ldi	r20, 0xC8	; 200
    6a70:	52 e4       	ldi	r21, 0x42	; 66
    6a72:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    6a76:	dc 01       	movw	r26, r24
    6a78:	cb 01       	movw	r24, r22
    6a7a:	bc 01       	movw	r22, r24
    6a7c:	cd 01       	movw	r24, r26
    6a7e:	20 e0       	ldi	r18, 0x00	; 0
    6a80:	30 e0       	ldi	r19, 0x00	; 0
    6a82:	4f e7       	ldi	r20, 0x7F	; 127
    6a84:	53 e4       	ldi	r21, 0x43	; 67
    6a86:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6a8a:	dc 01       	movw	r26, r24
    6a8c:	cb 01       	movw	r24, r22
    6a8e:	bc 01       	movw	r22, r24
    6a90:	cd 01       	movw	r24, r26
    6a92:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6a96:	dc 01       	movw	r26, r24
    6a98:	cb 01       	movw	r24, r22
    6a9a:	f8 01       	movw	r30, r16
    6a9c:	80 83       	st	Z, r24
	 * 1. Fast PWM mode FOC0=0
	 * 2. Fast PWM Mode WGM01=1 & WGM00=1
	 * 3. Clear OC0 when match occurs (non inverted mode) COM00=0 & COM01=1
	 * 4. clock = F_CPU/8 CS00=0 CS01=1 CS02=0
	 */
	TCCR0 = (1<<WGM00) | (1<<WGM01) | (1<<COM01) | (1<<CS01);
    6a9e:	e3 e5       	ldi	r30, 0x53	; 83
    6aa0:	f0 e0       	ldi	r31, 0x00	; 0
    6aa2:	8a e6       	ldi	r24, 0x6A	; 106
    6aa4:	80 83       	st	Z, r24

	/* Configure PB3/ OC0 as output pin --> pin where the PWM signal is generated from Timer0 */
	GPIO_setupPinDirection(TIMER0_OCO_PORT_ID,TIMER0_OCO_PIN_ID,PIN_OUTPUT);
    6aa6:	81 e0       	ldi	r24, 0x01	; 1
    6aa8:	63 e0       	ldi	r22, 0x03	; 3
    6aaa:	41 e0       	ldi	r20, 0x01	; 1
    6aac:	0e 94 9c 2b 	call	0x5738	; 0x5738 <GPIO_setupPinDirection>
}
    6ab0:	0f 90       	pop	r0
    6ab2:	cf 91       	pop	r28
    6ab4:	df 91       	pop	r29
    6ab6:	1f 91       	pop	r17
    6ab8:	0f 91       	pop	r16
    6aba:	08 95       	ret

00006abc <__mulsi3>:
    6abc:	62 9f       	mul	r22, r18
    6abe:	d0 01       	movw	r26, r0
    6ac0:	73 9f       	mul	r23, r19
    6ac2:	f0 01       	movw	r30, r0
    6ac4:	82 9f       	mul	r24, r18
    6ac6:	e0 0d       	add	r30, r0
    6ac8:	f1 1d       	adc	r31, r1
    6aca:	64 9f       	mul	r22, r20
    6acc:	e0 0d       	add	r30, r0
    6ace:	f1 1d       	adc	r31, r1
    6ad0:	92 9f       	mul	r25, r18
    6ad2:	f0 0d       	add	r31, r0
    6ad4:	83 9f       	mul	r24, r19
    6ad6:	f0 0d       	add	r31, r0
    6ad8:	74 9f       	mul	r23, r20
    6ada:	f0 0d       	add	r31, r0
    6adc:	65 9f       	mul	r22, r21
    6ade:	f0 0d       	add	r31, r0
    6ae0:	99 27       	eor	r25, r25
    6ae2:	72 9f       	mul	r23, r18
    6ae4:	b0 0d       	add	r27, r0
    6ae6:	e1 1d       	adc	r30, r1
    6ae8:	f9 1f       	adc	r31, r25
    6aea:	63 9f       	mul	r22, r19
    6aec:	b0 0d       	add	r27, r0
    6aee:	e1 1d       	adc	r30, r1
    6af0:	f9 1f       	adc	r31, r25
    6af2:	bd 01       	movw	r22, r26
    6af4:	cf 01       	movw	r24, r30
    6af6:	11 24       	eor	r1, r1
    6af8:	08 95       	ret

00006afa <__prologue_saves__>:
    6afa:	2f 92       	push	r2
    6afc:	3f 92       	push	r3
    6afe:	4f 92       	push	r4
    6b00:	5f 92       	push	r5
    6b02:	6f 92       	push	r6
    6b04:	7f 92       	push	r7
    6b06:	8f 92       	push	r8
    6b08:	9f 92       	push	r9
    6b0a:	af 92       	push	r10
    6b0c:	bf 92       	push	r11
    6b0e:	cf 92       	push	r12
    6b10:	df 92       	push	r13
    6b12:	ef 92       	push	r14
    6b14:	ff 92       	push	r15
    6b16:	0f 93       	push	r16
    6b18:	1f 93       	push	r17
    6b1a:	cf 93       	push	r28
    6b1c:	df 93       	push	r29
    6b1e:	cd b7       	in	r28, 0x3d	; 61
    6b20:	de b7       	in	r29, 0x3e	; 62
    6b22:	ca 1b       	sub	r28, r26
    6b24:	db 0b       	sbc	r29, r27
    6b26:	0f b6       	in	r0, 0x3f	; 63
    6b28:	f8 94       	cli
    6b2a:	de bf       	out	0x3e, r29	; 62
    6b2c:	0f be       	out	0x3f, r0	; 63
    6b2e:	cd bf       	out	0x3d, r28	; 61
    6b30:	09 94       	ijmp

00006b32 <__epilogue_restores__>:
    6b32:	2a 88       	ldd	r2, Y+18	; 0x12
    6b34:	39 88       	ldd	r3, Y+17	; 0x11
    6b36:	48 88       	ldd	r4, Y+16	; 0x10
    6b38:	5f 84       	ldd	r5, Y+15	; 0x0f
    6b3a:	6e 84       	ldd	r6, Y+14	; 0x0e
    6b3c:	7d 84       	ldd	r7, Y+13	; 0x0d
    6b3e:	8c 84       	ldd	r8, Y+12	; 0x0c
    6b40:	9b 84       	ldd	r9, Y+11	; 0x0b
    6b42:	aa 84       	ldd	r10, Y+10	; 0x0a
    6b44:	b9 84       	ldd	r11, Y+9	; 0x09
    6b46:	c8 84       	ldd	r12, Y+8	; 0x08
    6b48:	df 80       	ldd	r13, Y+7	; 0x07
    6b4a:	ee 80       	ldd	r14, Y+6	; 0x06
    6b4c:	fd 80       	ldd	r15, Y+5	; 0x05
    6b4e:	0c 81       	ldd	r16, Y+4	; 0x04
    6b50:	1b 81       	ldd	r17, Y+3	; 0x03
    6b52:	aa 81       	ldd	r26, Y+2	; 0x02
    6b54:	b9 81       	ldd	r27, Y+1	; 0x01
    6b56:	ce 0f       	add	r28, r30
    6b58:	d1 1d       	adc	r29, r1
    6b5a:	0f b6       	in	r0, 0x3f	; 63
    6b5c:	f8 94       	cli
    6b5e:	de bf       	out	0x3e, r29	; 62
    6b60:	0f be       	out	0x3f, r0	; 63
    6b62:	cd bf       	out	0x3d, r28	; 61
    6b64:	ed 01       	movw	r28, r26
    6b66:	08 95       	ret

00006b68 <memcpy>:
    6b68:	fb 01       	movw	r30, r22
    6b6a:	dc 01       	movw	r26, r24
    6b6c:	02 c0       	rjmp	.+4      	; 0x6b72 <memcpy+0xa>
    6b6e:	01 90       	ld	r0, Z+
    6b70:	0d 92       	st	X+, r0
    6b72:	41 50       	subi	r20, 0x01	; 1
    6b74:	50 40       	sbci	r21, 0x00	; 0
    6b76:	d8 f7       	brcc	.-10     	; 0x6b6e <memcpy+0x6>
    6b78:	08 95       	ret

00006b7a <memset>:
    6b7a:	dc 01       	movw	r26, r24
    6b7c:	01 c0       	rjmp	.+2      	; 0x6b80 <memset+0x6>
    6b7e:	6d 93       	st	X+, r22
    6b80:	41 50       	subi	r20, 0x01	; 1
    6b82:	50 40       	sbci	r21, 0x00	; 0
    6b84:	e0 f7       	brcc	.-8      	; 0x6b7e <memset+0x4>
    6b86:	08 95       	ret

00006b88 <itoa>:
    6b88:	fb 01       	movw	r30, r22
    6b8a:	9f 01       	movw	r18, r30
    6b8c:	e8 94       	clt
    6b8e:	42 30       	cpi	r20, 0x02	; 2
    6b90:	c4 f0       	brlt	.+48     	; 0x6bc2 <itoa+0x3a>
    6b92:	45 32       	cpi	r20, 0x25	; 37
    6b94:	b4 f4       	brge	.+44     	; 0x6bc2 <itoa+0x3a>
    6b96:	4a 30       	cpi	r20, 0x0A	; 10
    6b98:	29 f4       	brne	.+10     	; 0x6ba4 <itoa+0x1c>
    6b9a:	97 fb       	bst	r25, 7
    6b9c:	1e f4       	brtc	.+6      	; 0x6ba4 <itoa+0x1c>
    6b9e:	90 95       	com	r25
    6ba0:	81 95       	neg	r24
    6ba2:	9f 4f       	sbci	r25, 0xFF	; 255
    6ba4:	64 2f       	mov	r22, r20
    6ba6:	77 27       	eor	r23, r23
    6ba8:	0e 94 f5 35 	call	0x6bea	; 0x6bea <__udivmodhi4>
    6bac:	80 5d       	subi	r24, 0xD0	; 208
    6bae:	8a 33       	cpi	r24, 0x3A	; 58
    6bb0:	0c f0       	brlt	.+2      	; 0x6bb4 <itoa+0x2c>
    6bb2:	89 5d       	subi	r24, 0xD9	; 217
    6bb4:	81 93       	st	Z+, r24
    6bb6:	cb 01       	movw	r24, r22
    6bb8:	00 97       	sbiw	r24, 0x00	; 0
    6bba:	a1 f7       	brne	.-24     	; 0x6ba4 <itoa+0x1c>
    6bbc:	16 f4       	brtc	.+4      	; 0x6bc2 <itoa+0x3a>
    6bbe:	5d e2       	ldi	r21, 0x2D	; 45
    6bc0:	51 93       	st	Z+, r21
    6bc2:	10 82       	st	Z, r1
    6bc4:	c9 01       	movw	r24, r18
    6bc6:	0c 94 e5 35 	jmp	0x6bca	; 0x6bca <strrev>

00006bca <strrev>:
    6bca:	dc 01       	movw	r26, r24
    6bcc:	fc 01       	movw	r30, r24
    6bce:	67 2f       	mov	r22, r23
    6bd0:	71 91       	ld	r23, Z+
    6bd2:	77 23       	and	r23, r23
    6bd4:	e1 f7       	brne	.-8      	; 0x6bce <strrev+0x4>
    6bd6:	32 97       	sbiw	r30, 0x02	; 2
    6bd8:	04 c0       	rjmp	.+8      	; 0x6be2 <strrev+0x18>
    6bda:	7c 91       	ld	r23, X
    6bdc:	6d 93       	st	X+, r22
    6bde:	70 83       	st	Z, r23
    6be0:	62 91       	ld	r22, -Z
    6be2:	ae 17       	cp	r26, r30
    6be4:	bf 07       	cpc	r27, r31
    6be6:	c8 f3       	brcs	.-14     	; 0x6bda <strrev+0x10>
    6be8:	08 95       	ret

00006bea <__udivmodhi4>:
    6bea:	aa 1b       	sub	r26, r26
    6bec:	bb 1b       	sub	r27, r27
    6bee:	51 e1       	ldi	r21, 0x11	; 17
    6bf0:	07 c0       	rjmp	.+14     	; 0x6c00 <__udivmodhi4_ep>

00006bf2 <__udivmodhi4_loop>:
    6bf2:	aa 1f       	adc	r26, r26
    6bf4:	bb 1f       	adc	r27, r27
    6bf6:	a6 17       	cp	r26, r22
    6bf8:	b7 07       	cpc	r27, r23
    6bfa:	10 f0       	brcs	.+4      	; 0x6c00 <__udivmodhi4_ep>
    6bfc:	a6 1b       	sub	r26, r22
    6bfe:	b7 0b       	sbc	r27, r23

00006c00 <__udivmodhi4_ep>:
    6c00:	88 1f       	adc	r24, r24
    6c02:	99 1f       	adc	r25, r25
    6c04:	5a 95       	dec	r21
    6c06:	a9 f7       	brne	.-22     	; 0x6bf2 <__udivmodhi4_loop>
    6c08:	80 95       	com	r24
    6c0a:	90 95       	com	r25
    6c0c:	bc 01       	movw	r22, r24
    6c0e:	cd 01       	movw	r24, r26
    6c10:	08 95       	ret

00006c12 <_exit>:
    6c12:	f8 94       	cli

00006c14 <__stop_program>:
    6c14:	ff cf       	rjmp	.-2      	; 0x6c14 <__stop_program>
